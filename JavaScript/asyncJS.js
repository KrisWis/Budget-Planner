// В синхронной системе задачи выполняются одна за другой. Вот пример, где все задачи выполняться друг за другом.
console.log(" I ");

console.log(" eat ");

console.log(" Ice Cream ");

// В асинхронной системе задачи выполняются независимо друг от друга. Вот пример, где задачи выполняться не друг за другом.
console.log("I"); // 1. Сначала выведеться это.

setTimeout(() => {
    console.log("eat"); // 3. В конце, через 2 секунды выведеться это.
}, 2000)

console.log("Ice Cream") // 2. Потом выведеться это.

/* Когда вы вкладываете функцию в другую функцию в качестве аргумента, это называется обратным вызовом или callback. 
При выполнении сложной задачи мы разбиваем ее на более мелкие шаги. 
Чтобы установить связь между этими шагами по времени (необязательно) и порядку, мы используем обратные вызовы.
Пример: */
function one() {
    console.log("one");
}
function two(callback) {
    callback();
}
two(one);

// Но чаще всего обратные вызовы выглядит примерно так:
let production = () => {

    setTimeout(() => {
        console.log("production has started")
        setTimeout(() => {
            console.log("The fruit has been chopped")
            setTimeout(() => {
                console.log(`${stocks.liquid[0]} and ${stocks.liquid[1]} Added`)
                setTimeout(() => {
                    console.log("start the machine")
                    setTimeout(() => {
                        console.log(`Ice cream placed on ${stocks.holder[1]}`)
                        setTimeout(() => {
                            console.log(`${stocks.toppings[0]} as toppings`)
                            setTimeout(() => {
                                console.log("serve Ice cream")
                            }, 2000)
                        }, 3000)
                    }, 2000)
                }, 1000)
            }, 1000)
        }, 2000)
    }, 0)

};

/* Promises были изобретены для избавления от ада обратных вызовов и для лучшей обработки наших задач.
Promise имеет три состояния:
Ожидание. Это начальная стадия. Здесь ничего не происходит.
Решено. Это означает, что задача выполнена.
Отклонено. Это означает, что задача потерпела ошибку или по какой либо другой причине не выполнилась. */
let is_shop_open = true;

let order = (time, work) => {
    /* Наш Promise состоит из 2 частей:
    Решено [resolve].
    Отклонено [reject]. 
    resolve и reject - callback функции. */
    return new Promise((resolve, reject) => {

        if (is_shop_open) { // Если задача решена

            setTimeout(() => {

                resolve(work()) // В качестве аргумента передаём наш колбэк, который передали функции order.

            }, time)

        }

        else { // Если задача не выполнена.
            reject(console.log("Что то пошло не так!"))
        }

    })
}

// Вызываем функцию order() передавай ей колбэк функцию.
order(2000, () => console.log(`${stocks.Fruits[0]} was selected`)); // Шаг 1

/* Метод then() принимает до двух аргументов: функции обратного вызова для выполненных и отклоненных случаев из Promise.
Обработчик then применяется только к экземплярам объектов Promise() и работает так, 
что возвращает promise, когда наше первое Promise будет выполнено.
Таким образом мы можем создать целую цепочку функций. */

order.then(() => { // Шаг 2
    return order(0, () => console.log('production has started'))
});


order.then(() => { // Шаг 3
    return order(2000, () => console.log("Fruit has been chopped"))
});

order.then(() => { // Шаг 4
    return order(1000, () => console.log(`${stocks.liquid[0]} and ${stocks.liquid[1]} added`))
});

order.then(() => { // Шаг 5
    return order(1000, () => console.log("start the machine"))
});

order.then(() => { // Шаг 6
    return order(2000, () => console.log(`ice cream placed on ${stocks.holder[1]}`))
});

order.then(() => { // Шаг 7
    return order(3000, () => console.log(`${stocks.toppings[0]} as toppings`))
});

order.then(() => { // Шаг 8
    return order(2000, () => console.log("Serve Ice Cream"))
});


is_shop_open = false;
/* Чтобы справиться с ошибкой (теперь функция order() будет возвращать reject() т.к is_shop_open равна false), мы используем обработчик .catch. 
Как и .then, он также возвращает Promise, но только в том случае, если наше первоначальное обещание потерпело ошибку. 
Т.е:
1. .then работает, когда Promise сработал как следует.
2. .catch работает, когда Promise отвергнут. 
Таким образом, между предыдущим обработчиком .then и обработчиком .catch не должно быть вообще ничего. */
order.catch(() => {
    /* Сначала выведеться то, что написано в reject() ("Что то пошло не так!"),
    а потом уже выведеться то, что тут ("Ошибка!"). */
    console.log("Ошибка!");
});


/* Существует обработчик .finally, который работает независимо от того, был ли наш Promise выполнен или отклонен. 
Например: независимо от того, обслужили ли мы хотя бы одного клиента или 100 клиентов, наш магазин закроется в конце дня.*/
order.finally(() => {
    console.log("Конец дня.")
})


/* Если написать слово async перед любой обычной функцией, то она станет Promise.
Но, Когда мы используем async/await, мы используем немного другой формат.
При использовании Async/Await вы также можете использовать обработчики .then, .catch и .finally, которые являются основной частью Promises. */
async function test() {

    // В обработчике try нужно писать код, который стоит выполнить.
    try {
        /* Пробуем сделать какое либо действие. Функции в асинхронных функциях вызываются с помощью слова await.
        Ключевое слово await заставляет JavaScript ждать, пока асинхронная функция выполнится и вернет результат. 
        Т.е если после вызова await abc() будет другой код, то он не выполниться, пока не выполниться функция abc(). */
        await abc();
    }

    // В обработчике catch нужно писать код, который выполниться если код в try() потерпет ошибку.
    catch (error) { // Если действие не смогло выполниться, то срабатывает обработчик catch()
        console.log("Функция abc() не запустилась!", error)
    }

    // В обработчике finally нужно писать код, который выполниться в любом случае.
    finally {
        console.log("Я выведусь в любом случае!")
    }
}

test();
console.log("Этот вывод сработает сразу после того, как код в функции test() дойдёт до функции с await.");
