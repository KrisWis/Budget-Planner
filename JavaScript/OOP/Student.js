// Файл, созданный специально для класса всегда называется с большой буквы.

// Чтобы класс наследовался от другого класса, то используется ключевое слово extends, после которого идёт имя наследуемого класса.
class Student extends Person {
  constructor(student_username, student_password, nickname) {
    /* В методе constructor() мы ОБЯЗАНЫ передать то кол-во параметров, которое указано 
    в методе constructor() родительского класса. 
    Делается это с помощью метода super(), куда и передаются параметры. 
    Таким образом мы передаём родительскому классу параметры для инициализации его переменных и не ломаем логику. 
    НО хоть у нас тут имена переменных и другие, не как в классе Person (хотя, могли быть и одинаковые), 
    но всё равно при создании объекта класса Student имена переменных не объявленных с помощью this,
    будут заменены именами переменных из родительского класса. 
    Т.е объект будет выглядеть не так: {student_username: 'ivan', student_password: '3232', nickname: 'Nick'},
    А так: {username: 'ivan', password: '3232', nickname: 'Nick'}.
    Также, нельзя перезаписывать свойства родительского класса своими, т.е
    если бы у нас были свойства username и password, как и в родительском классе, то
    мы не инициализируем их с помощью this, а передаём именно через super, а то будет ошибка. 
    super() нужно вызывать, даже если в родительском элементе нету никаких параметров и нечего передавать. */
    super(student_username, student_password);
    this.nickname = nickname;
  }

  // Можно объявлять функции с таким же именем, что и у родительского класса.
  validatePassword() {
    /* Нужно использовать свойство super, чтобы обращаться к родительским функциями с таким же именем, как функция потомка.
    Если у нас цепочка родителей, то super будет искать метод по всем родителям, пока не найдёт. */
    super.validatePassword();
    if (password.length < 10) {
      return true;
    } else {
      return false;
    }
  }

  print2() {
    /* С помощью свойства super нельзя обращаться к переменным родителя, т.к
    super просто вызывает функцию constructor() и передаёт необходимые для родителя данные. */
    console.log(super.name);
  }
}