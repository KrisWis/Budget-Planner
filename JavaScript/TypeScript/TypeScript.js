/* TYPESCRIPT С 0 ДО ПРОФИ. ПОЛНЫЙ КУРС + ПРАКТИКА [2023] - https://www.youtube.com/watch?v=PYWaUwjofJo */
const employee = {
    name: "Alice",
    age: 30,
    position: "Engineer",
    username: "username",
};
const person = employee;
// В TS каждая переменная или значение имеет тип данных.
/* Есть типы данных: number (числа), string (текст), boolean (логика), symbol (уникальные и неизменяемые значения),
null и undefined (отсутсвующие значения), binInt (большие целые числа).
Также есть специализированные типы: void (для функций, которые ничего не возвращают),
never (для функций, которые имеют вечные циклы или всегда выбрасывают ошибку),
unknown (используется, есть тип входных данных неизвестен на момент написания кода, требуется проверка),
any (любой тип данных). */
// Примеры анотации типов (т.е их определения у переменных):
const isAdult = true;
const age = 26;
const username = 'Ruslan';
// enum это способ группировки констант. Перечисления могут быть строками/числами и тд.
// Пример создания enum. По умолчанию, им присваиваются числовые значения, начиная с нуля.
var Status;
(function (Status) {
    Status[Status["Pending"] = 0] = "Pending";
    Status[Status["Approved"] = 1] = "Approved";
    Status[Status["Rejected"] = 2] = "Rejected"; // 2
})(Status || (Status = {}));
// Но можно задать значения и явно.
(function (Status) {
    Status[Status["Pending2"] = 0] = "Pending2";
    Status[Status["Approved2"] = 1] = "Approved2";
    Status[Status["Rejected2"] = 2] = "Rejected2";
})(Status || (Status = {}));
// Пример применения enum
const currentStatus = Status.Pending;
/* Проще говоря, enum представляет собой некий словарь ключей-значений.
Он делает код более читабельным и удобным.
Также, он делает так, что можно использовать только те ключи, которые есть в enum и не получиться присвоить что то не то. */
// Пример создания и использования строкового enum.
var Message;
(function (Message) {
    Message["Welcome"] = "Welcomeeeee";
    Message["Bye"] = "Byyeee";
})(Message || (Message = {}));
const greeting = Message.Welcome;
/* Пример использования интерфейса.
Объект должен быть в точно такой же структуре, как и интерфейс, и нельзя будет указать какие то доп.свойства, если не указано "propName: string]: any". */
const news = {
    author: 'w',
    category: ['we', 'we'],
    age: 1,
    ages: [1, 2],
    custom: "we",
    custom_arr: ['eew', 'we'],
    future: "ewwe"
};
// Класс, созданный из интерфейса делается с помощью слова implements и может содержать свойства, которых нету в самом интерфейсе.
// Можно наследоваться и от нескольких интерфейсов через запятую и доп.интерфейсы просто добавляют доп.обязательные свойства.
class Yauhen {
    name = "User";
    age = 31;
    nickName = 'nick';
    getPass() {
        return 'str';
    }
}
// Запросы типов помогают извлекать типы данных из переменых и тд.
const newsletter = {
    author: "Ruslam",
    category: ["all"],
    age: 1
};
// Можно типизировать параметры функции. А также, если функция ничего не возвращает то, типизировать её как void.
function test(value, value2) { }
// Либо же, если значение возвращается, то его также можно типизировать.
function test2(value, value2) {
    return 1;
}
// Необязательно указывать test, имя свойства может быть любой строкой и их может быть сколько угодно.
const testing = {
    test: 1,
    testing: 2
};
// Хоть этого свойства в объекте нету, но TS не выдаёт ошибку, т.к думает, что ключи добавляются динамически.
testing.y;
// У классов есть различные модификаторы доступа.
class Person2 {
    // public у всех свойств стоит по-умолчанию и означает публичное использование, т.е везде в коде.
    name;
    // private помечает свойство так, что его можно использовать только внутри кода того класса, внутри которого оно определённо.
    age;
    // protected помечает свойство так, что оно доступно внутри класса, где оно определённо, но и ещё во всех классах-наследниках.
    address;
    // readonly помечает свойства так, что их нельзя нигде изменять, только читать.
    city;
}
// "!" после элемента говорит TS, что этот элемент 100% есть. 
// Например, когда мы ищем элемент по ID, то не факт, что он есть в HTML. "!" даёт понять, что мы уверены, в том, что он есть.
document.getElementById("root");
// Использования обобщения типа. В первом примере, мы указываем, что T будет равно string, а во втором number.
let stringGenerics = { value: "Hello" };
let numberGenerics = { value: 1 };
// Использования обобщения интерфейса.
let interfaceGeneric = { first: 1, second: "s" };
// Пример обощения с функцией
function functionGeneric(item) {
    return item;
}
functionGeneric("aboba");
/* С помощью extends можно сделать так, чтобы обобщение наследовалось от каких то интерфейсов или типов.
Тут константа наследуется от test2, т.е точно должна содержать поле news, но может и свои. */
function logName(value) {
    console.log(value.news);
}
// Передаём обобщение
logName({ news: [1, 32], id: 1 });
// Также, следующим способом можно задавать значения по-умолчанию.
function logName2(value, str) {
    console.log(value.news, str);
}
// Теперь передавать обобщение необязательно, т.к оно по умолчанию test2 и string.
logName2({ news: [1, 32] }, "Rus");
const func = (value) => {
    if (value.type == "Article") {
        return value.UrlArticle;
    }
    return value.UrlNews;
};
const strr = { value: "" };
function test3(value) { }
/* Т.к мы в нашем типе данных указали, что свойство value может быть и строкой, и числом, и null, а test3 принимает только строку,
то мы можем как бы сказать TS, что уверены в том, что свойство value в этой ситуации это строка с помощью конструкции "as {тип данных свойства}".
Но утверждения типов нужно стараться использовать как можно реже. */
test3(strr.value);
// Присваиваем переменной key типа keys строку, которая есть в этом типе данных (мы получили её через keyof).
// Если бы мы присвоили имя, которого нету в ключах INews, то выдало бы ошибку.
const key = "author";
// Когда массив, кортеж и тд помечены, как readonly то и соответствующие для них методы для добавления или изменения элементов работать не будут.
// Чтобы компилировать .ts файл в .js файл нужно следовать инструкции на сайте - https://code.visualstudio.com/docs/typescript/typescript-compiling.
//# sourceMappingURL=TypeScript.js.map