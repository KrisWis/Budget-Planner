

/* TYPESCRIPT С 0 ДО ПРОФИ. ПОЛНЫЙ КУРС + ПРАКТИКА [2023] - https://www.youtube.com/watch?v=PYWaUwjofJo */



// TS - это улучшенная версия JS, он имеет более строгую типизацию. Но его стоит компилировать в JS, т.к браузеры понимают только его.
// Расширение .tsx говорит, что в файле находиться .jsx код, который поддерживает типизацию TypeScript.
// Расширение .ts говорит, что в файле находиться .js код, который поддерживает типизацию TypeScript.
// tsconfig.json представляет основной конфигурационный файл для TS проекта.
// tsconfig.node.js это конфигурационный файл для TS проекта с node.js.
// vite-env.d.ts нужен для работы с vite, который импортирует файлы.
// Файлы с расширением .d.ts используются для определения типов и интерфейсов TS.

// Сильная типизация - это когда нельзя умножать число на строку и тд. При слабой типизации это можно.
// При явной типизации, разработчик явно указывает тип переменной. При неявной типизации, язык сам определяет тип переменной.
// При динамической типизации, типизация проверяется во время выполнения, а при статической - во время компиляции.

// У TypeScript структурная типизация. 
// В номинативной системе, типы совместимы, если они имеют одинаковые имена и объявления, а в структурной совместимость типов определяется их структурой и членами.
// В примере представлена структурная типизация, и это не вызовет ошибку, т.к employee имеет все свойства, которые есть в Person, хоть и имеет дополнительные.
// Но если бы у employee не было бы какого то свойства, которое есть в Person, то TS выдал бы ошибку.
interface Person {
    name: string;
    age: number;
}
const employee = {
    name: "Alice",
    age: 30,
    position: "Engineer",
    username: "username",
}
const person: Person = employee;


// В TS каждая переменная или значение имеет тип данных.
/* Есть типы данных: number (числа), string (текст), boolean (логика), symbol (уникальные и неизменяемые значения), 
null и undefined (отсутсвующие значения), binInt (большие целые числа).
Также есть специализированные типы: void (для функций, которые ничего не возвращают), 
never (для функций, которые имеют вечные циклы или всегда выбрасывают ошибку), 
unknown (используется, есть тип входных данных неизвестен на момент написания кода, требуется проверка),
any (любой тип данных). */
// Примеры анотации типов (т.е их определения у переменных):
const isAdult: boolean = true;
const age: number = 26;
const username: string = 'Ruslan';

// enum это способ группировки констант. Перечисления могут быть строками/числами и тд.
// Пример создания enum. По умолчанию, им присваиваются числовые значения, начиная с нуля.
enum Status {
    Pending, // 0
    Approved, // 1
    Rejected // 2
}

// Но можно задать значения и явно.
enum Status {
    Pending2 = 0,
    Approved2 = 1,
    Rejected2 = 2
}

// Пример применения enum
const currentStatus: Status = Status.Pending;
/* Проще говоря, enum представляет собой некий словарь ключей-значений. 
Он делает код более читабельным и удобным. 
Также, он делает так, что можно использовать только те ключи, которые есть в enum и не получиться присвоить что то не то. */
// Пример создания и использования строкового enum.
enum Message {
    Welcome = "Welcomeeeee",
    Bye = "Byyeee"
}
const greeting: Message = Message.Welcome;


// С помощью слова type можно указать кастомный тип данных и использовать его для типизации.
// Пример ниже является алиасом типа, т.е способом дать существующему типу данных имя для лучшей читаемости кода.
type CategoryType = string;
type NewsType = {
    author: string,
    category: string[],
}
// Пример составного алиаса. Если свойство с этим типом данных указано не будет, то будет равно null. Это также является объединением типов.
type Test = string | null;
// Пример объединения интерфейсов. Т.е тип unification может быть и News, и User, и Admin.
// Но интерфейсы в объединении интерфейсов должны иметь одинаковые поля, иначе выдаст ошибку.
type unification = News | User | Admin;

// Пример пересечения интерфейсов. При пересечении тип будет содержать поля обоих интерфейсов.
type intersection = News & User;

// Интерфейсы помогают описать форму объекта и то как он будет выглядеть. Пример интерфейса:
interface News {
    author: string,
    category: string[], // Т.е category должен иметь массив строк
    age: number,
    ages: number[], // Т.е ages должен иметь массив чисел
    // В следующих двух свойствах используется наш кастомный тип данных
    custom: CategoryType,
    readonly custom_arr: CategoryType[], // Свойство, помеченное ключевым словом readonly не может быть изменено.
    optional?: number, /* Оптиональные свойства помечаются знаком вопроса и являются необязательными для заполнения. 
    Но к ним нужно и обращаться со "?", т.к это часть их имени. */
    [propName: string]: any; // Данная конструкция даёт свободное расширение объекта, т.е можно добавлять и свойства, не указанные в интерфейсе.
}


/* Пример использования интерфейса. 
Объект должен быть в точно такой же структуре, как и интерфейс, и нельзя будет указать какие то доп.свойства, если не указано "propName: string]: any". */
const news: News = {
    author: 'w',
    category: ['we', 'we'],
    age: 1,
    ages: [1, 2],
    custom: "we",
    custom_arr: ['eew', 'we'],
    future: "ewwe"
}

// Пример создания класса на основе интерфейса
interface User {
    name: string,
    age: number,
    getPass(): string, // Указанный тип данных указывает на то, какой тип должен возвращаться из функции.
}

// Класс, созданный из интерфейса делается с помощью слова implements и может содержать свойства, которых нету в самом интерфейсе.
// Можно наследоваться и от нескольких интерфейсов через запятую и доп.интерфейсы просто добавляют доп.обязательные свойства.
class Yauhen implements User {
    name: string = "User";
    age: number = 31;
    nickName: string = 'nick';

    getPass() {
        return 'str';
    }
}

//  Интерфейс может наследоваться от другого интерфейса, тем самым, получая его обязательные свойства. Наследоваться можно от нескольких интерфейсов через запятую.
interface Admin extends User {
    newFunc(): number,
}


// Запросы типов помогают извлекать типы данных из переменых и тд.
const newsletter = {
    author: "Ruslam",
    category: ["all"],
    age: 1
}
// Чтобы извлечь тип из переменной нужно воспользовать словом typeof. Если навестись на название типа, то можно увидеть, что получилось.
type NewsLetterType = typeof newsletter;


// Литеральные типы, это когда тип принимает конкретные значения и объект, использующий этот тип данных, может принимать только эти значения.
type LiteralTypes =
    | "regional"
    | "numeric"
    | "lyfestyle"
    | 1
    | true


// Если разработчик создаёт объект, то в TS у него обязательно нужно определять тип, иначе TS сделает это сам и будет выдавать ошибку.
// Также, есть встроенные в JS библиотеки, в которых имеются свои типы данных для объектов, например библиотека Intl.


// Можно указать, массив с какими конкретно объектами мы ждём, т.е типизировать и их тоже.
interface test {
    news: [Admin, number[], string]
}

// Можно типизировать параметры функции. А также, если функция ничего не возвращает то, типизировать её как void.
function test(value: string, value2: number | string): void { }
// Либо же, если значение возвращается, то его также можно типизировать.
function test2(value: string, value2: number | string): number {
    return 1;
}


// Индексные члены типов работают так, что можно указать, что за место ключа может быть любая строка.
// Мы определяем, что любой ключ объекта должен быть строкой, т.е добавлять можно сколько угодно свойств.
// Проще говоря, Индексные члены типов указывают на то, что ключи могут добавляться динамически.
interface testing {
    [key: string]: number;
}

// Необязательно указывать test, имя свойства может быть любой строкой и их может быть сколько угодно.
const testing: testing = {
    test: 1,
    testing: 2
}

// Хоть этого свойства в объекте нету, но TS не выдаёт ошибку, т.к думает, что ключи добавляются динамически.
testing.y


// У классов есть различные модификаторы доступа.
class Person2 {
    // public у всех свойств стоит по-умолчанию и означает публичное использование, т.е везде в коде.
    public name: string;
    // private помечает свойство так, что его можно использовать только внутри кода того класса, внутри которого оно определённо.
    private age: number;
    // protected помечает свойство так, что оно доступно внутри класса, где оно определённо, но и ещё во всех классах-наследниках.
    protected address: string;
    // readonly помечает свойства так, что их нельзя нигде изменять, только читать.
    readonly city: string;
}


// "!" после элемента говорит TS, что этот элемент 100% есть. 
// Например, когда мы ищем элемент по ID, то не факт, что он есть в HTML. "!" даёт понять, что мы уверены, в том, что он есть.
document.getElementById("root")!


// Generics (обобщения) помогают создавать многозадачные компоненты, которые могут работать с разными типами данных, сохраняя типовую безопасность и строгую типизацию.
// Чтобы создать обобщение, нужно указать в <> после названия типа/интерфейса константу, которая будет "принимать" тип данных.
// Дальше эту константу, можно использовать дальше в типе/интерфейсе для определения типа данных для значения.
type generic<T> = {
    value: T;
}

// Использования обобщения типа. В первом примере, мы указываем, что T будет равно string, а во втором number.
let stringGenerics: generic<string> = { value: "Hello" };
let numberGenerics: generic<number> = { value: 1 };

// Пример обобщения для интерфейса с передаванием нескольких обобщений.
interface InterfaceGeneric<variable, U> {
    first: variable;
    second: U;
}

// Использования обобщения интерфейса.
let interfaceGeneric: InterfaceGeneric<number, string> = { first: 1, second: "s" };

// Пример обощения с функцией
function functionGeneric<T>(item: T): T {
    return item;
}
functionGeneric<string>("aboba")


interface test2 {
    news: number[]
}

/* С помощью extends можно сделать так, чтобы обобщение наследовалось от каких то интерфейсов или типов. 
Тут константа наследуется от test2, т.е точно должна содержать поле news, но может и свои. */
function logName<T extends test2>(value: T): void {
    console.log(value.news);
}

// Передаём обобщение
logName<{ news: number[]; id: number }>({ news: [1, 32], id: 1 });

// Также, следующим способом можно задавать значения по-умолчанию.
function logName2<T extends test2 = test2, U = string>(value: T, str: U): void {
    console.log(value.news, str);
}

// Теперь передавать обобщение необязательно, т.к оно по умолчанию test2 и string.
logName2({ news: [1, 32] }, "Rus");

// Пример условного типа. Это значит, что если T является подтипом test2, то оно по-умолчанию будет test2, если нет, то null.
type IPerson<T> = T extends test2 ? test2 : null;


interface IArticle {
    type: "Article";
    UrlArticle: string;
}

interface INews {
    type: "News";
    UrlNews: string;
    author: string;
}

/* Пример дискриминантного объединения, когда тип может быть одним из нескольких интерфейсов. 
И эти интерфейсы имеют в себе свойство для различия между ними.
Поэтому при использовании этого типа нужно делать проверку по этому свойству, чтобы возвращать нужное значение. */
type ContentType = IArticle | INews;

const func = (value: ContentType) => {
    if (value.type == "Article") {
        return value.UrlArticle;
    }
    return value.UrlNews;
}


type testing2 = {
    value?: string | number | null;
}
const strr: testing2 = { value: "" };
function test3(value: string) { }

/* Т.к мы в нашем типе данных указали, что свойство value может быть и строкой, и числом, и null, а test3 принимает только строку,
то мы можем как бы сказать TS, что уверены в том, что свойство value в этой ситуации это строка с помощью конструкции "as {тип данных свойства}".
Но утверждения типов нужно стараться использовать как можно реже. */
test3(strr.value as string);


// Защитники типов - это когда мы проверяем с помощью typeof тип объекта и на основе этого делаем какие-либо действия.
// Также, это когда мы проверяем есть ли свойство в объекте с помощью "in".


// С помощью keyof можно вытащить из интерфейса/типа все ключи, чтобы сделать новый тип.
type Keys = keyof INews;
// Т.е это выглядит примерно так:
type Keys2 = "type"
    | "UrlNews"
    | "author"

// Присваиваем переменной key типа keys строку, которая есть в этом типе данных (мы получили её через keyof).
// Если бы мы присвоили имя, которого нету в ключах INews, то выдало бы ошибку.
const key: Keys = "author";


// MappedTypes позволяют создавать новые типы на основе старых, преобразуя их свойства.
// Например, тут мы проходимся по всем ключам интерфейса INews и делаем их readonly, а тип данных у них остаётся таким же каким был (определяем с помощью INews[K]).
type readonlyNews = { readonly [K in keyof INews]: INews[K] };

// С помощью префика "-" можно удалить какой-либо модификатор. Также, можно добавить модификатор "?".
type readonlyNews2 = { -readonly [K in keyof INews]?: INews[K] };

// Теперь все свойства интерфейса будут иметь тип string.
type readonlyNews3 = { [K in keyof INews]: string };

// Данным образом, обращаясь к свойству интерфейса можно получить, то какой он имеет тип данных и присвоить этот тип данных.
type NewsType2 = INews["author"];


// Утилитарные типы изменяют интерфейс добавляя к ниму различные модификаторы.

// 1 группа утилитарных типов:
// Утилитарный тип Readonly сделает все свойства интерфейса неизменяемыми.
type ReadOnlyNews = Readonly<INews>;

// Утилитарный тип Partial сделает все свойства интерфейса необязательными.
type PartialNews = Partial<INews>;

// Утилитарный тип Required сделает все свойства интерфейса обязательными.
type RequiredNews = Required<INews>;

/* Утилитарный тип Pick выбирает из переданного интерфейса определённые свойства, которые разделяются с помощью '|'
и в новом типе, созданном с помощью Pick будут только эти свойства, которые имеют те же типы данных, что и в переданном интерфейса.
Проще говоря, Pick берёт конкретные свойства интерфейса для создания нового типа. */
type PickNews = Pick<INews, 'author' | 'type'>;

// Утилитарный тип Record создаёт новый тип данных, где все переданные свойства будут иметь одинаковый (переданный) тип данных.
/* Чтобы добавить в тип данных, созданный с помощью Record, какое-то значение, имеющее отличный от остальных свойств тип данных,
то нужно использовать "&" для добавления этого свойства. */
type RecordNews = Record<'value1' | 'value2' | 'value3', string> & { value: number };

// 2 группа утилитарных типов:
// Утилитарный тип Exclude убирает переданная свойства из литерального объединения типов.
type ExcludeNews = Exclude<keyof INews, "type" | "author">;

// Утилитарный тип Extract оставляет в литеральном объединении типов только переданные свойства.
type ExtractNews = Extract<keyof INews, "type" | "author">;

// Утилитарный тип NonNullable принимает свойство интерфейса/типа и делает его обязательным и не равным null или undefined.
type NonNullableValue = NonNullable<testing2["value"]>;

// Утилитарный тип ReturnType принимает тип функции и возвращает тип возвращаемого значения этой функции.
type ReturnTypeFunc = ReturnType<typeof test2>;

// Утилитарный тип InstanceType извлекает тип экземпляра класса из типа конструктора класса.
type InstanceTypeClass = InstanceType<typeof Yauhen>;

// Утилитарный тип Omit убирает переданные свойства из переданного интерфейса/типа.
type OmitNews = Omit<INews, "type" | "author">;


// Когда массив, кортеж и тд помечены, как readonly то и соответствующие для них методы для добавления или изменения элементов работать не будут.


// Чтобы компилировать .ts файл в .js файл нужно следовать инструкции на сайте - https://code.visualstudio.com/docs/typescript/typescript-compiling.