

/* ТИПЫ ДАННЫХ - https://www.youtube.com/watch?v=n0sPFaLsNeI&list=PLY4rE9dstrJymG1GyPLgOKsJNq9r-p6pX */

"use strict"; // Когда "use strict" находится в начале скрипта, весь сценарий работает в «современном» режиме.


/* document - это объект, который позволяет управлять DOM-деревом. 
Функция write() служит для того, чтобы выводить текст, написанный в скобках. 
Но он очень редко используется, т.к не может вывести текст внутри определённого тега. */
document.write("JavaScript говорит привет!");
/* console - объект консоли.
Функция log() выводит текст в консоль. */
console.log("JavaScript говорит привет!");
/* Функция info() нужна для вывода информатионного текста в консоль. */
console.info("JavaScript говорит привет!");
/* Функция error() нужна для вывода сообщения ошибки в консоль. */
console.error("JavaScript говорит привет!");
/* Функция warn() нужна для вывода сообщения предупреждения в консоль. */
console.warn("JavaScript говорит привет!");
/* Чтобы создать переменную, нужно использовать ключевое слово var, а дальше писать уже название переменной. После, через "=" значение переменной. */
var str = 'Web-developer';
/* Функция alert() делает сайт недоступным для пользователя и текст ошибки будет тот, что передан в скобках. */
// alert("Ошибка");
/* Переменная с булевым значением. */
var bool = true;
/* Если переменной не будет задано значение, то она будет равна "undefined". */
var undef;
/* Переменная со значением null. */
var nul = null;
/* Чтобы задать в переменную объект, то нужно указать фигурные скобки. В них будут записаны различные функции и свойства.
Свойство - переменная внутри объекта, которая хранит строку, числа и тд. Метод - переменная внутри функции, которая хранит функцию.
Функции, регулярные выражения, массивы и тд - это всё объектные типы данных. */
var obj = {
  prop: 1,
  prop: function () {
  }
};

/* Лучше всего писать переменные так, экономя память: */
var str = "eewew",
  number = 1,
  bool = true,
  obj = {
    prop: 1,
    prop: function () {
    }
  };

/* VAR БОЛЬШЕ НЕ ИСПОЛЬЗОВАТЬ, А ИСПОЛЬЗОВАТЬ LET И CONST. */
const COLOR_RED = "#F00"; // Константы неизменяемы, и чаще всего пишутся в верхнем регисте.


/* ПРИМИТИВНЫЕ И ОБЪЕКТНЫЕ ДАННЫЕ. ОБЁРТКИ - https://www.youtube.com/watch?v=p-Ob8gEJBJs&list=PLY4rE9dstrJymG1GyPLgOKsJNq9r-p6pX&index=2 */


var obj = {
  prop: 1,
  prop: function () {
  }
},
  regexp = "/baba/g",
  func = function () { },
  arr = [1, 2, 3];

// Ключевое слово typeof выводит конкретный тип данных объектных данных.
console.log(typeof obj);
console.log(typeof regexp);
console.log(typeof func);
console.log(typeof arr);

// Мы обращаемся к переменной obj и её свойству prop, в котором меняем значение.
obj.prop = "Другое значение";
// У 3 элемента массива arr меняем значение.
arr[2] = 24;
// Функция toUpperCase() возводит строку в верхний регистр.
str.toUpperCase();
// Ключевое слово new создаёт из примитива объект. Из '2431' получиться {0: "2", 1: "4", 2: "3", 3: "1"}. 
new String('2431');
// Функция toString() переделывает переменную в строку. Если применить это к обёртке, то она приведёт переменную к виду, который был до обёртки.
number.toString();


/* STATEMENTS (ИНСТРУКЦИИ), EXPRESSIONS (ВЫРАЖЕНИЯ), OPERATORS (ОПЕРАТОРЫ) - https://www.youtube.com/watch?v=hqozKP8pol8&list=PLY4rE9dstrJymG1GyPLgOKsJNq9r-p6pX&index=3 */


var statement; // Инструкция
statement = 5 + 2; // Выражение
'Литерал'; // Литерал
// Арифметические операторы это +, -, *, = и тд.
var i = 2;
++i; // Увеличивает значение переменной i на 1.
--i; // Уменьшает значение переменной i на 1.
i++; /* Увеличивает значение переменной i на 1, но только после завершения работы выражения 
    (т.е если засунуть это в console.log(), то выведет старое значение, а если опять использовать console.log(), то выведет, как и должно с прибавкой на 1). */
i--; /* Уменьшает значение переменной i на 1, но только после завершения работы выражения 
    (т.е если засунуть это в console.log(), то выведет старое значение, а если опять использовать console.log(), то выведет, как и должно с убавкой на 1). */

console.log(i += 2) // Оператор += отвечает и за сложение, и за присваивание переменной значения.
// Операторы сравнения это >, <, == и тд. Также, есть операторы строгого равенства и неравенства - "===" и "!==", они сравнивают также и тип данных.


/* УСЛОВНЫЕ И ЛОГИЧЕСКИЕ ОПЕРАТОРЫ - https://www.youtube.com/watch?v=ogmqkRFNmcE&list=PLY4rE9dstrJymG1GyPLgOKsJNq9r-p6pX&index=4 */


/* ?? (оператор нулевого слияния) возвращает первое определённое значение. 
Например, результат выражения a ?? b будет следующим:
если a не равно null или undefined, то a,
если a равно null или undefined, то b.*/

var age = 18;
// Пример использования условных операторов if/else if/else.
if (age === 18) {
  console.log("Ты взрослый");
}
else if (age > 18) {
  console.log("Ты старше 18!")
}
else if (age < 18) {
  console.log("Ты младше 18!")
}
else {
  console.log("Ничего не подходит!")
};

// Пример конструкции switch().
let a = 2 + 2;
/* Переменная x проверяется на строгое равенство первому значению value1, затем второму value2 и так далее.
Если соответствие установлено – switch начинает выполняться от соответствующей директивы case и далее, до ближайшего break (или до конца switch).
Если ни один case не совпал – выполняется (если есть) вариант default. 
Проверка на равенство всегда строгая (===). Значения должны быть одного типа, чтобы выполнялось равенство. */
switch (a) {
  case 3:
    console.log('Маловато');
    break;

  // Оба варианта 4 и 5 выводят одно сообщение.
  case 4:
  case 5:
    console.log('Перебор');
    break;

  default:
    console.log("Нет таких значений");
}

/* Пример использования условного оператора "?". 
Сначала задаётся условие, после этого ставиться "?". 
Дальше пишется действие при случае, если условие равно true, ставиться ":" и действие при случае, если условие равно false. */
(age === 18) ? console.log("Ты взрослый") : console.log("Ты не взрослый!");

/* Ещё один пример использования условного оператора "?". 
Если age равен 18, то в консоль выводиться "Ты взрослый",
Если больше 18, то "Ты старше 18!",
Если меньше 18, то "Ты младше 18!",
Если же ничего из вышеперечисленного не подходит, то выводиться "Ничего не подходит!". */
(age === 18) ? console.log("Ты взрослый") :
  (age > 18) ? console.log("Ты старше 18!") :
    (age < 18) ? console.log("Ты младше 18!") :
      console.log("Ничего не подходит!");

// Логические операторы - это "||"(или), "&&"(и), "!"(нет).

// Пример использования "&&"(и): условие, если возраст больше или равен 18, но возраст должен быть меньше или равен 50.
(age >= 18 && age <= 50) ? console.log("Ты взрослый") : console.log("Ваш возраст не подходит!");
// Пример использования "||"(или): условие, если возраст больше или равен 18, или возраст меньше или равен 50.
(age >= 18 || age <= 50) ? console.log("Ты взрослый") : console.log("Ваш возраст не подходит!");
// Пример использования "!"(нет): условие, если возраст не равен 18, то "Ты не взрослый", а если равен, то "Ты взрослый!".
(age !== 18) ? console.log("Ты не взрослый") : console.log("Ты взрослый!");


/* ЧИСЛА - https://www.youtube.com/watch?v=IKddd9ZTwB4&list=PLY4rE9dstrJymG1GyPLgOKsJNq9r-p6pX&index=5 */


// символ "n" в конце означает, что это BigInt - тип данных для больших чисел.
const bigInt = 1234567890123456789012345678901234567890n;
var number = 234;
// Функция toFixed() приводит целое число к числу с плавающей точкой. В скобках пишется кол-во чисел после запятой.
number.toFixed(2);
// Функция toExponential() приводит число к экспонентциальному виду.
number.toExponential();
// Функция toPrecision() приводит число с плавающей точкой к целому числу. В скобках пишется, то сколько чисел нужно вывести.
number.toPrecision(4);
// Функция toString() приводит число к строке.
number.toString();
// Мы обращаемся к модулю Math и его функции sqrt(), которая выводит корень числа.
Math.sqrt(number);
// Мы обращаемся к модулю Math и его функции pow(), которая выводит число, которое дано первым в скобках, возведённое в число, данное вторым в скобках.
Math.pow(5, 2);
// Мы обращаемся к модулю Math и его функции floor(), которая всегда округляет число вниз.
Math.floor(number);
// Мы обращаемся к модулю Math и его функции ceil(), которая всегда округляет число вверх.
Math.ceil(number);
// Мы обращаемся к модулю Math и его функции round(), которая округляет число до ближайшего.
Math.round(number);
// Мы обращаемся к модулю Math и его константе PI, которая равно числу пи.
Math.PI;
// NaN(Not a Number) - это то, что нельзя получить. Например, NaN выведется, если поделить 0 на 0 или строку умножить на число.
0 / 0;
// NaN не равен ничему, даже самому себе.
NaN === NaN; // Выведет false.
// Функция isNaN() проверяет равно ли значение, переданное в скобках NaN.
var n = NaN;
isNaN(number); // Вернёт NaN.
1 / 0; // Будет равно infinity.
-1 / 0; // Будет равно -infinity.
Infinity + 31223; // Всё равно будет равно infinity.


/* СТРОКИ - https://www.youtube.com/watch?v=BTzuzSLsai8&list=PLY4rE9dstrJymG1GyPLgOKsJNq9r-p6pX&index=6 */


var str = "\"string\" is a type";// Таким способом, ставя "\" перед кавычками можно писать в одинаковых кавычках эти же кавычки.
var str = "string\nstring"; // "\n" делает перенос на новую строку.
var str = "string\tstring"; // "\t" делает таб перед словом.
console.log(str.length); // length выводит длину строки.
console.log(str.concat("Ещё строка")); // concat() соединяет данные строки.
console.log(str.charAt(0)); // chatAt() выводит символ данной строки, соотвествующий индексу, который дан в скобочках.
console.log(str.charCodeAt(0)); // chatCodeAt() выводит код символа данной строки, соотвествующий индексу, который дан в скобочках.
console.log(str.substring(5)); // substring() выводит символы данной строки, которые идут после индекса, который дан в скобочках.
console.log(str.substring(5, 7)); // Выведет все символы с 5 по 7 индексы.
console.log(str.slice(-5)); // slice() делает всё тоже самое, что и substring(), но может принимать отрицательные значения, чтобы обрезание шло в обратном порядке.
console.log(str.substr(5, 5)); // substr() выводит количество (второе число в скобках) символов данной строки, которые идут после индекса, который дан в скобочках.
console.log(str.split()); // split() разбивает строку на массив.
console.log(str.replace("string", "number")); // replace() заменяет в строке строку, которая дана первой в скобках, строкой, которая дана второй.
console.log(str.indexOf("s")); // indexOf() возвращает индекс данного символа.
console.log(str.toUpperCase()); // toUpperCase() возводит строку в верхний регистр.
console.log(str.toLowerCase()); // toLowerCase() возводит строку в нижний регистр.


/* BOOLEAN, NULL, UNDEFINED - https://www.youtube.com/watch?v=vyC1BTyh-E0&list=PLY4rE9dstrJymG1GyPLgOKsJNq9r-p6pX&index=7 */


// NaN, 0, "", null, undefined - равны false.
// undefined возвращает JavaScript, если элемент не найден, a null мы можем присвоить сами переменной.
// Также, undefined выводиться, если функции не переданы аргументы и ей нечего выводить.


/* ПРЕОБРАЗОВАНИЯ ТИПОВ ДАННЫХ - https://www.youtube.com/watch?v=OhldHbz93Kw&list=PLY4rE9dstrJymG1GyPLgOKsJNq9r-p6pX&index=8 */


String(1); // String() преобразовывает элемент в строку.
Number("2"); // Number() преобразовывает элемент в число.
Boolean(0); // Boolean() преобразовывает элемент в true или false.
5 + '1'; // Произойдёт автоматическая контакценация и на выходе будет строка '51'.
5 + ''; // Произойдёт автоматическая контакценация и на выходе будет строка '5'.
+'655434'; // Произойдёт автоматическая контакценация и на выходе будет число 655434.
+''; // Произойдёт автоматическая контакценация и на выходе будет число 0.
+true; // Произойдёт автоматическая контакценация и на выходе будет число 1.
!!'655434'; // Произойдёт автоматическая контакценация в bool и на выходе будет true.
number.toString(); // Преобразование числа в строку.
parseInt("100 px", 10); // parseInt() берёт из строки только числа и преобразовывает их в числа. Можно передать систему исчисления, как второй параметр.
parseFloat("100.32 px", 10); /* parseFloat() берёт из строки только числа и преобразовывает их в числа с плавающей точкой. 
                                Можно передать систему исчисления, как второй параметр. */


/* ОБЪЕКТЫ - https://www.youtube.com/watch?v=sfqsBd6Iwx0&list=PLY4rE9dstrJymG1GyPLgOKsJNq9r-p6pX&index=9 */


// Объект можно создать 2 способами:
var obj = Object();
var obj = {};
// Ключом объекта может быть любая строка, обычно без кавычек. Значением может быть всё что угодно, кроме undefined.
obj = {
  keey: 1,
  func: function () {
    console.log(this.keey); // С помощью ключевого слова this можно обратиться к корневому объекту. В нашем случае, это obj.
  }
};
// Чтобы обратиться к ключу объекта можно использовать точку или квадратные скобки.
obj.keey;
var prop = 'func';
obj[prop];
console.log(obj.fff || 'name'); // Если у obj нету ключа fff, то выводиться 'name'.
obj.new = "new"; // Добавляем новую пару ключ/значение.
obj.new = "neeeeew" // Изменяем пару ключ/значение.
delete obj.func; // Удаляем пару ключ/значение у obj.


/* МАССИВЫ - https://www.youtube.com/watch?v=5hjC9Y0WAig&list=PLY4rE9dstrJymG1GyPLgOKsJNq9r-p6pX&index=10 */


var arr = [1, null, '', {}]; // Создание массива.
arr[6] = 'six'; // Добавляем в 6 индекс значение, в массив где всего 4 элемента, то в 5 и 6 элемент будут равны undefined, а 7 нашему значению.
delete arr[2]; // Удаляем элемент под 2 индексом (''), но он не удалиться, а просто превратиться в undefined.
arr.splice(1, 1); /* splice() удаляет элементы, которые идут с индекса, который передан первым в скобках до индекса, переданного вторым. 
splice() именно удаляет элементы и сдвигает массив. */
arr.length = 100; // Нельзя увеличить длину массива таким способом.
arr.length = 2; // В массиве остануться только первые 2 элемента.
// Массив у которого объекты тоже массивы называется матрицей.
var matrix = [
  [
    [
      []
    ]
  ]
];
arr.concat([1, 2, 3]); // concat() может соединять массив с массивом.
arr.join(" "); // join() переделывает массив в строку. В аргументах принимать разделитель.
arr.push(23, 'wq'); // push() вставляет переданные элементы в конец массива.
arr.pop(); // pop() удаляет последний элемент массива.
arr.unshift(23, 42); // unshift() вставляет переданные элементы в начало массива.
arr.shift(); // shift() удаляет первый элемент массива.
arr.reverse(); // reverse() делает массив задом наперёд.
arr.slice(1, 5); // slice() вырезает кусок массива, по переданным индексам.
arr.sort(); // sort() сортирует массив. Сначала идут числа, потом строки. Но числа он сортирует странно. Может принимать функцию для пользовательской сортировки.


/* ЦИКЛЫ - https://www.youtube.com/watch?v=kFDhIxBV2cs&list=PLY4rE9dstrJymG1GyPLgOKsJNq9r-p6pX&index=11 */


var i;
/* Цикл for в Js состорит из 3 частей, которые разделяются ";" - 
инициализация (объявление начального значения переменной), тест (условие), 
инкремент/дискремент (прибавляем или убавляем у переменной 1, чтобы цикл был не бесконечен). */
/* Любую часть цикла for можно пропустить, и начало, и шаг, просто вместо них написать ";". */

for (i = 0; i < 10; i++) {
  console.log(i);
};


/* С помощью length можно пройтись по всему массиву. */
var arr = [1, 2, 3]
for (i = 0; i < arr.length; i++) {
  console.log(arr[i]);
};

/* Мы можем выйти из цикла в любой момент с помощью специальной директивы break. */

/* Директива continue – «облегчённая версия» break. При её выполнении цикл не прерывается, а переходит к следующей итерации (если условие все ещё равно true). */

var obj = {
  prop: 'one',
  proop: "two"
};

// Таким способом, можно ставить метку на цикл.
outer: for (let i = 0; i < 3; i++) {

  inner: for (let j = 0; j < 3; j++) {

    console.log(`Значение на координатах (${i},${j})`, '');

    // Выходит из верхнего цикла, а значит из всех циклов.
    if (j == 2) break outer;

    break inner; // Выходим только из нижнего цикла.
  }
}

/* Цикл for in. Объявляем сначала переменную, а потом в условии делаем так, 
чтобы цикл проходился по каждому свойству объекта. */
var prop;
for (prop in obj) {
  /* В JS часто объекты наследуется от своих предков и имеют теже свойства, что и они.
  И если нужно пройтись по свойствам именно этого объекта, а не ещё его предков, 
  то стоит всегда проверять есть ли свойство в объекте, с помощью hasOwnProperty(). */
  if (obj.hasOwnProperty(prop)) {
    console.log(prop, obj[prop]);
  }
};

// Пример работы цикла while.
var k = 0;
while (k < 10) {
  console.log(k++);
};

//Пример работы цикла do while. Его отличие лишь в том, что сначала выполняется тело цикла, а потом уже условие, т.е действие цикла выполниться хотя бы 1 раз.
var h = 0;
do {
  console.log(h++);
} while (h < 10);


/* ФУНКЦИИ - https://www.youtube.com/watch?v=FZkSwa_rm_E&list=PLY4rE9dstrJymG1GyPLgOKsJNq9r-p6pX&index=12 */


/* Функция состоит из 4 частей: ключевое слово "function", имя функции (необязательно), параметры функции, тело функции.
Также параметру можно задать параметр по умолчанию.
Это пример function declaration.  */
function func(a, b, с = 1) {
  text = text || 'пусто'; // Можно присвоить параметру значение по умолчанию таким образом.
  return a + b + c; // return преждевременно завершает функцию. Если функция ничего не будет возвращать, то выведется undefined.
};

console.log(func(3, 4)); // Запускаем функцию
console.log(func); //  Выведет код функции, т.к задавая имя функции мы как бы записываем её код в переменную.
var func = '123';
//console.log(func()); // Выведет ошибку, т.к мы создали переменную с таким же именем, как у функции и теперь её значение перезаписано.
// Можно присвоить переменной функцию, чаще всего она анонимна. Это пример function expression.
var funcExp = function (a, b) {
  return a + b;
};
console.log(funcExp(3, 4)); // Функция, записанная в переменную вызывается также, как и обычная.


/* Пример парсинга function declaration. Сначала он парсит объявления всех функций. 
И только потом парсит объявления переменных, return. Такая особенность называется hoisting. */
function func1() {

  // 1. Сначала парситься и объявляется эта функция.
  function funcExample() {
    return 'one';
  };

  // 3. Теперь парситься эта переменная и в ней находиться функция с выводом 'two', т.к она была объявлена последней.
  var variable = funcExample();

  // 2. Потом, парситься эта функция с тем же именем, что и первая, поэтому она перезаписывается.
  function funcExample() {
    return 'two';
  };
  // 4. Возвращается переменная с функцией.
  return variable;
};

console.log(func1()) // Выведет 'two'.

// Function Declaration может быть вызвана раньше, чем она объявлена в отличии от function expression.
sayHi("Вася"); // Привет, Вася
function sayHi(name) {
  console.log(`Привет, ${name}`);
}

/* Также объявление Function Declaration видимо только внутри блока кода, в котором располагается. 
С Function Expression таких проблем нет. */
let ages = 16;

if (ages < 18) {
  welcome();               // \   (выполнится)
  //  |
  function welcome() {     //  |
    console.log("Привет!");      //  |  Function Declaration доступно
  }                        //  |  во всём блоке кода, в котором объявлено
  //  |
  welcome();               // /   (выполнится)

} else {

  function welcome() {
    console.log("Здравствуйте!");
  }
}

// здесь фигурная скобка закрывается,
// поэтому Function Declaration, созданные внутри блока кода выше -- недоступны отсюда.

//welcome(); // Ошибка: welcome is not defined


/* Пример парсинга Function Expression. Он парсит всё сверху вниз, как и должно быть по логике.
Функции, объявленные при помощи Function Expression, создаются только когда поток выполнения достигает их. */
function func1() {

  // Сначала парситься и объявляется эта функция.
  var funcExample = function () {
    return 'one';
  };

  // Потом парситься переменная, в которой записана функция с выводом 'one'.
  var variable = funcExample();

  // Теперь парситься эта функция, но она нигде не запускается, поэтому бесполезна.
  var funcExample = function () {
    return 'two';
  };

  // Возвращается переменная с функцией.
  return variable;
};

console.log(func1()); // Выведет 'one'.


// Пример работы функции обратного вызова.
var func = function (callback) {
  var name = "Nick";
  return callback(name); // Возвращаем функцию, которую передадим ниже.
};
// Передаём в качестве параметра функции новую функцию.
console.log(func(function (n) {
  return 'Hello' + n;
}));


// Возвращение функции. Объявляем функцию и возвращаем новую функцию в её теле.
var func1 = function () {
  return function () {
    console.log("Привет");
  };
};
console.log(func1()); // Мы получим не "Привет", а код функции, которая была возвращена.
console.log(func1()()); // Запуская код возвращённой функции, мы получим как раз "Привет".


/* Анонимная самовызывающиеся функция. Она должна быть заключена в круглые скобки, чтобы быть вызванной. 
Она нужна для того, чтобы изолировать переменные и т.д, которые будут в этой функции от глобального кода.
Т.е переменные, функции, и т.д, объявленные в этой функции нельзя будет использовать за её пределами.
Перед объявлением такой функции принято ставить ";" для того, 
чтобы когда код будут минифицировать (делать весь код в одну строчку) 
и кто то забыл поставить ";" перед этой функцией, то она уже тут стояла. */
; (function () { // Объявляем функцию.
  console.log("Привет от анонимной самовызывающийся функции.")
})(); // Запускаем функцию.


// Аргументы функции.
var funcArgs = function () {
  console.log(arguments); // arguments - это специальный массив функции, содержащий все аргументы, переданные ей.
};

funcArgs() // Выведет [], т.к функция не принимает никаких аргументов.

var funcArgs2 = function (a, b) {
  console.log(arguments); // arguments - это специальный массив функции, содержащий все аргументы, переданные ей.
};

funcArgs2(1, 5) // Выведет [1, 5].

// Функция, которой можно передавать неограниченное кол-во параметров.
var funcArgs3 = function () {
  var i, sum = 0;
  for (i = 0; i < arguments.length; i++) { // Делаем цикл по кол-ву переданных аргументов.
    sum += arguments[i]; /* К сумме прибавляем каждый переданный параметр, 
    используя индекс (переменную i, которой каждую итерацию прибавляется 1) в массиве arguments. */
  };

  return sum; // Возвращаем сумму.
};

funcArgs3(1, 2, 3, 4, 5) // Можно передавать сколько угодно аргументов. Выведет 15.


// Пример работы стрелочной функции.
/* Эта стрелочная функция представляет собой более короткую форму:

let sum = function(a, b) {
  return a + b;
};
*/
let sum = (a, b) => a + b;

// Если аргументов нет, круглые скобки будут пустыми, но они должны присутствовать:
let sayHello = () => console.log("Hello!");

// Пример многострочной функции.
let suma = (a, b) => {  // фигурная скобка, открывающая тело многострочной функции
  let result = a + b;
  return result; // если мы используем фигурные скобки, то нам нужно явно указать "return"
};

/* ОБЛАСТЬ ВИДИМОСТИ ПЕРЕМЕННЫХ (SCOPE) - https://www.youtube.com/watch?v=RlTcSgNph68&list=PLY4rE9dstrJymG1GyPLgOKsJNq9r-p6pX&index=13 */


// Глобальные переменные - это все переменные, которые объявлены не в теле какой-либо функции и могут быть использованы везде.
var num = 1; // Глобальная переменная.
// Локальные переменные - это все переменные, которые объявлены в теле какой-либо функции и могут быть использованы только в её пределах. 
function func() {
  var num = 2; // Локальная переменная.
};
// Мы можем обращаться к глобальным переменным с помошью объекта window.
window.num;
// При кодинге, лучше использовать локальные переменные, а не глобальные.

// Переменная, объявленная без слова var автоматически становиться глобальной, даже если она объявлена в функции.
//variable = '';
var inner = function () {
  var arr = [1, 2, 3];
  for (i == 0; i < arr.length; i++) { // Мы объявили i без слова var, поэтому она стала глобальной.
    console.log(i);
    outer()
  };

};
var outer = function () {
  var arr = [1, 2, 3];
  for (i == 0; i < arr.length; i++) { /* Так как тут мы тоже не используем слово var, то используется глобальная переменная и она перезаписывает на 0. 
                                      И будет путаница в функциях просто из-за того, что мы не написали слово var и переменная i cтала глобальной. 
                                      Поэтому, чтобы путаниц не было, то ВСЕГДА нужно писать var перед объявлением переменной. */
    console.log(i);
  };
};

inner();


// Цепочка областей видимости.
var k = 4;

var outerScope = function () {
  console.log(k); /* Выведет undefined, т.к мы объявляем переменную с тем же именем дальше в коде этой функции. 
  Если бы не объявляли, то вывело бы 4. Т.к парсер JS сначала парсит объявления переменных, но без их значений. */
  var k = 8;
  console.log(k); // Выведет 8, т.к локальная переменная этой функции объявлена.

  var innerScope = function () {
    console.log(k); /* Выведет undefined, т.к мы объявляем переменную с тем же именем дальше в коде этой функции. 
    Если бы не объявляли, то вывело бы 8. Т.к парсер JS сначала парсит объявления переменных, но без их значений. */
    var k = 12;
  };
  innerScope(); // Запуская эту функцию, мы присваим переменной k значение 12 только в пределах функции innerScope().
  console.log(k); // Выведет 8, т.к значение локальной переменной этой функции равно 8.
};

outerScope();

/* Правило JS: всегда описывай все переменные в начале области видимости. 
Т.е когда начинается тело функции, то сразу объявлять все переменные, которые будут там использованы.
Необязательно записывать сразу всем переменным их значения, но нужно их объявлять (например: var i;), 
чтобы когда будете их использовать в функции, то использовались именно они, а не их клоны из глобальной области видимости. */


/* ЗАМЫКАНИЕ (CLOSURE) - https://www.youtube.com/watch?v=N09Ljaaexqk&list=PLY4rE9dstrJymG1GyPLgOKsJNq9r-p6pX&index=14 */


/* Все переменные внутри функции это свойства объекта Lexical Environment. 
При запуске, функция создаёт этот объект и записывает в него все переменные, аргументы, параметры и тд. 
У него есть скрытое свойство - scope (область видимости). Его никак нельзя изменить.
Оно ссылается на функцию, в которой было создано. И из-за scope функции доступны внешние переменные и тд. */
/* Замыкание - это функция и все внешние переменные, которые ей доступны. */

var FirstFunc = function () {
  var index = 5;
  return function () {
    return index;
  };
};

var SecondFunc = function () {
  var index = 15;
  console.log(FirstFunc()()); /* Функция запоминает только тот Lexical Environment, 
  в котором она была создана, но не в котором она была вызвана. Поэтому переменная index не перезапишетcя и останется равной 5. */
};

SecondFunc(); // Выведет 5.

// Замыкание даёт возможность брать переменные из прошлых функцией, и можно сравнивать их с переменными из новой функции.
var SecondFunc = function () {
  var index = 15;
  var oldIndex = FirstFunc()();
  console.log(index > oldIndex)
};


/* ОБЪЕКТ WINDOW и DOM (объективная модель браузера) - https://www.youtube.com/watch?v=mzoe-I7r5HE&list=PLY4rE9dstrJymG1GyPLgOKsJNq9r-p6pX&index=15 */


// C помощью объекта window можно обращаться к глобальным переменным.
var foo = '';
console.log(window.foo); // К глобальной переменной console тоже можно обратиться с помощью window.
console.log(navigator); // Объект navigator хранит данные о ОП пользователя, его браузере и тд.
console.log(navigator.userAgent); // navigator.userAgent выведет всю информацию о браузере пользователя.
console.log(screen); // Объект screen хранит данные о экране пользователя, разрешении тд.
console.log(screen.width + ' x ' + screen.height); // Выведет разрешение экрана пользователя.
console.log(location); // Объект location хранит данные о текущем url и странице.
//location.reload(); // location.reload() перезагрузит страницу.
console.log(location.toString()); // location.toString() выведет полную ссылку на текущую страницу.
//location.href = "http://..." // Перезаписав свойство href у объекта location можно переадресовать пользователя на другую страницу.
console.log(frames); // Объект frames возвращает массив, распечатывая все элементы текущего окна.
console.log(history); /* Объект history позволяет манипулировать историей браузера в пределах сессии, 
а именно историей о посещённых страницах в пределах вкладки или фрейма загруженного внутри страницы. */

//window.confirm("Примите."); // Метод confirm() выводит модальное окно подтверждения действия с переданным текстом.
/*var prompt = window.prompt(); Метод prompt() выводит модальное окно, где пользователь может написать и передать данные. 
Так как мы сохранили этот метод в переменную, то она будет хранить текст, который написал пользователь. */


/* DOM (ОБЪЕКТНАЯ МОДЕЛЬ ДОКУМЕНТА) - https://www.youtube.com/watch?v=1FpuKVmotNc&list=PLY4rE9dstrJymG1GyPLgOKsJNq9r-p6pX&index=16 */


/* Каждый HTML-тег создаёт узел дерева с типом элемента. 
Вложенные в него элементы являются дочерними узлами. А для текста создаются узлы с типом text. 
Пробелы также являются узлами дерева. 
Чтобы обратиться к DOM нужно использовать объект document. */

(function () {
  /* Метод getElementsByTagName() нужен для того, чтобы найти элементы по их тегу, который передан в скобках.
  Он выдаёт массив с этими тегами, где можно посмотреть все их свойства. 
  Он называется NodeList. С ним можно работать также, как и с обычным массивом. */
  var elems = document.getElementsByTagName("p");
  for (var i = 0; i < elems.length; i++) {
    console.log(elems[i]); // Выведет тег с его вложенниями. Например, <p>1</p>.
  };
  /* getElementsByClassName() находит элементы по имени переданнового класса.
  Выведет массив с элементами и их классами, по типу "p.paragraph". */
  var classElems = document.getElementsByClassName("paragraph");
  /* getElementById() находит элемент по имени идентификатора. 
  Так как id должен быть уникальным, то находит только 1 элемент.
  Выведет код с этим элементом, как "<p id="four">4</p>". */
  var idElem = document.getElementById("four");
  /* querySelector() находит первый элемент, соответствующий переданному селектору. 
  Выведет тег этого элемента, как "div". */
  var elemSelector = document.querySelector("div.user-panel.main input[name='login']");
  /* querySelectorAll() находит все элементы, соотвествующие переданному селектору. 
  Выведет массив с элементами, их классами, тегами и тд, как "[p, p.class. p#id]". */
  var elemSelector = document.querySelectorAll("div.user-panel.main input[name='login']");
  // Следующим способом можно найти все элементы p, вложенные в тег div.
  var elemsInDiv = document.querySelectorAll("div p");

  // Свойства и методы узлов.
  for (var i = 0; i < elems.length; i++) {
    console.log(elems[i].tagName); // tagName выведет имя тега.
    console.log(elems[i].parentNode); // parentNode выведет названия родительских тегов, как "<body></body> или <div></div>".
    /* previousSibling выводит элементы, которые идут перед тегом.
    Если это пробельный символ, то выведет просто "#text".
    Если же мы пишем HTML код без пробелов, то выведет тег, идущий перед нашим тегом, как "<p class="paragraph">2</p>". */
    console.log(elems[i].previousSibling);
    console.log(elems[i].previousSibling.previousSibling); // Вернёт позапрошлый элемент.
    /* nextSibling выводит элементы, которые идут после тега.
    Если это пробельный символ, то выведет просто "#text".
    Если же мы пишем HTML код без пробелов, то выведет тег, идущий после нашего тега, как "<p class="paragraph">2</p>". */
    console.log(elems[i].nextSibling);
    console.log(elems[i].nextSibling.nextSibling); // Вернёт элемент, идущий после после нашего тега.
    console.log(elems[i].nodeName); // nodeName выведет имя узла.
    /* nodeType выведет число, определяющий, что представляет собой узел. 
    Например, 1 - это узел элемента, 3 - это #text узел, 8 - это узел комментария и так далее.
    Все значения чисел можно узнать на сайте - https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType. */
    console.log(elems[i].nodeType);
  };


  /* childNodes выводит всех узлов-детей переданного тега.
  Например, "p#four, text, p" и тд. */
  var childNodesInDiv = document.querySelector("div").childNodes;
  /* children выводит всех узлов-элементов-детей переданного тега.
  Например, "p#four, p, a.example" и тд. */
  var childrenInDiv = document.querySelector("div").children;
  /* firstChild выводит первого узла-ребёнка переданного тега.
  Например, "p#four, #text, p" и тд. */
  var firstChildInDiv = document.querySelector("div").firstChild;
  /* lastChild выводит последнего узла-ребёнка переданного тега.
  Например, "p#four, #text, p" и тд. */
  var lastChildInDiv = document.querySelector("div").lastChild;
  /* innerHTML выводит код-разметку вложенных элементов переданного тега.
  Например, 
  "<p id="four">4</p>
  <p>5</p>". */
  var InnerInDiv = document.querySelector("div").innerHTML;
})();


/* СОЗДАНИЕ ЭЛЕМЕНТОВ ДИНАМИЧЕСКИ - https://www.youtube.com/watch?v=v2nLPYTmxBo&list=PLY4rE9dstrJymG1GyPLgOKsJNq9r-p6pX&index=17 */


(function () {

  /* Так как, обращение к DOM дереву крайне затратно для оптимизации, 
  то следует сохранить document в переменную и обращаться уже к ней. */
  var doc = document;

  // createElement() создаёт узел элемента, который передан в скобках.
  var elem = doc.createElement("p");
  // createTextNode() создаёт текстовый узел, текст, которого передан в скобках.
  var content = doc.createTextNode("Это динамично созданный элемент!");

  // Добавление созданного элемента в код.
  var idElem = doc.getElementById("four"); // Берём элемент по id.
  idElem.parentNode.appendChild(elem); // Берём родителя тега, которого нашли по id и добавляем наш элемент в него. Элемент добавиться в конец.
  /* Берём родителя тега, которого нашли по id и добавляем наш элемент перед элементом, который нашли по id.
  В параметрах передаём сам элемент, и элемент, перед которым его нужно вставить. */
  idElem.parentNode.insertBefore(elem, idElem);
  /* Берём родителя тега, которого нашли по id и заменяем элемент, который нашли по id нашим элементов.
  В параметрах передаём элемент, которым нужно заменить, и элемент, который нужно заменить. */
  //idElem.parentNode.replaceChild(elem, idElem);
  /* Берём родителя тега, которого нашли по id и удаляем этот самый элемент.
  В параметрах передаём элемент, которым нужно удалить. 
  Таким образом, можно удалить любой элемент-ребёнок. */
  idElem.parentNode.removeChild(idElem);

  // appendChild() добавляет узел, переданный в скобках, в качестве ребёнка тега.
  elem.appendChild(content);
  // setAttribute() добавляет атрибут в наш тег. В скобках передаётся название атрибута, и дальше, его значение.
  elem.setAttribute('id', 'ourID');
  // Таким способом, также можно добавить id нашему элементу.
  elem.id = "ourId";
  // Чтобы вставить в элемент HTML-код можно использовать свойство innerHTML.
  elem.innerHTML = "<strong>Это динамично созданный элемент!</strong>";
})();


/* ИЗМЕНЕНИЕ СТИЛЕЙ ЭЛЕМЕНТА - https://www.youtube.com/watch?v=NDe-anrOZ_s&list=PLY4rE9dstrJymG1GyPLgOKsJNq9r-p6pX&index=18 */


(function () {
  var div = document.getElementById("test");
  /* Записываем в переменную стили нашего элемента. */
  var style = div.style;
  /* Чтобы поменять свойство у элемента, 
  то обращаемся к его стилям и через точку к нужному нам свойству, и потом присваиваем нужное значение ввиде строки.
  НО ТАК ЛУЧШЕ НИКОГДА НЕ ДЕЛАТЬ, ТАК КАК ЭТО ОЧЕНЬ ЗАТРАТНО. */
  style.color = "red";
  style.backgroundColor = "black"; // Свойства из двух слов пишутся таким образом ("верблюдиком").
  style.border = "1px solid blue";
  style.padding = "3px";

  /* Чтобы добавлять стили элементу, лучше создать в CSS файле класс, 
  в котором уже будут все нужные свойства и уже его просто добавлять элементам. */
  div.className = "myClass"; // Добавление класса делается с помощью свойства className.
  div.className = "myClass secondClass thirdClass"; // Разделяя пробелом, можно добавить элементу сразу много классов.
  div.className = div.className.replace("myClass", "") // Чтобы убрать один конкретный класс можно использовать метод replace().
  div.className = ""; // Чтобы убрать все классы у пробела, нужно сделать так.

  // Также, классы можно добавлять с помощью свойства classList и его метода add().
  div.classList.add('myClass', "secondClass");
  // Также, классы можно удалять с помощью свойства classList и его метода remove().
  div.classList.remove('myClass', "secondClass");
  /* Метод toggle() работает таким образом, 
  что если данный класс отсутствует, то он его добавляет элементу,
  а если наоборот - такой класс есть, то он его удаляет у элемента. */
  div.classList.toggle('myClass');

  // Результат вызова getComputedStyle() – объект со стилями, похожий на elem.style, но с учётом всех CSS-классов (т.е и тех, что в браузере по умолчанию).
  getComputedStyle(div);
})();


/* АНИМАЦИЯ И ТАЙМЕРЫ - https://www.youtube.com/watch?v=-CGo9A7_oEg&list=PLY4rE9dstrJymG1GyPLgOKsJNq9r-p6pX&index=19 */


/* Стоит сразу сказать, что JavaScript-анимации не каждый день используются, 
а только когда хотят сделать что-то интересное и необычное. Не стоит усложнять функцию до тех пор пока это вам не понадобились. */
(function () {
  var startTimer = function () {
    console.log("Сработало!");
  };
  /* В метод setTimeout() передаётся функция ввиде объекта (т.е без скобок) 
  и кол-во милисекунд для задержки. 1000 милисекунд = 1 секунда.
  По истечению времени сработает переданная функция. */
  setTimeout(startTimer, 3000);
  console.log("Сработает сразу, а не через 3 секунды.") // Таймер применим только к переданной функции, а не ко всему следующему коду.

  /* Чтобы завершить функцию с таймером нужно записать её в переменную, а потом эту переменную вызвать в clearTimeout().
  Сама функция при таком исходе никогда не будет вызвана (только если дальше в коде). */
  var timer = setTimeout(startTimer, 3000);
  clearTimeout(timer);

  var delay = 100,
    i = 0,
    // Функция-цикл, вызывающяя сама себя.
    startTimer = function () {

      var elem = document.getElementById("circle"),
        bottom = elem.offsetTop; // Свойство offsetTop возвращает расстояние от вверха документа до позиции элемента.

      if (i < 10) {
        console.log('Сработало ' + (i + 1) + ' раз!'); // Таким способом можно вписать переменную в текст.
        setTimeout(startTimer, delay);
        elem.style.top = bottom + 20 + 'px'; // Увеличиваем у элемента отступ сверху.
      }

      i++;
    };

  startTimer();

  // Функция-цикл, вызывающяя сама себя.
  var startTimer = function (pixels) {

    var elem = document.getElementById("circle"),
      bottom = elem.offsetTop; // Свойство offsetTop возвращает расстояние от вверха документа до позиции элемента.

    if (i < 10) {
      elem.style.top = bottom + pixels + 'px'; // Увеличиваем у элемента отступ сверху.
    } else {
      clearInterval(timer); // clearInterval() завершает интервал.
    }

    i++;
  };
  // Метод setInterval() задаёт интервал, с которым функция будет работать.
  var timer = setInterval(function () { // Таким образом, можно передать параметры функции.
    startTimer(20);
  }, 3000);

  // Функции, чтобы не было ошибки.
  function animate1() {
    console.log()
  }

  function animate2() {
    console.log()
  }

  function animate3() {
    console.log()
  }

  // Такой подход занимает меньше нагружает систему, чем...
  setInterval(function () {
    animate1();
    animate2();
    animate3();
  }, 20)
  // ...такой.
  setInterval(animate1, 20); // независимые анимации
  setInterval(animate2, 20); // в разных местах кода
  setInterval(animate3, 20);

  /* Такой вызов планирует запуск функции callback на ближайшее время, когда браузер сочтёт возможным осуществить анимацию.
  Лучше использовать данный способ для анимаций. */
  function callback() {
    console.log()
  }
  let requestId = requestAnimationFrame(callback);
  // отмена запланированного запуска callback
  cancelAnimationFrame(requestId);

  /* Время прошедшее с момента начала загрузки страницы в миллисекундах может быть получено с помощью вызова performance.now(). */
  let prev = performance.now();


  /* Вспомогательная функция animate для создания анимации. 
  duration – общая продолжительность анимации в миллисекундах.
  timing – функция вычисления прогресса анимации. Получается момент времени от 0 до 1, возвращает прогресс анимации, обычно тоже от 0 до 1.
  draw – функция отрисовки анимации.
  */
  function animate({ timing, draw, duration }) {

    let start = performance.now();

    requestAnimationFrame(function animate(time) {
      // timeFraction изменяется от 0 до 1
      let timeFraction = (time - start) / duration;
      if (timeFraction > 1) timeFraction = 1;

      // вычисление текущего состояния анимации
      let progress = timing(timeFraction);

      draw(progress); // отрисовать её

      if (timeFraction < 1) {
        requestAnimationFrame(animate);
      }

    });
  }

  // Сама функция, которая на самом деле и рисует анимацию.
  function draw(progress) {
    train.style.left = progress + 'px';
  }

})();


/* ЗНАКОМСТВО С СОБЫТИЯМИ - https://www.youtube.com/watch?v=Ojcp828IAfw&list=PLY4rE9dstrJymG1GyPLgOKsJNq9r-p6pX&index=20 */


(function () {
  let box = document.getElementById("box");
  /* Обработчик событий - это встроенное свойство JS, которое позволяет вешать действия на наш элемент.
  Пишется он так, сначала on, а потом название события. 
  После того, как выбрал событие нужно написать ему значение ввиде функции. */
  box.onclick = function () {
    // Ключевое слово this указывает на элемент, на который повешен обработчик.
    this.style.backgroundColor = "red";
  }

  /* НО подобный вариант создания событий плох, т.к можно на одно событие задать только одну функцию. */
  box.onclick = function () { // Просто перезапишет событие.
    this.style.backgroundColor = "green";
  }

  /* Список самых популярных событий:
  События мыши:

  click – происходит, когда кликнули на элемент левой кнопкой мыши (на устройствах с сенсорными экранами оно происходит при касании).
  contextmenu – происходит, когда кликнули на элемент правой кнопкой мыши.
  mouseover / mouseout – когда мышь наводится на / покидает элемент.
  mousedown / mouseup – когда нажали / отжали кнопку мыши на элементе.
  mousemove – при движении мыши.
  События на элементах управления:

  submit – пользователь отправил форму <form>.
  focus – пользователь фокусируется на элементе, например нажимает на <input>.
  Клавиатурные события:

  keydown и keyup – когда пользователь нажимает / отпускает клавишу.
  События документа:

  DOMContentLoaded – когда HTML загружен и обработан, DOM документа полностью построен и доступен.
  CSS events:

  transitionend – когда CSS-анимация завершена. */
})();


/* СТАНДАРТНАЯ МОДЕЛЬ СОБЫТИЙ - https://www.youtube.com/watch?v=0udLlA5Y7yc&list=PLY4rE9dstrJymG1GyPLgOKsJNq9r-p6pX&index=21 */


/* Стандартная модель событий работает следующим образом:
1 этап - захват. По HTML разметке парсер идёт до нужного тега проходя по всем его родителям.
2 этап - захват целевого элемента. Парсер "захватывает" нужный элемент.
3 этап - всплытие. Парсер проходит обратно вверх по всем родительским элементам нашего тега.
Но у прошлых версий IE есть только стадия всплытия. */
(function () {
  let box = document.getElementById("box");
  let sayHi = function () {
    console.log("Hi!");
  }
  /* Бывают моменты когда нужно обработать само событие.
  И он автоматически передаётся, как параметр, функции, которая вызывается с помощью addEventListener().
  Имя ему можно задать любое, в моём случае "e". */
  let changeColor = function (e) {
    console.log(e.type); // Свойство type выдаёт название события, как "click".
    console.log(e.target); // Свойство target выдаёт код элемента, на который сработало событие.
    console.log(e.currentTarget); // Свойство currentTarget выдаёт код элемента, на котором висит обработчик.
    /* Различие target и currentTarget заключается в том, 
    что обработчик может быть повешен на тег html, и currentTarget выдаст его,
    а target выдаст именно тот элемент, на который сработало событие (кнопка и тд). */
    e.preventDefault(); // Метод preventDefault() отключает логику элемента, которая есть в браузере по умолчанию.
    console.log(e.clientX); // Свойство clientX координаты курсора по оси X в момент клика относительно окна, для событий мыши.
    console.log(e.clientY); // Свойство clientY координаты курсора по оси X в момент клика относительно окна, для событий мыши.
    this.style.backgroundColor = "green";
  }

  /* Есть более правильный способ добавлять события - это метод addEventListener().
  Первый параметр - это название события.
  Второй параметр - это функция, которая сработает при этом событии.
  Третий параметр - осуществлять ли событие на стадии захвата или на стадии всплытия:
  По умолчанию, true - на стадии захвата, как у всех современных браузеров.
  false - на стадии всплытия, для прошлых версий IE. */
  box.addEventListener("click", changeColor, false);
  box.addEventListener("click", sayHi, false);
  // Метод removeEventListener() отключает обработчик и принимает все те же параметры, что и addEventListener().
  box.removeEventListener("click", sayHi, false);
})();


/* МОДЕЛЬ СОБЫТИЙ INTERNET EXPLORER - https://www.youtube.com/watch?v=OGs4L59vVS4&list=PLY4rE9dstrJymG1GyPLgOKsJNq9r-p6pX&index=22 */


(function () {
  let box = document.getElementById("box");
  let changeColor = function (e) {
    // e.returnValue = false равносильно e.preventDefault(), но для старых версий IE.
    e.returnValue = false;
    // Ключевое слово this в IE не работает, поэтому, чтобы получить элемент, на который сработало событие, нужно использовать свойство srcElement.
    let elem = e.srcElement;
  }

  /* В старый версиях IE событие добавляется с помощью attachEvent(). 
  Первый параметр - это название события.
  Второй параметр - это функция, которая сработает при этом событии. */
  //box.attachEvent("onclick", changeColor);
  // В старый версиях IE событие удаляется с помощью detachEvent() и принимает все те же параметры, что и attachEvent().
  //box.detachEvent("onclick", changeColor);
})();


/* КРОСС-БРАУЗЕРНЫЕ СОБЫТИЯ - https://www.youtube.com/watch?v=FFlRoNYXEW0&list=PLY4rE9dstrJymG1GyPLgOKsJNq9r-p6pX&index=23 */


// Создадим объект и опишем в нём все методы для кросс-браузерных событий.
let eventsObj = {
  // Собственная кросс-браузерная функция для добавления события.
  addEvent: function (el, type, func) {
    // Проверяем на наличие метода addEventListener (для всех современных браузеров).
    if (typeof addEventListener !== "undefined") { // И если оно есть, то добавляем событие методом addEventListener().
      el.addEventListener(type, func, false);

      // Проверяем на наличие метода attachEvent (для старых версий IE).
    } else if (typeof attachEvent !== "undefined") { // И если оно есть, то добавляем событие методом attachEvent().
      el.attachEvent('on' + type, func); // Так как в IE события начинаются с 'on', то добавляем его в начале.

    } else { // Для исключительных браузеров.
      el['on' + type] = func; // Равносильно el.ontype = function () {}.
    }
  },

  // Собственная кросс-браузерная функция для удаления события.
  removeEvent: function (el, type, func) {
    // Проверяем на наличие метода removeEventListener (для всех современных браузеров).
    if (typeof removeEventListener !== "undefined") { // И если оно есть, то удаляем событие методом removeEventListener().
      el.removeEventListener(type, func, false);

      // Проверяем на наличие метода detachEvent (для старых версий IE).
    } else if (typeof detachEvent !== "undefined") { // И если оно есть, то удаляем событие методом detachEvent().
      el.detachEvent('on' + type, func); // Так как в IE события начинаются с 'on', то добавляем его в начале.

    } else { // Для исключительных браузеров.
      el['on' + type] = null; // Равносильно el.ontype = null.
    }
  },

  // Собственная кросс-браузерная функция для получения элемента, на который сработало событие.
  getTarget: function (event) {
    // Проверяем на наличие свойства target (для всех современных браузеров).
    if (typeof event.target !== "undefined") { // И если оно есть, то получаем элемент свойством target.
      return event.target;
    } else { // Для старых версий IE.
      return event.srcElement; // Получаем элемент свойством srcElement.
    }
  },

  // Собственная кросс-браузерная функция для отключения логики элемента, которая есть в браузере по умолчанию.
  preventDefault: function (event) {
    // Проверяем на наличие метода preventDefault (для всех современных браузеров).
    if (typeof event.preventDefault !== "undefined") { // И если оно есть, то отключаем логику методом preventDefault().
      event.preventDefault();
    } else { // Для старых версий IE.
      event.returnValue = false; // Отключаем логику с помощью свойства returnValue.
    }
  }
};

// Пример работы наших методов.
eventsObj.addEvent(box, "click", changeColor);
eventsObj.removeEvent(box, "click", changeColor);
// Методы getTarget() и preventDefault() созданы для вызова внутри функций.
var test = function (e) {
  var elem = eventsObj.getTarget(e);
  eventsObj.preventDefault(e);
};


/* ДЕЛЕГИРОВАНИЕ СОБЫТИЙ - https://www.youtube.com/watch?v=07pqPoYbY0k&list=PLY4rE9dstrJymG1GyPLgOKsJNq9r-p6pX&index=24 */


/* Делегирование событий - это когда события принимает весь родитель, а не один элемент. 
Идея в том, что если у нас есть много элементов, события на которых нужно обрабатывать похожим образом,
то вместо того, чтобы назначать обработчик каждому, мы ставим один обработчик на их общего предка. 
Больше примеров на https://learn.javascript.ru/event-delegation. */
(function () {
  let test = function (event) {
    let elem = eventsObj.getTarget(event), // Получаем элемент, на который кликнули.
      colorData = elem.getAttribute('data-color'); // Получаем значение атрибута 'data-color'.

    /* Обработчик у нас стоит на весь документ, 
    но с помощью if мы делаем действия только для тех элементов, которые нам нужны. */
    if (colorData) { // Если у элемента есть атрибут 'data-color'.
      document.body.className = colorData; // Задаём нужный класс.
    }
  }

  /* Всего один обработчик, но на весь документ. 
  Это намного лучше чем использовать цикл по всем элементам документа. 
  Все операции, связанные с DOM деревом затратные по памяти. */
  eventsObj.addEvent(document, 'click', test); // Передаём в функцию document, как главный родительский элемент.
})();



/* ДВИЖЕНИЕ МЫШИ - https://learn.javascript.ru/mousemove-mouseover-mouseout-mouseenter-mouseleave */


/* Событие mouseover происходит в момент, когда курсор оказывается над элементом, а событие mouseout – в момент, когда курсор уходит с элемента.
Эти события являются особенными, потому что у них имеется свойство relatedTarget. Оно «дополняет» target. 
Когда мышь переходит с одного элемента на другой, то один из них будет target, а другой relatedTarget.

Для события mouseover:
event.target – это элемент, на который курсор перешёл.
event.relatedTarget – это элемент, с которого курсор ушёл (relatedTarget → target).

Для события mouseout наоборот:
event.target – это элемент, с которого курсор ушёл.
event.relatedTarget – это элемент, на который курсор перешёл (target → relatedTarget). */

/* Свойство relatedTarget может быть null.
Это нормально и означает, что указатель мыши перешёл не с другого элемента, а из-за пределов окна браузера. Или же, наоборот, ушёл за пределы окна. */

/* Событие mousemove происходит при движении мыши. Однако, это не означает, что указанное событие генерируется при прохождении каждого пикселя.
Браузер периодически проверяет позицию курсора и, заметив изменения, генерирует события mousemove.
Это означает, что если пользователь двигает мышкой очень быстро, то некоторые DOM-элементы могут быть пропущены */

/* Важная особенность события mouseout – оно генерируется в том числе, когда указатель переходит с элемента на его потомка.
По логике браузера, курсор мыши может быть только над одним элементом в любой момент времени – над самым глубоко вложенным и верхним по z-index.
Событие mouseover, происходящее на потомке, всплывает. Поэтому если на родительском элементе есть такой обработчик, то оно его вызовет.
При переходе с родителя элемента на потомка – на родителе сработают два обработчика: и mouseout и mouseover. */

/* События mouseenter/mouseleave похожи на mouseover/mouseout. Они тоже генерируются, когда курсор мыши переходит на элемент или покидает его.
Но есть и пара важных отличий:
Переходы внутри элемента, на его потомки и с них, не считаются.
События mouseenter/mouseleave не всплывают.
Когда указатель появляется над элементом – генерируется mouseenter, причём не имеет значения, где именно указатель: на самом элементе или на его потомке.
Событие mouseleave происходит, когда курсор покидает элемент.  */


/* CSS HOUDINI */


// CSS Houdini - это набор API, которые предоставляют доступ к частям движка CSS. Это упрощает разработчикам создание расширений для CSS.


// API типизированной объектной модели (ТОМ)


// Раньше, чтобы получить например свойство CSS элемента нужно было сильно выкручиваться:
selectedElement.style.fontSize = newFontSize + 'px' // newFontSize = 20
console.log(selectedElement.style.fontSize) // 20px

/* Но с помощью CSS Houdini, мы можем сделать так.
computedStyleMap(): для парсинга вычисляемых (не встроенных) стилей. Этот метод вызывается перед парсингом или применением других методов.
attributeStyleMap: для парсинга и модификации встроенных стилей. Это свойство элемента. */
// получаем вычисляемые стили из таблицы стилей (начальное значение)
selectedElement.computedStyleMap().get('font-size') // { value: 20, unit: 'px' }
// устанавливаем встроенные стили
selectedElement.attributeStyleMap.set('font-size', CSS.em(2))
selectedElement.attributeStyleMap.set('color', 'blue')
// вычисляемые стили не изменились
selectedElement.computedStyleMap().get('font-size') // { value: 20, unit: 'px' }
// получаем новые встроенные стили
selectedElement.attributeStyleMap.get('font-size') // { value: 2, unit: 'em' }

/* Рассматриваемый API включает не только get и set, но и другие методы, например:
clear: удаляет все встроенные стили
delete: удаляет определенное свойство CSS и его значение
has: возвращает true/false в зависимости от наличия указанного свойства
append: добавляет дополнительное значение в свойство, поддерживающее несколько значений. */


// API пользовательских свойств и значений


/* Этот API позволяет разработчикам расширять переменные CSS, определяя тип, начальное значение и наследование.
Для того, чтобы определить пользовательское свойство необходимо его зарегистрировать с помощью метода «registerProperty». 
Этот метод определяет, как браузеры должны применять свойство и обрабатывать ошибки.
В качестве аргумента данному методу передается объект со следующими свойствами:
name: название пользовательского свойства.
syntax: инструкция для парсинга. Предустановленными значениями являются: <color>, <integer>, <number>, <length>, <percentage> и др.
inherits: будет наследоваться или нет.
initialValue: значение по умолчанию (до переопределения, а также при возникновении ошибок). */
CSS.registerProperty({
  name: '--colorPrimary',
  syntax: '<color>',
  inherits: false,
  initialValue: 'blue',
})


/* ВОРКЛЕТЫ */


/* Ворклеты — это скрипты, запускающиеся во время рендеринга и не зависящие от основного JS кода. 
Они расширяют возможности движка рендеринга, спроектированы для параллельного выполнения (2 или более экземпляра), 
не блокируют основной поток, имеют ограниченный доступ к глобальной области видимости и вызываются движком по необходимости. 
Ворклеты могут выполняться только через HTTPS (в продакшне) или через localhost (для целей разработки и тестирования).

Гудини включает следующие ворклеты, расширяющие движок рендеринга браузера:
Paint Worklet — Paint API
Animation Worklet — Animation API
Layout Worklet — Layout API */


/* PAINT API */


/* Paint API позволяет разработчикам использовать функции JS для рисования фона, границ или содержимого элемента, используя 2D Rendering Context, 
который является подмножеством HTML5 Canvas API. 
Paint API использует Paint Worklet для рисования изображения, которое зависит от изменений в CSS (например, изменений в переменных CSS). */

/* Создание Paint Worklet состоит из нескольких этапов:
1. Написать и зарегистрировать ворклет с помощью функции «registerPaint».
Функция «registerPaint» состоит из следующих частей:

inputProperties: массив пользовательских свойств CSS, за которыми наблюдает ворклет. Этот массив представляет собой зависимости ворклета
inputArguments: массив аргументов, которые могут быть переданы из функции во внешний CSS
contextOptions: прозрачность цветов. Если в значении стоит false, все цвета будут полностью непрозрачными
paint: главная функция, принимающая следующие аргументы:

ctx: контекст 2D-рисования, почти идентичный 2D контексту рисования Canvas API
size: объект со значениями ширины и высоты элемента. Значения зависят от процесса рендеринга макета. Размер холста такой же как действительный размер элемента
properties: переменные, содержащиеся в inputProperties
args: массив аргументов, передаваемых функции «paint». */
registerPaint('paintWorkletExample', class {
  static get inputProperties() { return ['--myVariable']; }
  static get inputArguments() { return ['<color>']; }
  static get contextOptions() { return { alpha: true } }

  paint(ctx, size, properties, args) {
    // ...
  }
})

/* 2. Вызвать ворклет в HTML или JS с помощью CSS.paintWorklet.addModule. */
CSS.paintWorklet.addModule('path/to/worklet/file.js');

/* 3. Использовать метод paint() в CSS вместе с названием ворклета и передаваемыми аргументами. 
После вызова ворклета он может быть использован в CSS с помощью функции «paint». 
Эта функция в качестве первого параметра принимает зарегистрированное имя ворклета и все аргументы, указанные в inputArguments.
С этого момента браузер знает, когда вызывать ворклет и какие действия пользователя приводят к изменению тех или иных значений пользовательских свойств CSS. 
Пример: 
.example-element {
  background: paint(paintWorkletExample, blue);
} */


/* ANIMATION API */


/* Этот API расширяет веб анимации через обработку различных событий (прокрутка, наведение, клик и т.д.) и улучшает производительность, 
запуская анимации в собственном потоке посредством ворклета анимации.
Этот класс включает две функции:
constructor: вызывается при создании нового экземпляра. Используется для общей настройки
animate: основная функция, содержащая логику анимации. Принимаются следующие параметры:
currentTime: значения (отметки) времени на определенной шкале времени
effect: массив эффектов, используемых в анимации. */
registerAnimation('animationWorkletExample', class {
  constructor(options) {
    // …
  }
  animate(currentTime, effect) {
    /* Веб анимация основана на отметках времени — контрольных точках для эффектов на шкале времени анимации.
    Например, разберем повторяющуюся линейную анимацию, которая состоит из трех кадров (начало, середина, конец), 
    запускается через 1 секунду после полной загрузки страницы (задержка) и длится 4 секунды. */
    effect.localTime = 3000 // 1000ms задержка + 2000ms средний кадр

    /* При постоянном значении effect.localTime анимация будет заблокирована на определенном кадре.
    Поэтому значение effect.localTime должно меняться. Таким значением должна быть функция, привязанная к currentTime или другой переменной. */
    effect.localTime = currentTime // y = x линейная функция
  }
})

// добавляем ворклет анимации
await CSS.animationWorklet.addModule('path/to/worklet/file.js')
// выбираем элемент для анимации
const elementExample = document.getElementById('element-example')
// определяем эффекты
const effectExample = new KeyframeEffect(
  elementExample, // анимируемый элемент
  // [ … ], // кадры анимации
  // { … } // настройки - продолжительность, задержка, количество повторов и т.д.
)
// создаем новый экземпляр ворклета анимации и запускаем его
new WorkletAnimation(
  'animationWorkletExample', // название ворклета
  effectExample, // график анимации
  document.timeline, // отметки времени
  {},  // настройки для конструктора
).play()

/* Анимация может быть привязана не только к загрузке документа, но также к действиям пользователя.
Такое действие пользователя как прокрутка страницы может использоваться в анимации через объект «ScrollTimeline».
Например, анимация может начинаться при прокрутке 200px и заканчиваться при прокрутке 800px. */
const scrollTimelineExample = new ScrollTimeline({
  scrollSource: scrollElement, // элемент, за прокруткой которого мы наблюдаем
  orientation: 'vertical', // направление прокрутки
  startScrollOffset: '200px', // начало отметки
  endScrollOffset: '800px', // конец отметки
  timeRange: 1200, // продолжительность эффекта
  fill: 'forwards' // направление анимации
})


/* LAYOUT API */


/* Layout API позволяет разработчикам расширять процесс рендеринга макета, определяя новые модули для использования в CSS свойстве “display”.
Этот API представляет новые концепции, 
является очень сложным и предлагает большое количество настроек для разработки пользовательских алгоритмов работы с макетом страницы. */

/* Регистрация ворклета включает следующие методы:

inputProperties: массив пользовательских свойств CSS, за которыми наблюдает ворклет и которые принадлежат родителю — элементу, вызвавшему рендеринг макета. 
Этот массив представляет собой зависимости ворклета макета
childrenInputProperties: массив пользовательских свойств CSS, за которыми наблюдает ворклет и которые принадлежат потомку
layoutOptions: определяет следующие свойства макета:

childDisplay: предустановленными значениями являются block и normal. Определяет способ отображения элемента (блочный или строчный)
sizing: предустановленными значениями являются block-like и manual. Определяет необходимость предварительного вычисления размеров элемента (если не указаны)
intrinsicSizes: определяет, как контейнер или его содержимое отображается в контексте макета:

children: потомок элемента, вызвавшего рендеринг макета страницы
edges: границы контейнера
styleMap: типизированная объектная модель стилей контейнера
layout: основная функция для работы с макетом:

children: дочерний элемент
edges: границы
constraints: ограничения, налагаемые родительским макетом
styleMap: типизированная объектная модель стилей контейнера
breakToken: контрольная точка для разделения макета при пагинации или печати.
Чтобы подключить этот layout в css, нужно сделать что то типа:
.example-element {
  display: layout(exampleLayout)
}

.example-element называется родительским макетом, включающим внутренние отступы, границы и ползунки прокрутки.
Родительский макет состоит из дочерних элементов, которые называются текущими макетами. 
Текущие макеты являются целевыми элементами, макеты которых «кастомизируются» с помощью Layout API.
Например, при использовании «display: flex» потомки элемента перестраиваются согласно гибкому макету. Это похоже на работу Layout API.
Каждый текущий макет состоит из дочерних макетов, содержащих алгоритмы рендеринга макета дочернего элемента — LayoutChild (включая псевдоклассы ::before и ::after).
LayoutChild — генерируемый средствами CSS контейнер, содержащий данные о стилях (без данных о макете). 
Элементы LayoutChild автоматически создаются браузером на стадии применения стилей. 
Дочерний макет может создавать Fragment, содержащий инструкции по рендерингу макета. */
registerLayout('exampleLayout', class {
  static get inputProperties() { return ['--example-variable'] }

  static get childrenInputProperties() { return ['--exampleChildVariable'] }

  static get layoutOptions() {
    return {
      childDisplay: 'normal',
      sizing: 'block-like'
    }
  }

  intrinsicSizes(children, edges, styleMap) {
    // …
  }

  layout(children, edges, constraints, styleMap, breakToken) {
    // …
  }
})

CSS.layoutWorklet.addModule('path/to/worklet/file.js');


/* VIEW TRANSITION API */


/* View Transitions API, что можно перевести как "интерфейс переходов отображения", 
предлагает легкий способ анимирования перехода между двумя состояниями DOM — даже между загрузками страниц. 
До недавнего времени у нас не было возможности простого обновления DOM. При использовании View Transitions API происходит следующее:
1. Делается снимок (snapshot) текущего состояния страницы.
2. Выполняется обновление DOM (добавляются/удаляются элементы).
3. Делается снимок нового состояния страницы.
4. Переход между этими состояниями анимируется с помощью дефолтного плавного затухания или с помощью кастомной анимации. */
// Получаем все статьи
const article = document.getElementsByTagName('article');

// Отображаем активную статью при загрузке страницы
switchArticle();

function switchArticle(e) {

  /* При загрузке страницы активная статья определяется по location.hash (хеш-части URL — все, что после символа #).
  При отсутствии хеша, активной становится первая статья. 
  При переходе на статью её id записывается в url после #, и так можно определить на какой сейчас статье пользователь. */
  const hash = e?.target?.hash?.slice(1) || location?.hash?.slice(1);

  Array.from(article).forEach((a, i) => {

    if (a.id === hash || (!hash && !i)) {
      a.removeAttribute('hidden');
    }
    else {
      a.setAttribute('hidden', '');
    }

  });

}

/* document.startViewTransition() делает снимок начального состояния, запускает switchArticle(), 
делает снимок нового состояния и создает дефолтный полусекундный переход между состояниями. */
document.body.addEventListener('click', e => {

  if (!e?.target?.hash) return;

  if (document.startViewTransition) {

    // Запускаем переход отображения
    document.startViewTransition(() => switchArticle(e));

  }
  else {

    // Переходы отображения недоступны
    switchArticle(e);
  }

});

/* Коллбэк, передаваемый document.startViewTransition(), может возвращать промис, что делает возможными асинхронные обновления DOM.
Но, это замораживает (freeze) страницу до разрешения промиса, что может негативно повлиять на пользовательский опыт. */
document.startViewTransition(async () => {
  const response = await fetch('/some-data');
  const json = await response.json();

  doDOMUpdates(json);
  await sendAnalyticsEvent();
});

/* Более эффективным подходом является вызов большей части кода за пределами метода startViewTransition: */
const response = await fetch('/some-data');
const json = await response.json();

document.startViewTransition(() => doDOMUpdates(json));

await sendAnalyticsEvent();

/* document.startViewTransition() возвращает объект, запускающий промис ready, который разрешается, 
когда становятся доступными псевдоэлементы перехода (обратите внимание на свойство pseudoElement второго параметра animate()). */
const transition = document.startViewTransition(doDOMupdate);
transition.ready.then(() => {

  document.documentElement.animate(
    [
      { rotate: '0deg' },
      { rotate: '360deg' },
    ],
    {
      duration: 1000,
      easing: 'ease',
      pseudoElement: '::view-transition-new(root)',
    }
  );
});


/* JAVASCRIPT ПАТТЕРНЫ */


/* ВВЕДЕНИЕ - https://www.youtube.com/watch?v=RyY6x_6ws4s&list=PLNkWIWHIRwMGzgvuPRFkDrpAygvdKJIE4&index=2 */


/* Паттерны разработки - это некие структурные единицы, которые предназначены для решения часто встречаемых задач. 
Паттерны деляться на 3 группы: структурные, порождающие и поведенческие. 
Паттерны можно произвести на любой язык программирования. 
Никогда не нужно подстраивать свой код под паттерн. */


/* SiNGLETON - https://www.youtube.com/watch?v=GrYs0qDQEp0&list=PLNkWIWHIRwMGzgvuPRFkDrpAygvdKJIE4&index=3 */


/* Этот паттерн нужен каждый раз, когда в системе есть объект в единственном экземпляре 
и к которому должен быть доступ из разных частей программы. */

// Объекты в JS никогда не будут равны друг другу, даже если они имеют одинаковое содержимое.

// Каждый раз, когда мы создаём объект с помощью литерала, он будет singleton, т.к он в одном экземпляре.
const singleton = 1;

// Создаём класс, который использует singleton
let instance; // Объявляем глобальную переменную
class Counter {

  constructor() {
    if (!instance) instance = this; // Если instance нет, то создаём его. 
    instance.count = 0;
    return instance; // Если он есть, то возвращаем его. Таким образом, он всегда будет у нас в одном экзепляре.
  }

  getCount() {
    return instance.count;
  }

  increaseCount() {
    return instance.count++;
  }
}

// В данном классе, мы используем не глобальную переменную, а статическое свойство класса.
class Counter2 {

  constructor() {
    if (typeof Counter2.instance === 'object') {
      return Counter2.instance;
    }
    this.count = 0;
    Counter2.instance = this;
    return this;
  }

  getCount() {
    return this.count;
  }

  increaseCount() {
    return this.count++;
  }
}

// Делаем 2 экзепляра класса (неважно, Counter или Counter2`)
const myCount1 = new Counter();
const myCount2 = new Counter();
// Увеличиваем число на 1
myCount1.increaseCount();
myCount2.increaseCount();
// В обоих выведеться 2, т.к хоть у нас и 2 разных объекта, но ссылаются они на один и тот же объект instance.
console.log(myCount1.getCount());
console.log(myCount2.getCount());

// Проще говоря, singleton гарантирует, что у класса есть только 1 экзепляр, как в примере выше.


/* FACTORY METHOD - https://www.youtube.com/watch?v=wmla1hxxvQI&list=PLNkWIWHIRwMGzgvuPRFkDrpAygvdKJIE4&index=3 */


