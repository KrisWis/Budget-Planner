/* REACT SNEAKERS - https://www.youtube.com/playlist?list=PL0FGkDGJQjJEos_0yVkbKjsQ9zGVy3dG7 */


/* 1 УРОК - https://www.youtube.com/watch?v=ptiom4YWqoE&list=PL0FGkDGJQjJEos_0yVkbKjsQ9zGVy3dG7&index=1 */


// nodeJS нужен для React, т.к это просто зависимость для реакта.
// npm устанавливает навсегда, а npx временно.

// package.json - это просто настройка проекта и его конфигурация.

// JSX это такой код разметки в React, когда ты можешь описывать js код ввиде html тегов.

// Если я хочу использовать что-либо из одного файла в других, то нужно использовать export dafault для этого чего-либо.
// export default позволяет всем дочерним файлам производить импорт этого чего-либо.

// Чтобы установить какой-либо препроцессор для css нужно использовать "npm install node-название", к примеру - "npm install node-sass".

// Для CSS класса пишут className, а не класс, т.к class - зарезервированное слово в js.
<div className="wrapper"></div>

// Если какой то файл находиться в папке public, то путь через public указывать не нужно, react и так это понимает. Нужно просто писать путь без public, например:
// <img width={40} height={40} src="/img/logo.png"></img> - а также, чтобы указывать любые значения в jsx разметке, нужно использовать фигурные скобки.

/* svg можно указывать двумя путями: добавить её в корень проекта и потом ввести путь к ней через src в теге <img>.
И второй способ, это добавить её с тегом svg и path. Но при первом случае её никак не получиться изменить цвет.
А при втором, можно спокойно обратиться к path и через свойство fill изменить цвет.
Но у первого случая есть и плюс - т.к это картинки, то браузер их может кешировать и потом сайт будет грузиться быстрее. */

// Мы будем использовать библиотеку 'macro-css', которая добавляет некоторые классы для шаблонных свойств.
// Чтобы её установить пишем npm install macro-css, а чтобы использовать - пишем в index.js - import 'macro-css'.

// Лучше использовать подключение шрифтов в html, чем в css.

// Если <img> не изменяется, то лучше использовать атрибуты width и height в HTML. Если же они будут влиять на адаптив и будут изменять свои размеры - то css стили.


/* 2 УРОК - https://www.youtube.com/watch?v=bfj4lEyc4w8&list=PL0FGkDGJQjJEos_0yVkbKjsQ9zGVy3dG7&index=2 */


// В React нужно при создании тега <img> указывать атрибут alt.
// В React в атрибуте style надо писать в фигурных скобках.
// В style, чтобы передать набор свойств, нужно передавать их как объект, т.е к примеру: "style={{ backgroundImage: 'url()' }}".
/* Также, свойства которые пишуться через дефис, в React пишуться с большой буквы. Например, background-image будет backgroundImage.
Это из-за того, что то, что мы пишем в фигурных скобках это по сути js код. */

// Да и впринципе, если ты хочешь написать js код в jsx разметке, нужно использовать фигурные скобки:
// <h2>{5 + 5}</h2>
// Это и есть различие JSX от HTML. В JSX можно выполнить JS код, а в HTML - нет.

// Компоненты нужны для повторно используемых кусков HTML кода. Если поменять что-либо в компоненте, то это поменяется во всех местах, где он используется.
// В правильной структуре, нужно хранить все компоненты в папке components.
// Названия файлов компонентов нужно писать с большой буквы.

// Сами функциональные компоненты должны называться также, как и их файлы, только без расширения.

// Компонентами могут быть различные повторяющиеся блоки коды, а также, просто некоторые масштабные блоки кода, типа header, main и тд. Но это уже для гибкости.

// При импорте компонента, его имя может быть любым - необязательно делать тоже самое имя, что и у самого функционального компонента, но обязательно с большой буквы.


// Чтобы создать компонент, нужно сделать для него отдельный файл, а дальше код должен иметь приблизительно такую структуру:
function Card() {
    return (
        <div className="card">
            <div className="favorite">
                <img src="/img/heart-unliked.svg" alt="Unliked" />
            </div>
            <img width={133} height={112} src="/img/sneakers/1.jpg" alt="Sneakers" />
            <h5>Мужские Кроссовки Nike Blazer Mid Suede</h5>
            <div className="d-flex justify-between align-center">
                <div className="d-flex flex-column">
                    <span>Цена:</span>
                    <b>12 999 руб.</b>
                </div>
                <button className="button">
                    <img width={11} height={11} src="/img/plus.svg" alt="Plus" />
                </button>
            </div>
        </div>
    );
}

// export default Card;


// Теперь, создав 3 компонента Card, Drawer, Header, наш главный компонент App.js выглядит так:
// Импортируем все компоненты
import Card from './components/Card';
import Header from './components/Header';
import Drawer from './components/Drawer';

function App() {
    return (
        <div className="wrapper clear">
            Для использования компонента в JSX разметке, его имя нужно использовать в ввиде закрывающего тега:
            <Drawer />
            <Header />
            <div className="content p-40">
                <div className="d-flex align-center justify-between mb-40">
                    <h1>Все кроссовки</h1>
                    <div className="search-block d-flex">
                        <img src="/img/search.svg" alt="Search" />
                        <input placeholder="Поиск..." />
                    </div>
                </div>

                <div className="d-flex">
                    <Card />
                    <Card />
                    <Card />
                    <Card />
                </div>
            </div>
        </div>
    );
}

// export default App; - и нужно экспортировать сам компонент


// В языке реакта функциональный компонент состоит из методов типа .createElement() и впринципе много мусора. Но у нас всё лаконично.

// Импорты компонентов стоит писать там, где эти компоненты и используется, т.е переносить все импорты в один корневой файл - зло и неоптимизированно.


/* 3 УРОК - https://www.youtube.com/watch?v=8W-M96dXA3Y&list=PL0FGkDGJQjJEos_0yVkbKjsQ9zGVy3dG7&index=3 */


// Представим, что у нас есть массив объектов со свойствами name.
// Мы можем создать в JSX разметке, JS код (с помощью фигурных скобок) и вызвать у нашего массива метод map(), а потом преобразовать каждый объект в HTML элемент:
<div>
    {arr.map((obj) => { // проходимся по всему массиву
        <p>{obj.name}</p> // Получаем свойство name и пусть оно будет выводиться в параграфе.
    })}

    {arr.map(() => { // проходимся по всему массиву 
        <Card /> // Сколько элементов массиве - столько раз и выведеться компонент Card.
    })}
</div>

// Также, есть такое понятие, как пропсы - это как бы параметры для компонента.
// Чтобы их передать, нужно просто в селектор компонента передать их как атрибуты:
// <Card title="тест" example={1}/> - пропсов может быть сколько угодно. Строки передаются в кавычках, все остальные типы данных - в фигурных скобках.

// А в файле компонента, нужно чтобы функция теперь принимала параметр props (общепринятое название) и этот объект будет хранить переданные пропсы:
function Card(props) {
    console.log(props) // {title: "тест", example: 1}
    // И теперь, из этих пропсов мы можем взять любое переданное свойство и использовать его в JSX:
    // <h3>{props.title}</h3>
}

// Теперь мы можем объединить перебор массива с помощью map и пропсы:
<div className="d-flex">
    {arr.map((obj) => (
        <Card
            title={obj.title}
            price={obj.price}
            imageUrl={obj.imageUrl}
        />
    ))}
</div>

// Мы используем именно map(), т.к он возвращает новый изменённый массив из компонентов, в отличии от, например, forEach(), который просто пройдётся циклом.

// Каждый элемент, который есть в JSX разметке, для реакта - это объект.

/* У нас есть наше DOM дерево, которое отображает саму страницу. 
А у реакта есть специальное Virtual DOM, которое выглядит также, как и DOM, только состоит из реакт объектов. 
И когда какая-то операция происходит в реакте, то он сравнивает соё виртуальное древо с DOM древом, которое отображает то, что есть сейчас.
Реакт проходиться по каждому элементу и если находит какие-либо изменения, то обновляет DOM дерево, изменяя то что нужно.
Виртуальное древо в первую очередь создано для оптимизации. Сами мы его изменять не можем, только React может с ним работать. */


// Пример того, как сделать событие клика при нажатии:
{/* <div className="d-flex">
    {arr.map((obj) => (
    <Card
        title={obj.title}
        price={obj.price}
        imageUrl={obj.imageUrl}
        onClick={() => console.log(obj)} - в React нужно навесить на элемент событие onClick, а дальше в фигурных скобках писать JS код.
    />
    ))}
</div> */}

// Стоит помнить, что функцией делают сам компонент, а функции внутри него создают с помощью переменных и стрелочных функций:
// Но стоит помнить, что как и в обычной JS - если просто передать функцию без стрелочной, то первым аргументом придёт параметр события.
const onClickFunc = (event) => { }
// ... onClick={onClickFunc} - и передаём просто название функции

// Если же наша функция принимает параметры, то нужно вызывать её в React с помощью стрелочной анонимной самовызывающейся функции:
const onClickFunc2 = (a, b) => { }
// чтобы передать параметры в функцию (и event передаваться первым не будет, т.к мы передаём не саму функцию) нужно использовать такой синтаксис.
// ... onClick={() => onClickFunc(1, 2)}

// Вообщем, если функция должна принимать параметры, то их нужно передавать с вызовом стрелочной анонимной самовызывающейся функции.

// Стоит помнить, что когда при создании компонента мы передали событие, то это просто тот же самый пропс и название у него может быть любым:
<Card
    title={obj.title}
    price={obj.price}
    imageUrl={obj.imageUrl}
    /* И это передасться в пропс функционального компонента, и потом эту функцию уже можно использовать при самих событиях (onClick и тд.).
    У пропсов передаваемых в компонент имя может быть любое. А вот у событий в реакте есть строгие наименования (onClick и тд.). */
    naKlicke={() => console.log(obj)}
/>

// Когда меняем структуру папок и тд, то нужно перезагружать проект.

/* По правильной архитектуре, в папке components нужно создавать папки с именами компонентов.
И в этих папках будут находиться файл стилей ОБЯЗАТЕЛЬНО с расширением .module, который будет содержать стили конкретно для этого компонента.
Стили нужно называть также, как и компонент.
А также, файл index.js, который и будет содержать код компонента. 
Но данная архитектура нужно только если компонент имеет свои собственные стили (а он почти всегда их имеет), но если их нет, то хватит просто Card.js без папки. */

// И т.к мы указали файл index.js, то в App.js мы можем не указывать прямой путь, а просто указать, какой компонент нам нужен и React сам всё поймёт:
import Card from './components/Card';

// В index.js нужно импортировать сами стили для их подключения:
import styles from './Card.module.scss';
console.log(styles); // Это объект, который хранит классы, описанные в файле.

// Теперь функция у нас должна выглядеть следующим образом:
function Card(props) {
    return ( // Если раньше у нас было className="card", то теперь обращаемся к свойству объекта стилей:
        <div className={styles.card}>
            <div className={styles.favorite}>
                <img src="/img/heart-unliked.svg" alt="Unliked" />
            </div>
            <img width={133} height={112} src={props.imageUrl} alt="Sneakers" />
            <h5>{props.title}</h5>
            <div className="d-flex justify-between align-center">
                <div className="d-flex flex-column">
                    <span>Цена:</span>
                    <b>{props.price} руб.</b>
                </div>
                <button className="button" onClick={props.onClick}>
                    <img width={11} height={11} src="/img/plus.svg" alt="Plus" />
                </button>
            </div>
        </div>
    );
}

/* Объект styles.card будет выглядеть, как "Card_card__kjhOw" -
т.е сначала указывается название компонента, потом название класса, а потом специальный уникальный идентификатор.
Это сделано для уникальности каждого класса. И теперь не нужно думать над названиями для классов. */

/* Стоит помнить, что если вылезает ошибка "Plugin "react" was conflicted between package.json » eslint-config-react-app",
то значит дело в пути, который я указал в консоли при "npm start".
Я часто ввожу его весь маленькими буквами, а он должен быть таким, как и называются папки (с большими буквами тоже, не игнорируя их). */

// Если файл содержит JSX разметку, то стоит использовать расширение .jsx, если же нет - то просто .js.


/* 4 УРОК - https://www.youtube.com/watch?v=gfx8IBUzZqw&list=PL0FGkDGJQjJEos_0yVkbKjsQ9zGVy3dG7&index=4 */


// При названии свойств надо называть грамотно, чтобы сразу было понятно за что это свойство отвечает.
/* Например, onClick - непонятно, при клике на что это будет происходить?
А onClickPlus - вполне понятно и грамотно. Понятно, что это будет происходить при клике на плюсе. Но главное не делать их слишком длинными и не зацикливаться на этом.
Например, onClickFavourite - очевидно, что при нажатии на избранное. */

// Стоит помнить, что даже когда в js меняется значение какой-либо переменной, то React об этом не знает и страницу не перерисовывает.
// useState() использует деструктуризацию и первая переменная это само значение, а вторая - функция, которая изменяет это значение.
// Сначала у нас значение false у константы isAdded, функция setIsAdded - для её изменения.
const [isAdded, setIsAdded] = React.useState(false);

const onClickPlus = () => { // Функция для события клика по кнопке
    setIsAdded(!isAdded); // Меняем значение isAdded на противоположное.
}

// Делаем условие в src, где в зависимости от значение isAdded выбирается svg`ашка.
<img src={isAdded ? "btn-checked.svg" : "btn-plus.svg"}></img>

// useEffect() выполняет код при изменение конкретного чего-либо.


// В React "условный рендеринг" обычно осуществляется с помощью тернарного оператора.
{ cartOpened ? <Drawer /> : null }

/* Также, это можно сделать таким способом:
Оператор && сначала проверяет левую часть и если она равна false, то на правую часть даже не смотрит (оптимизация).
Если же она равна true, то выполнение идёт дальше. */
{ cartOpened && <Drawer /> }

// Есть такой сервис, как mockAPi - это некий тестовый бекенд, на котором можно хранить свой JSON. Его мы и будем использовать (ссылку на бек с JSON данными).

// axios - это JS библиотека для обращения к бекенду/серверу и вытаскивания оттуда данных.

// Пример правильного использования fetch с помощью Промисов и .then():
fetch('https://60d381a361160900173c93d3.mockapi.io/items') // ссылка на json данные, хранящиеся на mockApi.
    .then((res) => {
        return res.json();
    })
    .then((json) => {
        setItems(json);
    });

/* Но стоит помнить, что при любом обновлении стейта/пропсов и тд - функция компонента перезапускается.
Поэтому, есть вероятность, что fetch будет отправлять запрос кучу раз, поэтому нам нужно использовать useEffect(), чтобы этого избежать. */
React.useEffect(() => {
    fetch('https://60d381a361160900173c93d3.mockapi.io/items')
        .then((res) => {
            return res.json();
        })
        .then((json) => {
            setItems(json);
        });
}, []); // Делаем это только при первом рендере


// Также, в функциях компонентов, которые получают пропсы, можно использовать деструктуризацию и тут мы используем свойства onClose и items.
function Drawer({ onClose, items = [] }) { } // Используем деструктуризацию, чтобы задать items дефолтное значение.
// Поэтому, можно теперь писать не props.onClose и props.items, а просто - onClose и items.


// Делаем функцию для добавления в корзину
const onAddToCart = (obj) => {
    // Также, более правильным считается такое добавление данных в стейт, а не братие переменной, в которой и храниться значение стейта.
    setCartItems((prev) => [...prev, obj]); // В функцию стейта всегда передаётся предыдущее значение.
};

<Card
    title={item.title}
    price={item.price}
    imageUrl={item.imageUrl}
    onFavorite={() => console.log('Добавили в закладки')}
    onPlus={(obj) => onAddToCart(obj)} // То, что в первых скобках - это то, что передали в само свойство onPlus() при вызове в другом компоненте.
/>


/* УРОК 5 - https://www.youtube.com/watch?v=J22CdUt5OOs&list=PL0FGkDGJQjJEos_0yVkbKjsQ9zGVy3dG7&index=5 */


/* Каждый HTML элемент, сгеенрированный с помощью map должен иметь уникальный идентификатор key.
Это возникает из-за того, что React не умеет различать элементы, которые были рендерены из массива.
Чтобы указать реакту, что элемент уникален, нужно в свойстве key указать уникальные данные,
например индекс элемента в массиве, но это не значит, что нужно делать рандом или типа того.
Это впринципе нужно для того, чтобы когда реакт сверял DOM древо и Virtual DOM, то видел разницу.
Но индекс делать не стоит, т.к реакту нужно более уникальное значение для key и это негативно скажется, если порядок элементов в списке измениться. */

// При изменении props компонент именно обновляется, а при изменение key он удаляется и добавляется на страницу снова (жизненный цикл перезапускается).
// Если до ререндера страницы конкретный key не существовал, то будет didMount.
// А до ререндера key существовал, а теперь его нет, то вызоветься willunmount.
/* Но key не должен соблюдать какое то рандомное значение - оно должно быть связано с элементом,
т.к это тогда никак не будет влиять на оптимизацию (а key и создан для оптимизации). */

/* Контролируемый инпут в реакт это когда ты берешь какие-то данные из инпута, то ты должен эти данные в этот инпут и сохранить.
Т.е сохранять значение инпута, например, в стейт. А потом этот стейт делать как value для инпута. */
const onChangeSearchInput = (event) => {
    setSearchValue(event.target.value);
};
<input value={searchValue}></input>
// И теперь у нас есть контролируемый инпут, т.к мы можем очистить в нём данные, просто очистив стейт.
// А неконтролируемый инпут это тот, чье value мы не можем контролировать с помощью кода.

// includes() ищёт точное совпадение, поэтому при фильтрации надо приводить к нижнему регистру.
{
    arr.filter((item) => item.title.toLowerCase().includes(searchValue)) // Пример обычной реализации поиска
        .map((obj) => (
            <Card
                title={obj.title}
                price={obj.price}
                imageUrl={obj.imageUrl}
            />
        ))
}

// Для установки axios надо прописать "npm install axios", а потом импортировать "import axios from 'axios'".
axios.get('/items').then((res) => { // С помощью axios можно сразу указывать запросы, которые тебе нужны.
    setItems(res.data); // А также тут не нужно переделывать его из json в объект, axios сам это делает и нужно проверять свойство data.
});
// Также, два axios запроса отправленные в одно время будут отправлять параллельно.
axios.get('/cart').then((res) => {
    setCartItems(res.data);
});

// Пример post запроса:
axios.post('/cart', obj);

// В React можно возвращать только один элемент. Т.е, к примеру, если у нас два дива, то они обязательно должны быть обёрнуты в родительский элемент.

// В package.json можно сделать свойство proxy и в него передать ссылку, на которую будут поступать запросы.
axios.get('/cart').then((res) => { // Поэтому, нам теперь не нужно писать всю ссылку - хватит только поддомена.
    setCartItems(res.data);
});

// React Router нужен для многостраничности и чтобы при переходе на другую страницу, был другой адрес в адресной строке, но это будет без перезагрузки страницы.
// Для установки - "npm install react-router-dom". Потом его нужно будет импортировать:
import { BrowserRouter as Router } from 'react-router-dom';

// И в Router надо будет обернуть всё наше приложение в index.js и с помощью этого мы и сможем делать роутинг - переход по страницам без перезагрузки.
ReactDOM.render(
    <React.StrictMode>
        <Router>
            <App />
        </Router>
    </React.StrictMode>,
    document.getElementById('root'),
);

// А в App.js надо будет импортировать Route:
import { Route } from 'react-router-dom';

// И теперь мы можем обернуть любой блок кода в Route и поставить свойство path - то, при каком адресе будет рендериться этот блок.
<div>
    <Route path="/" exact>
        <Home
            items={items}
            searchValue={searchValue}
            setSearchValue={setSearchValue}
            onChangeSearchInput={onChangeSearchInput}
            onAddToFavorite={onAddToFavorite}
            onAddToCart={onAddToCart}
        />
    </Route>

    <Route path="/favorites" exact> - Будет показываться только на странице фаворитов
        <Favorites items={favorites} onAddToFavorite={onAddToFavorite} />
    </Route>
</div>

// Теперь в файле, где юзер и должен попадать на страницу фаворитов, импортируем специальный объект Link:
import { Link } from 'react-router-dom';

// И теперь, нужно обёрнуть тот элемент, по нажатию на который юзер и будет попадать на нужную нам страницу.
// В свойстве to нужно указывать путь к странице, на которую будет ввести ссылка. В целом, Link - это тот же <a>, но с реактовским поведением.
// В HTML это будет как раз отображаться, как <a> с атрибутом href, но React будет это понимать по правильному и давать этой ссылке нужный функционал.
<Link to="/favorites">
    <img width={18} height={18} src="/img/heart.svg" alt="Закладки" />
</Link>

// Проще говоря, в Route надо оборачивать только тот контент, который должен рендериться только по конкретному адресу.

// React сравнивает так, что даже если что то будет идти после favorites, но перед этим будет "/", то тоже допустит. "/favorites/555" - допустимо, "favoriteswew" - нет.
// Но если добавить атрибут exact, то сравнение адреса будет строгое. "/favorites" - только оно допустимо, "/favorites/555" и тд - нет.
{/* <Link to="/favorites" exact>
    <img width={18} height={18} src="/img/heart.svg" alt="Закладки" />
</Link> */}

// Компоненты, которые отображаются только на определённых страницах, по логике, стоит хранить в папке pages.

// Чтобы передать какие либо данные из родительского компонента в дочерний можно просто использовать пропсы.
// Ещё, есть лайфхак - вместо того, чтобы передавать пропсы так:
<Card
    title={obj.title}
    price={obj.price}
    imageUrl={obj.imageUrl}
/>
// Можно так:
{/* <Card
    {...obj} - и все свойства, которые есть в этом объекте автоматически станут пропсами.
/> */}

/* Стоит помнить, что когда используешь async/await, то код стоит оборачивать в try/catch,
т.к без этого при использовании async/await js просто скажет, что произошла ошибка, но не скажет какая именно. */


/* УРОК 6 - https://www.youtube.com/watch?v=2jLFTiytfgg&list=PL0FGkDGJQjJEos_0yVkbKjsQ9zGVy3dG7&index=6 */


// Чтобы делать проверку на дубликат, надо сравнивать не сами элементы (т.к функция перезапускается и это уже фактически разные элементы), а их id.

// Если используешь булевое значение в пропсах, то не обязательно писать значение:
// props={true}
// Можно просто писать само свойство

/* Часто, когда с бека получаешь данные с нескольких запросов, то нужно дождаться пока обработаются все запросы,
поэтому стоит использовать асинхронность - у каждого запроса писать await  */
// в useEffect() нельзя передать асинхронную функцию, но внутри него можно создать асинхронные функции.

// Библиотека React Content Loader (React Skeleton) подходит, когда нужно сделать анимации загрузки.
// Для этого есть специальный сайт - https://skeletonreact.com/. Но top и left должны быть равны 0.

// В Реакте есть такая штука, что у элементов разделённых тернарным оператором и тд не должен быть один родитель.
// И вместо того, чтобы просто создавать див можно использовать Фрагмент - <> и </>.

// Хорошая реализация для создания загрузки это сделать стейт и когда всё будет загружено, то менять и в другой функции уже чекать это состояние.
const [isLoading, setIsLoading] = React.useState(true);

/* Контекст в React - это некое хранилище всех данных. 
Т.е вместо того, чтобы перекидывать пропсы из одного компонента в другой, у нас может быть одно общее хранилище, за которым будут следить конкретные компоненты.
И если они увидят в нём изменения, то сразу сделают ререндер. */

/* Лучше создавать контекст в отдельном файле (context.js) с помощью createContext() и передаванием туда объекта, и последующего экспорта.
Т.е по сути, контекст у нас будет обычным объектом, но т.к мы создаём его с помощью createContext(), то на него навешивается сложная логика реакта.
Логика - т.е реакт получает оповещение о том, какие компоненты надо перерисовать и тд. */
import React from 'react';
const AppContext = React.createContext({});
// export default AppContext; - можно его создать и в App.js и делать экспорт переменной, но это довольно странный метод.

// Чтобы указать какие компоненты должны следить за контекстом нужно обёрнуть нужные куски кода в провайдер:
<AppContext.Provider // Провайдер не добавляет данные в контекст, а заменяет объект контекста на переданный объект.
    value={{ // И теперь нужно сюда в свойство value передать те данные, которые и будут доступны всему этому куску кода. 
        items, // И теперь нам не нужно передавать пропсы компонентов, т.к всё храниться в контексте.
        cartItems,
        favorites,
        isItemAdded,
        onAddToFavorite,
        setCartOpened,
        setCartItems,
    }}>

    <div className="wrapper clear">
        {cartOpened && (
            <Drawer items={cartItems} onClose={() => setCartOpened(false)} onRemove={onRemoveItem} />
        )}

        <Header onClickCart={() => setCartOpened(true)} />

        <Route path="/" exact>
            <Home
                items={items}
                cartItems={cartItems}
                searchValue={searchValue}
                setSearchValue={setSearchValue}
                onChangeSearchInput={onChangeSearchInput}
                onAddToFavorite={onAddToFavorite}
                onAddToCart={onAddToCart}
                isLoading={isLoading}
            />
        </Route>

        <Route path="/favorites" exact>
            <Favorites />
        </Route>
    </div>
</AppContext.Provider>

// Чтобы взять в компонент нужные данные из контекста нужно использовать useContext():
const { favorites, onAddToFavorite } = React.useContext(AppContext);

// Если есть какие то повторяющиеся элементы на странице, то лучше сделать их с помощью компонента.

// HTTP-запрос PUT заменяет старые данные на новые.

// У mockApi нет функции очистки всех данных, только по отдельности.

// Также, насчёт контекста надо помнить - не нужно передавать в него всё подряд - нужно только то, что будет использоваться глобально во всех компонентов.

// Но в больших проектах лучше использовать Redux, нежели Context.


/* 7 УРОК - https://www.youtube.com/watch?v=C_3ZT7j1_jc&list=PL0FGkDGJQjJEos_0yVkbKjsQ9zGVy3dG7&index=7 */


// Кастомные хуки используются, когда нужно переиспользовать один и тот же код (проще говоря, в те же моменты, что и функции).
// Обычно кастомные хуки создаются в папке hooks в отдельных файлах.
// Пример кастомного хука useCart (хуки создаются обычно с префиксом use), созданного в отдельном файле:
// Это хук, который берём контекст, а затем высчитывает сумму и возвращаем нужные значения.
export const useCart = () => { // Вообще, лучше использовать такой обычный export, а не export default, т.к дефолт плохо оптимизированный.
    const { cartItems, setCartItems } = React.useContext(AppContext);
    const totalPrice = cartItems.reduce((sum, obj) => obj.price + sum, 0);

    return { cartItems, setCartItems, totalPrice };
};

// Пример экспорта с единичным export, а не export default:
import { useCart } from '../../hooks/useCart';

// Кастомный хук используется также, как и обычный:
const { cartItems, setCartItems, totalPrice } = useCart();

// Пример того, как из двух массивов получить один с объектами из обоих массивов:
data.reduce((prev, obj) => [...prev, ...obj.items], [])

// Иногда, асинхронные запросы, которые выполняются подряд лучше делать с помощью Promise.all() и деструктуризации.
// Но и стоит помнить, что он вёрнет ошибку, даже если только один запрос не выполниться, а это часто не то, что нужно.
const [cartResponse, favoritesResponse, itemsResponse] = await Promise.all([ // Возвратит массив со всеми полученными ответами.
    axios.get('https://60d62397943aa60017768e77.mockapi.io/cart'),
    axios.get('https://60d62397943aa60017768e77.mockapi.io/favorites'),
    axios.get('https://60d62397943aa60017768e77.mockapi.io/items'),
]);