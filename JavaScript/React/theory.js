

/* React JS c Нуля - Курс для начинающих БЕЗ ВОДЫ [2024] - https://www.youtube.com/watch?v=kz23xxukY5s */


/* Для того, чтобы работать с Vite+React нужно создать проект "npm create vite@latest". Выбрать React и далее TS или JS.
Далее в созданной папке надо установить зависимости с помощью "npm install".
А далее можно запустить проект с помощью npm run dev. */

// Можно сказать, что компоненты в React - это как врапперы в HTML, ставяться по примерно такой же логике, как кирпичики.
// Компоненты нужды для элементов на странице, которые имеют схожую структуру.
// Реактивность - это когда что то меняется в коде, и технология (в нашем случае React) это сразу перерендеривает на странице.
// Имена компонентов пишуться с большой буквы, чтобы реакт не путал их с обычными HTML тегами.

// В динамических данных, которые выводяться с помощью React можно передать только те данные, которые можно привести к строке.

// В JSX, в компонент мы можем передать какой-либо HTML код.
<Button>
    <span>33232</span>
    <h2>erwre</h2>
</Button>

// И функция компонента может принимать специальный параметр children, который и имеет в себе HTML разметку, написанную внутри тегов компонента.
export default function Button({ children }) {
    return <button>{children}</button> // И используем этот параметр
}

// События в React все те же самые, только с префиксом On. Функцию в событие надо передавать без скобок.

// Если элемент является стейтом, то реакт будет его перерисовывать, а если это статика, то нет.

// useState() можно использовать только внутри функции компонента на верхнем уровне.

// При изменении стейта с помощью функции, переменная стейта измениться только при следующем рендере.

// Любая функция, которая использует return может возвращать только что-то одно (либо кортеж/массив и тд с несколькими элементами и тд), так и в реакт.

// JSX разметка во внутренностях реакта создаётся с помощью множества React.createElement().

// Лучше, чтобы стейт был только в корневом компоненте.

// С объектом стилей можно работать только если файл стилей имеет расширение .module. Если нет, то классы используются, как обычно.
// Объект стилей принято называть classes. Принято использовать объект стилей при использовании классов в стилях. Это устраняет коллизию имён.

// Есть специальная библиотека styled-component, из неё надо импортировать объект styled:
import { styled } from 'styled-components';

// Мы можем сделать с помощью этой либы свой собственный компонент с уже встроенными стилями подобным способом:
const Header = styled.header`
    height: 50px;
    display: flex;
    padding: 0 2rem;
`
// А потом также вставить его в код:
// <Header />

// В React в <label> вместо атрибута for используется htmlFor для связи с инпутом.
/* Создаём стейт для последующей связи с инпутом. В инпут, в свойство value передаём его. 
Но если сделать только это, то в инпут не получиться ничего написать, т.к теперь его значение чётко привязано к стейту.
И если не меняется стейт, то и не меняется он. */
const [name, setName] = useState('');

/* Поэтому, мы создаём функцию, которая вызывается при событии писания в инпуте.
И теперь, то что пишеться в инпуте, храниться и в стейте, поэтому инпут работает корректно. */
function handleNameChange(event) {
    setName(event.target.value);
}

// Так и создаётся двухсторонняя привязка данных в React. Инпут зависим от стейта, а стейт зависим от инпута.
<form>
    <label htmlFor='name'>Ваше имя</label>
    <input type='text' id="name" className='control' value={name} onChange={handleNameChange}></input>
</form>

// Делаем стейт для ошибки
const [hasError, sethasError] = useState(false);

function handleNameChange(event) {
    setName(event.target.value);
    /* Стоит помнить, что стейт обновляется только после следующего ререндера функции. 
    Поэтому, тут в name будет храниться прошлое значение. */
    sethasError(name);

    // Поэтому надо следующий синтаксис для точной работы с прошлым значением.
    sethasError((prev) => { prev, name });
}

/* Часто, когда в компонент передаёшь пропсы, то можно передать их как ...props, и в сам компонент также передать их через rest оператор.
Это чтобы не писать много пропсов, а передать их сразу через props. */

// Для того, чтобы каждый раз не писать кучу useState можно написать один и передать в него объект.
const [form, setForm] = useState({
    name: '',
    hasError: true,
    reason: "help"
})

// И так, мы можем обновлять наш стейт. Но т.к стейт изменяет свой объект, а не обновляет. То надо писать каждый раз все свойства, которые прописы в оригинальном стейте.
setForm({
    name: "new",
    hasError: false
    // Тут нету поля reason, поэтому будет ошибка.
})

// Но поле reason нам не нужно менять, поэтому мы можем просто передать весь предыдущий стейт и изменить в нём нужные нам свойства.
setForm(prev => ({
    ...prev,
    name: "new",
    hasError: false
}))

// useRef() определяет значение только после того, как оно было присвоено. Если просмотреть объект до присвоения, то он будет пустым.
// В JS можно написать знак вопроса перед свойством, которое не факт, что есть в объекте и оно тогда не выдаст ошибки.
console.log(input.current?.value)

// Если useState() всегда при изменении вызывает ререндер, то useRef - нет.

// Импортируем специальный createPortal.
import { createPortal } from 'react-dom';

// Создаём реф для диалога, т.к этот элемент имеет специальные методы для отображения и потом присваиваем в jsx.
const dialog = useRef();

// Он нужен для "телепортации" html элементов, туда, куда нам надо.
createPortal(
    <dialog ref={dialog}></dialog>, // Первым аргументом, он принимает саму jsx разметку.
    document.getElementById("modal") // Вторым аргументом - элемент, в который и нужно поместить нашу разметку.
)

// useEffect с [] выполняется после полного рендера страницы.

// useCallback это перехват реакции, который позволяет вам кэшировать определение функции между повторными рендерингами.
/* useCallback принимает в качестве первого параметра функцию и возвращает ее сохраненную версию 
(с точки зрения ее местоположения в памяти, а не вычислений, выполняемых внутри).
Это означает, что возвращаемая функция не воссоздается в новой ссылке на память каждый раз при повторном рендеринге компонента, 
в то время как обычная функция внутри компонента это делает.
Возвращаемая функция воссоздается по новой ссылке на память, если изменяется одна из переменных внутри useCalback массива зависимостей (ее второй параметр). */

import { useCallback } from 'react';

export default function ProductPage({ productId, referrer }) {
    /* useCallback надо, думаю, использовать в связке с useEffect, т.к он кеширует функцию, если она имеет те же самые dependencies, что и в прошлый раз.
    Это список, который передаётся вторым параметром. Проще говоря, useCallback используется в первую очередь для оптимизации. */
    const handleSubmit = useCallback((orderDetails) => {
        post('/product/' + productId + '/buy', {
            referrer,
            orderDetails,
        });
    }, [productId, referrer]); // Реакт вызовет эту функцию при инициализации переданных зависимостей.
}


/* КУРС REACT С НУЛЯ! СОЗДАЙ СВОЁ ПРИЛОЖЕНИЕ КРИПТОВАЛЮТ! СТАНЬ REACT FRONTEND РАЗРАБОТЧИКОМ - https://www.youtube.com/watch?v=am_UiIvha5M */


// Все урлы к апи и прочию подобную данные лучше записывать в файле .env.
// Пример получения данных из .env:
import.meta.env.URL_API;

// Управляемый инпут создаётся с помощью useState, а не управляемый с помощью useRef.

// HOC (High Order Component) - это такой компонент, который оборачивает другой компонент, добавляя ему доп.функциональность.
// Пример создания HOC:
export const WithRuBalance = (Component) => { // Функция принимает компонент
    return (props) => { // Берём все пропсы компонента
        const { balance } = props; // Берём из пропсов баланс
        const ruBalance = balance * 90; // Создаём переменную на основе полученных данных
        return <Component {...props} ruBalance={ruBalance} />; // Возвращаем компонент со всеми прошлыми пропсами и с одним новым.
    };
};
// Пример использования данного HOC`а:
// export default WithRuBalance(Card); - Экспортируем уже не сам компонент, а с обёрткой.

// React.memo - это HOC для оптимизации, который предотвращает повторный рендеринг.
// Иногда, когда что то меняется в корневом компоненте, то он перерисовывается весь, даже когда некоторые компоненты перерисовывать не нужно.
// export default React.memo(FilterBlock); - компонент, который обёрнут в React.memo() будет перерендерен только в том случае, если его пропсы изменяться.

// Хук useMemo() позволяет минимизировать повторные вычисления, оптимизировать.
/* 1 параметром он принимает саму функцию, которую нужно закешировать, а вторым - зависимости, и только при измении их функция будет отрабатывать снова.
Без этого, она бы отрабатывала каждый раз при ререндере компонента. */
const expensiveCoins = useMemo(() => filterExpensiveCoins(), [filteredCoins])

// React.memo нужен для оптимизации рендера компонента, useMemo() для оптимизации сложных вычислений, а useCallback() для оптимизации создания функций.
// Когда компонент перерисовывается, то функция пересоздаётся.
/* Если функция объявлена просто как функция или выражение со стрелкой, оно будет создаваться заново при каждом рендеринге. 
Таким образом, оно будет отличаться по ссылкам. И вложенный дочерний элемент будут повторно отображаться каждый раз, хотя в этом нет необходимости. */
const addBalance = useCallback(() => { // Кешируем эту функцию
    setBalance(prev => prev + 1000)
})
/* Как и в случае с useMemo(), useCallback() мы должны использовать только тогда, когда это действительно нужно при ресурсозатратных функциях,
а в мелких функциях этого делает не стоит, т.к кеширование - это тоже трудозатратный процесс. */

// Деплой React приложения на Vercel в этом же видео с таймкода 1:31:14.

// Redux - это типа стейт менеджера. RTK Query и React Query - нужны для оптимизированных запросов на сервер.
// React Hook Form - для создания и работы над формами.