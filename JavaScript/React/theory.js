

/* REACT HOOKS - https://www.youtube.com/playlist?list=PL0FGkDGJQjJH4Uz-Vsk_91V65Wh88nlXC */


/* Для создания приложения в React, нужно написать в терминале "npx create-react-app my-app".
Для запуска приложения обязательно должны существовать index.html в папке public и index.js в папке src. Наличие остальных файлов необязательно.
Ну а потом уже переходит в папку приложения и пишем в терминале "npm start".
Всю архитектуру приложения можно посмотреть в файле "my-app". */

// Хуки позволяют расширить возможности функциональных компонентов без использования классов.


/* USE STATE - https://www.youtube.com/watch?v=NlrhyypLCm8&list=PL0FGkDGJQjJH4Uz-Vsk_91V65Wh88nlXC */


// Состояния - это данные, которые храняться только в одном компоненте.
// UseState() используется для создания состояний, чтобы конкретные данные были доступны только одному компоненту.

// Файл index.js (основной файл, где мы и подключаем все наши компоненты):
import React from 'react'; // Подключаем React
import ReactDOM from 'react-dom'; // Подключаем DOM дерево реакта
import App from './App'; // Импортируем наш компонент
import './index.css'; // Импортируем файл стилей

ReactDOM.render( // Используем метод render для отображения/рендеринга компонента в DOM дереве
    <React.StrictMode> - основной элемент нашего приложения
        <App /> - наш компонент
    </React.StrictMode>,
    document.getElementById("root"), // Вместо какого DOM элемента будет вся эта конструкция
)


// Файл App.js (файл компонента):
import React from 'react'; // Подключаем React

function App() { // Обозначаем функцию приложения

    // Раньше мы создавали массив чисел:
    // const numbers = [1, 2, 3];

    /* А теперь мы используем хук React.useState() и т.к он возвращает массив, состоящий из хранящихся данных и функции, 
    которая будет сообщать React об изменениях в этом состоянии для ререндеринга страницы. Т.е, в нашем случае, он возвращает [[1, 2, 3], f()].
    Поэтому, мы используем деструктуризацию и присваиваем numbers массив, а setNumbers функцию.
    И теперь, массив [1, 2, 3] храниться, как состояние. А также, мы можем использовать функцию setNumbers для ЗАМЕНЫ этого состояния на другое значение. */
    const [numbers, setNumbers] = React.useState([1, 2, 3]);

    // Создаём функцию, которая добавляет в массив цифру.
    const AddNumber = () => {
        // Просто создаём рандомное число
        const randNumber = Math.floor(Math.random() * 10);

        /* И это число добавиться в массив numbers, но в том то и дело, что мы оповещаем об этом только js, но не React.
        React не знает о том, что массив обновился, поэтому элементы не перерендеривает. */
        // numbers.push(randNumber);

        /* Поэтому, используем функцию setNumbers для замены значения в нашем состоянии, которое храниться в numbers. 
        Мы передаём туда массив, где с помощью spread оператора достаём все цифры из прошлого массива и добавляем новое число, только что созданное. */
        const newArr = [...numbers, randNumber];
        setNumbers(newArr);
    }

    return ( // Функция возвращает JSX разметку (типа HTML)
        <div className="App">
            <ul>
                {
                    /* Проходимся по массиву с помощью map() и генерируем на основе каждого элемента в массиве элемент li.
                    Но также, нужно помнить, что React имеет некое виртуальное дерево и он решает, нужно ли элемент рендерить или нет.
                    Поэтому, нам нужно добавить уникальный ключ для каждого элемента с помощью свойства key, куда мы передаём индекс элемента в массиве.
                    В нашем примере, ключ может быть неуникальным, но вообще, ему нужно быть полностью уникальным и неповторяющимся.
                    И также, этого свойства в DOM дереве мы увидеть не сможем, оно находиться именно в виртуальном дереве React. */
                    numbers.map((num, index) => (
                        <li key={index}>{num}</li>
                    ))}
                В React события нужно писать с большой буквы (т.е не onclick, а onClick) и уже потом в фигурных скобках передаём функцию.
                <button onClick={AddNumber}>Новое число</button>
            </ul>
        </div>
    )
}

export default App; // Экспортируем функцию



/* Таким образом, с помощью useState() мы даём понять JavaScript`у, что нужно производить замену значения в numbers,
а потом и React сказали, что произведено изменение переменной, чтобы он понял, нужно ему ререндерить страницу или нет (зависит от свойства key). */

/* useState() стоит использовать тогда, когда переменная используется в виртуальном дереве React и её значение может изменяться.
Ну а если она не изменяется, то и смысла от использования useState() нет. */


/* USE EFFECT - https://www.youtube.com/watch?v=slaaDOt0ZvM&list=PL0FGkDGJQjJH4Uz-Vsk_91V65Wh88nlXC&index=2 */


/* useEffect нужен для того, чтобы дать понять реакту, что компонент что то сделал.
Например, что кнопка внедрена в страницу или что компонент обновился или был удалён. */

/* В React есть 3 метода для управления жизненным циклом компонента:
componentDidMount - вызывается при отображении компонента на странице;
componentDidUpdate - вызывается, когда в компоненте произошли какие то изменения.
В этот метод передаются два параметра - старое состояние и старые пропсы. Поэтому, мы можем взять потом старые и новые данные и сравнить их;
componentWillUnmount - вызывается перед удалением компонента со страницы. */

// .jsx файлы стоит создавать, если в файле присутствует JSX разметка.
// Мы создали компонент List.jsx и перенесли весь функционал из App.js в него:
import React from "react";

const List = () => {

    const [numbers, setNumbers] = React.useState([1, 2, 3]);

    // Создаём функцию, которая добавляет в массив цифру.
    const AddNumber = () => {
        /* И это число добавиться в массив numbers, но в том то и дело, что мы оповещаем об этом только js, но не React.
        React не знает о том, что массив обновился, поэтому элементы не перерендеривает. */
        // numbers.push(4);

        // Просто создаём рандомное число
        const randNumber = Math.floor(Math.random() * 10);
        /* Используем функцию setNumbers для замены значения в нашем состоянии, которое храниться в numbers. 
        Мы передаём туда массив, где с помощью spread оператора достаём все цифры из прошлого массива и добавляем новое число, только что созданное. */
        const newArr = [...numbers, randNumber];
        setNumbers(newArr);
    }

    return (
        <div>
            <ul>
                {
                    /* Проходимся по массиву с помощью map() и генерируем на основе каждого элемента в массиве элемент li.
                    Но также, нужно помнить, что React имеет некое виртуальное дерево и он решает, нужно ли элемент рендерить или нет.
                    Поэтому, нам нужно добавить уникальный ключ для каждого элемента с помощью свойства key, куда мы передаём индекс элемента в массиве.
                    В нашем примере, ключ может быть неуникальным, но вообще, ему нужно быть полностью уникальным и неповторяющимся.
                    И также, этого свойства в DOM дереве мы увидеть не сможем, оно находиться именно в виртуальном дереве React. */
                    numbers.map((num, index) => (
                        <li key={index}>{num}</li>
                    ))}
                В React события нужно писать с большой буквы (т.е не onclick, а onClick) и уже потом в фигурных скобках передаём функцию.
                <button onClick={AddNumber}>Новое число</button>
            </ul>
        </div>
    )
}
/* export default List; - т.к в файле можно экспортировать дефолтно только один элемент, то дальше буду оборачивать эти конструкции комментариями, 
но на самом деле, это необходимая вещь. */

// А файл App.js теперь выглядит следующим образом:
import React from 'react'; // Подключаем React
import List from './List'; // Импортируем компонент List

function App() { // Обозначаем функцию приложения

    return ( // Она возвращает JSX разметку (типа HTML)
        <div className="App">
            <List /> - отображаем наш компонент в этом компоненте App.
        </div>
    )
}

// export default App; // Экспортируем функцию. Опять же, оборачиваю комментариям только в этом файле, в работе оборачивать не нужно.

/* Пропсы — это данные, доступные только для чтения, которые передаются от родительского компонента дочернему компоненту. 
Они используются для настройки поведения и внешнего вида компонента. */


// Теперь мы переписываем наш прошлый функциональный компонент с помоью класса в List.jsx:
/* Важно, что наш класс наследуется от React.Component, а это значит, что он теперь имеет все методы и функции React компонента.
Например, setState(), и вышеперечисленные методы жизненного цикла. */
class List2 extends React.Component {

    // Теперь, т.к наш класс наследуется от компонента, мы можем определить в нём специальное свойство state, в котором можем хранить данные.
    state = {
        numbers: [1, 2, 3]
    };

    // Создаём функцию для добавления числа в массив, находящийся в состоянии.
    addRandomNumber = () => {
        const randNumber = Math.floor(Math.random() * 10);
        // Т.к, наш класс наследуется от компонента, мы можем использовать метод setState() куда передать новый state с новыми свойствами.
        // Но стоит помнить, что мы лишь заменяем состояние на новое значение, а не обновляем его.
        this.setState({
            numbers: [...this.state.numbers, randNumber]
        })
    }

    // Данный метод будет вызываться при отображении компонента на странице.
    componentDidMount() {
        console.log("Компонент был отображен!")
    }

    /* Этот метод будет вызываться, когда в компоненте произойдёт какое то изменение, например, обновиться состояние.
    В качестве аргументов, в эту функцию передаются предыдущие пропсы и предыдущее состояние и мы можем задать им любое имя в объявлении функции.
    В нашем случае, это будет prevProps и prevState.
    Чтобы обратиться к текущем пропсам или состояниям нужно использовать this.state и this.props. */
    componentDidUpdate(prevProps, prevState) {
        console.log(prevProps, prevState, this.props, this.state)
    }

    // Данный метод будет вызываться перед удалением компонента на странице.
    componentWillUnmount() {
        console.log("Компонент будет удалён!")
    }


    // Для рендеринга компонента, т.к наш класс наследуется от него, то у нас есть свойство render() для этого.
    render() {
        return ( // Возвращаем jsx разметку.
            <div>
                <ul>
                    {
                        this.state.numbers.map((num, index) => (
                            <li key={index}>{num}</li>
                        ))}
                    <button onClick={this.addRandomNumber}>Новое число</button>
                </ul>
            </div>
        )
    }
}

// Изменяем класс в нашем App.js для функционала удаления и появления компонента со страницы:
// Создаём состояние
const [visibleList, setVisibleList] = React.useState(true);

// Создаём функцию, которая будет менять значение состояния.
const toggleVisibleList = () => {
    /* Есть такая особенность, что иногда при использовании функции состояния, она будет возвращать старое значение.
    Чтобы этого избежать, мы можем использовать вызов анонимной самовызывающейся функции внутри функции состояния.
    Мы вызываем её, в её параметры попадает наше состояние, мы присваиваем ей имя visible и потом меняем это значение на обратное. */
    setVisibleList((visible) => !visible);
}


return ( // Она возвращает JSX разметку (типа HTML)
    <div className="App">
        Делаем так, что если visibleList равен true, то компонент отображается, если же он равен false, то он не отображается.
        Если он не отображается, то его и в DOM нету.
        {visibleList && <List />} - отображаем наш компонент в этом компоненте App.
        <button onClick={toggleVisibleList}>Показать / скрыть список</button> - делаем сюда на событие клика функцию изменения видимости компонента.
    </div>
)


// Теперь в App.js, мы можем убрать наш классовый компонент и сделать всё тоже самое, но в старом, функциональном:
// Для этого мы будем юзать хук useEffect. Он первым аргументом принимает анонимную самовызывающуюся функцию, а вторым - зависимости.
// Если в качестве второго аргумента, мы передаём пустой массив, то React`у ни за чем следить не нужно и он вызывает функцию при componentDidMount.
React.useEffect(() => {
    console.log("Компонент был отображён!")
}, []); // [] - componentDidMount(), т.е чтобы он ни за чем не следил.

/* Если же ничего не передавать вторым аргументом, то функция будет вызываться при componentDidMount и componentDidUpdate.
Т.е React будет следить за изменением вообще всего. */
React.useEffect(() => {
    console.log("Компонент был отображён!")
});

// Чтобы useEffect() отлавливал изменение чего либо, нужно передать это в массив вторым аргументом.
// В примере, мы передаём туда numbers и поэтому, useEffect() будет вызываться каждый раз, когда numbers будет как либо изменён.
// Если нам нужно фиксировать чьё то ещё изменение, то просто тоже передаём это в массив.
React.useEffect(() => {
    console.log("Компонент был отображён!")
}, [numbers]);

/* Чтобы ловить событие, когда компонент будет удалён, нужно вторым аргументом передать пустой массив, как при componentDidMount(). 
А потом в return передавать анонимную самовызывающуюся функцию, в которой и будут происходить действия при удалении компонента. */
React.useEffect(() => {
    console.log("Компонент был отображён!");
    return () => {
        console.log("Компонент будет удалён!");
    }
}, []);

/* Также, стоит иметь ввиду, что useEffect(), в которых есть зависимости, в которых пустой массив или вообще нету второго аргумента - 
все они запустяться при отображении компонента. */

/* ComponentDidMount можно использовать, когда какой то компонент рендеришь, а в его разметке есть элемент, 
который ты хочешь достать по querySelector(), но он выдаст null, т.к компонент ещё не зарендерился, а ты уже хочешь получить элемент оттуда.
Тогда и поможет ComponentDidMount. */


/* USEREF - https://www.youtube.com/watch?v=8Yy6MDsF-Tg&list=PL0FGkDGJQjJH4Uz-Vsk_91V65Wh88nlXC&index=3 */


/* При любом обновлении компонента, функция его создания вызывается заново. Поэтому, все переменные и тд пересоздаются каждый раз и тд.
Поэтому, если мы в самом начале функции, объявляем переменную, но присваиваем ей значение только при создании компонента, 
то при любом обновлении компонента, функция будет перезапускаться и значение этой переменной будет undefined, т.к значение ей присваиваться не будет. */

// Хук useRef() создаёт объект со свойством current и значением этой переменной (т.е сначала будет {current: undefined}).
// Мы бы могли создавать этот объект и сами, но главное отличие в том, что useRef() не пересоздаёт объект при перезапуске функции.
// Т.е мы можем всегда хранить актуальные данные, независимо от того, обновится компонент или нет.
// useRef() является объектом, т.к в объекте, к значению по свойству можно обратиться в любой части кода.
const ulRef = React.useRef();

/* Нам не нужно писать querySelector() и тд, можно просто в jsx разметке, в элементе, 
на который хотим получить ссылку писать атрибут ref и в него передавать наше свойство, 
и в объекте useRef в свойстве current тоже будет это значение. */
<ul ref={ulRef}></ul>

// Теперь мы можем обращаться к этому элементу в любой части функции.
ulRef.current.addEventListener("click", function () { })

/* Также, стоит иметь ввиду, что если мы создали свойство, которое будет вызываться при каком то событии и хотим удалять eventListener по переменной этой функции,
то не выйдет, т.к когда компонент обновляется, то эта переменная обновляется тоже. И она ссылается уже на совершенно другой объект.
Поэтому мы не сможем использовать эту переменную во время removeEventListener(). Это можно исправить, используя хук useCallback(). */

// Можно сказать, useRef() нужен, чтобы хранить постоянную ссылку на DOM элемент.
// Но также, его можно использовать для постоянной ссылки на переменную, например, таймер:
const timerRef = React.useRef();
timerRef.current = setTimeout(() => { }, 200);

/* Напомню, что есть такая особенность, что иногда при использовании функции состояния, она будет возвращать старое значение.
Чтобы этого избежать, мы можем использовать вызов анонимной самовызывающейся функции внутри функции состояния.
Мы вызываем её, а в её параметры всегда попадает наше прошлое состояние, и мы присваиваем этому состоянию новое значение. */
setNumbers((prev) => [...prev, 1, 2, 3]);

// Проще говоря, useRef() не перезаписывает своё свойство при перезапуске функции/обновлении компонента.


/* REACT SNEAKERS - https://www.youtube.com/playlist?list=PL0FGkDGJQjJEos_0yVkbKjsQ9zGVy3dG7 */


/* 1 УРОК - https://www.youtube.com/watch?v=ptiom4YWqoE&list=PL0FGkDGJQjJEos_0yVkbKjsQ9zGVy3dG7&index=1 */


// nodeJS нужен для React, т.к это просто зависимость для реакта.
// npm устанавливает навсегда, а npx временно.

// package.json - это просто настройка проекта и его конфигурация.

// JSX это такой код разметки в React, когда ты можешь описывать js код ввиде html тегов.

// Если я хочу использовать что-либо из одного файла в других, то нужно использовать export dafault для этого чего-либо.
// export default позволяет всем дочерним файлам производить импорт этого чего-либо.

// Чтобы установить какой-либо препроцессор для css нужно использовать "npm install node-название", к примеру - "npm install node-sass".

// Для CSS класса пишут className, а не класс, т.к class - зарезервированное слово в js.
<div className="wrapper"></div>

// Если какой то файл находиться в папке public, то путь через public указывать не нужно, react и так это понимает. Нужно просто писать путь без public, например:
// <img width={40} height={40} src="/img/logo.png"></img> - а также, чтобы указывать любые значения в jsx разметке, нужно использовать фигурные скобки.

/* svg можно указывать двумя путями: добавить её в корень проекта и потом ввести путь к ней через src в теге <img>.
И второй способ, это добавить её с тегом svg и path. Но при первом случае её никак не получиться изменить цвет.
А при втором, можно спокойно обратиться к path и через свойство fill изменить цвет.
Но у первого случая есть и плюс - т.к это картинки, то браузер их может кешировать и потом сайт будет грузиться быстрее. */

// Мы будем использовать библиотеку 'macro-css', которая добавляет некоторые классы для шаблонных свойств.
// Чтобы её установить пишем npm install macro-css, а чтобы использовать - пишем в index.js - import 'macro-css'.

// Лучше использовать подключение шрифтов в html, чем в css.

// Если <img> не изменяется, то лучше использовать атрибуты width и height в HTML. Если же они будут влиять на адаптив и будут изменять свои размеры - то css стили.


/* 2 УРОК - https://www.youtube.com/watch?v=bfj4lEyc4w8&list=PL0FGkDGJQjJEos_0yVkbKjsQ9zGVy3dG7&index=2 */


// В React нужно при создании тега <img> указывать атрибут alt.
// В React в атрибуте style надо писать в фигурных скобках.
// В style, чтобы передать набор свойств, нужно передавать их как объект, т.е к примеру: "style={{ backgroundImage: 'url()' }}".
/* Также, свойства которые пишуться через дефис, в React пишуться с большой буквы. Например, background-image будет backgroundImage.
Это из-за того, что то, что мы пишем в фигурных скобках это по сути js код. */

// Да и впринципе, если ты хочешь написать js код в jsx разметке, нужно использовать фигурные скобки:
// <h2>{5 + 5}</h2>
// Это и есть различие JSX от HTML. В JSX можно выполнить JS код, а в HTML - нет.

// Компоненты нужны для повторно используемых кусков HTML кода. Если поменять что-либо в компоненте, то это поменяется во всех местах, где он используется.
// В правильной структуре, нужно хранить все компоненты в папке components.
// Названия файлов компонентов нужно писать с большой буквы.

// Сами функциональные компоненты должны называться также, как и их файлы, только без расширения.

// Компонентами могут быть различные повторяющиеся блоки коды, а также, просто некоторые масштабные блоки кода, типа header, main и тд. Но это уже для гибкости.

// При импорте компонента, его имя может быть любым - необязательно делать тоже самое имя, что и у самого функционального компонента, но обязательно с большой буквы.


// Чтобы создать компонент, нужно сделать для него отдельный файл, а дальше код должен иметь приблизительно такую структуру:
function Card() {
    return (
        <div className="card">
            <div className="favorite">
                <img src="/img/heart-unliked.svg" alt="Unliked" />
            </div>
            <img width={133} height={112} src="/img/sneakers/1.jpg" alt="Sneakers" />
            <h5>Мужские Кроссовки Nike Blazer Mid Suede</h5>
            <div className="d-flex justify-between align-center">
                <div className="d-flex flex-column">
                    <span>Цена:</span>
                    <b>12 999 руб.</b>
                </div>
                <button className="button">
                    <img width={11} height={11} src="/img/plus.svg" alt="Plus" />
                </button>
            </div>
        </div>
    );
}

// export default Card;


// Теперь, создав 3 компонента Card, Drawer, Header, наш главный компонент App.js выглядит так:
// Импортируем все компоненты
import Card from './components/Card';
import Header from './components/Header';
import Drawer from './components/Drawer';

function App() {
    return (
        <div className="wrapper clear">
            Для использования компонента в JSX разметке, его имя нужно использовать в ввиде закрывающего тега:
            <Drawer />
            <Header />
            <div className="content p-40">
                <div className="d-flex align-center justify-between mb-40">
                    <h1>Все кроссовки</h1>
                    <div className="search-block d-flex">
                        <img src="/img/search.svg" alt="Search" />
                        <input placeholder="Поиск..." />
                    </div>
                </div>

                <div className="d-flex">
                    <Card />
                    <Card />
                    <Card />
                    <Card />
                </div>
            </div>
        </div>
    );
}

// export default App; - и нужно экспортировать сам компонент


// В языке реакта функциональный компонент состоит из методов типа .createElement() и впринципе много мусора. Но у нас всё лаконично.

// Импорты компонентов стоит писать там, где эти компоненты и используется, т.е переносить все импорты в один корневой файл - зло и неоптимизированно.


/* 3 УРОК - https://www.youtube.com/watch?v=8W-M96dXA3Y&list=PL0FGkDGJQjJEos_0yVkbKjsQ9zGVy3dG7&index=3 */


// Представим, что у нас есть массив объектов со свойствами name.
// Мы можем создать в JSX разметке, JS код (с помощью фигурных скобок) и вызвать у нашего массива метод map(), а потом преобразовать каждый объект в HTML элемент:
<div>
    {arr.map((obj) => { // проходимся по всему массиву
        <p>{obj.name}</p> // Получаем свойство name и пусть оно будет выводиться в параграфе.
    })}

    {arr.map(() => { // проходимся по всему массиву 
        <Card /> // Сколько элементов массиве - столько раз и выведеться компонент Card.
    })}
</div>

// Также, есть такое понятие, как пропсы - это как бы параметры для компонента.
// Чтобы их передать, нужно просто в селектор компонента передать их как атрибуты:
// <Card title="тест" example={1}/> - пропсов может быть сколько угодно. Строки передаются в кавычках, все остальные типы данных - в фигурных скобках.

// А в файле компонента, нужно чтобы функция теперь принимала параметр props (общепринятое название) и этот объект будет хранить переданные пропсы:
function Card(props) {
    console.log(props) // {title: "тест", example: 1}
    // И теперь, из этих пропсов мы можем взять любое переданное свойство и использовать его в JSX:
    // <h3>{props.title}</h3>
}

// Теперь мы можем объединить перебор массива с помощью map и пропсы:
<div className="d-flex">
    {arr.map((obj) => (
        <Card
            title={obj.title}
            price={obj.price}
            imageUrl={obj.imageUrl}
        />
    ))}
</div>

// Мы используем именно map(), т.к он возвращает новый изменённый массив из компонентов, в отличии от, например, forEach(), который просто пройдётся циклом.

// Каждый элемент, который есть в JSX разметке, для реакта - это объект.

/* У нас есть наше DOM дерево, которое отображает саму страницу. 
А у реакта есть специальное Virtual DOM, которое выглядит также, как и DOM, только состоит из реакт объектов. 
И когда какая-то операция происходит в реакте, то он сравнивает соё виртуальное древо с DOM древом, которое отображает то, что есть сейчас.
Реакт проходиться по каждому элементу и если находит какие-либо изменения, то обновляет DOM дерево, изменяя то что нужно.
Виртуальное древо в первую очередь создано для оптимизации. Сами мы его изменять не можем, только React может с ним работать. */


// Пример того, как сделать событие клика при нажатии:
{/* <div className="d-flex">
    {arr.map((obj) => (
    <Card
        title={obj.title}
        price={obj.price}
        imageUrl={obj.imageUrl}
        onClick={() => console.log(obj)} - в React нужно навесить на элемент событие onClick, а дальше в фигурных скобках писать JS код.
    />
    ))}
</div> */}

// Стоит помнить, что функцией делают сам компонент, а функции внутри него создают с помощью переменных и стрелочных функций:
// Но стоит помнить, что как и в обычной JS - если просто передать функцию без стрелочной, то первым аргументом придёт параметр события.
const onClickFunc = (event) => { }
// ... onClick={onClickFunc} - и передаём просто название функции

// Если же наша функция принимает параметры, то нужно вызывать её в React с помощью стрелочной анонимной самовызывающейся функции:
const onClickFunc2 = (a, b) => { }
// чтобы передать параметры в функцию (и event передаваться первым не будет, т.к мы передаём не саму функцию) нужно использовать такой синтаксис.
// ... onClick={() => onClickFunc(1, 2)}

// Вообщем, если функция должна принимать параметры, то их нужно передавать с вызовом стрелочной анонимной самовызывающейся функции.

// Стоит помнить, что когда при создании компонента мы передали событие, то это просто тот же самый пропс и название у него может быть любым:
<Card
    title={obj.title}
    price={obj.price}
    imageUrl={obj.imageUrl}
    /* И это передасться в пропс функционального компонента, и потом эту функцию уже можно использовать при самих событиях (onClick и тд.).
    У пропсов передаваемых в компонент имя может быть любое. А вот у событий в реакте есть строгие наименования (onClick и тд.). */
    naKlicke={() => console.log(obj)}
/>

// Когда меняем структуру папок и тд, то нужно перезагружать проект.

/* По правильной архитектуре, в папке components нужно создавать папки с именами компонентов.
И в этих папках будут находиться файл стилей ОБЯЗАТЕЛЬНО с расширением .module, который будет содержать стили конкретно для этого компонента.
Стили нужно называть также, как и компонент.
А также, файл index.js, который и будет содержать код компонента. 
Но данная архитектура нужно только если компонент имеет свои собственные стили (а он почти всегда их имеет), но если их нет, то хватит просто Card.js без папки. */

// И т.к мы указали файл index.js, то в App.js мы можем не указывать прямой путь, а просто указать, какой компонент нам нужен и React сам всё поймёт:
import Card from './components/Card';

// В index.js нужно импортировать сами стили для их подключения:
import styles from './Card.module.scss';
console.log(styles); // Это объект, который хранит классы, описанные в файле.

// Теперь функция у нас должна выглядеть следующим образом:
function Card(props) {
    return ( // Если раньше у нас было className="card", то теперь обращаемся к свойству объекта стилей:
        <div className={styles.card}>
            <div className={styles.favorite}>
                <img src="/img/heart-unliked.svg" alt="Unliked" />
            </div>
            <img width={133} height={112} src={props.imageUrl} alt="Sneakers" />
            <h5>{props.title}</h5>
            <div className="d-flex justify-between align-center">
                <div className="d-flex flex-column">
                    <span>Цена:</span>
                    <b>{props.price} руб.</b>
                </div>
                <button className="button" onClick={props.onClick}>
                    <img width={11} height={11} src="/img/plus.svg" alt="Plus" />
                </button>
            </div>
        </div>
    );
}

/* Объект styles.card будет выглядеть, как "Card_card__kjhOw" -
т.е сначала указывается название компонента, потом название класса, а потом специальный уникальный идентификатор.
Это сделано для уникальности каждого класса. И теперь не нужно думать над названиями для классов. */

/* Стоит помнить, что если вылезает ошибка "Plugin "react" was conflicted between package.json » eslint-config-react-app",
то значит дело в пути, который я указал в консоли при "npm start".
Я часто ввожу его весь маленькими буквами, а он должен быть таким, как и называются папки (с большими буквами тоже, не игнорируя их). */

// Если файл содержит JSX разметку, то стоит использовать расширение .jsx, если же нет - то просто .js.


/* 4 УРОК - https://www.youtube.com/watch?v=gfx8IBUzZqw&list=PL0FGkDGJQjJEos_0yVkbKjsQ9zGVy3dG7&index=4 */


// При названии свойств надо называть грамотно, чтобы сразу было понятно за что это свойство отвечает.
/* Например, onClick - непонятно, при клике на что это будет происходить?
А onClickPlus - вполне понятно и грамотно. Понятно, что это будет происходить при клике на плюсе. Но главное не делать их слишком длинными и не зацикливаться на этом.
Например, onClickFavourite - очевидно, что при нажатии на избранное. */

// Стоит помнить, что даже когда в js меняется значение какой-либо переменной, то React об этом не знает и страницу не перерисовывает.
// useState() использует деструктуризацию и первая переменная это само значение, а вторая - функция, которая изменяет это значение.
// Сначала у нас значение false у константы isAdded, функция setIsAdded - для её изменения.
const [isAdded, setIsAdded] = React.useState(false);

const onClickPlus = () => { // Функция для события клика по кнопке
    setIsAdded(!isAdded); // Меняем значение isAdded на противоположное.
}

// Делаем условие в src, где в зависимости от значение isAdded выбирается svg`ашка.
<img src={isAdded ? "btn-checked.svg" : "btn-plus.svg"}></img>

// useEffect() выполняет код при изменение конкретного чего-либо.


// В React "условный рендеринг" обычно осуществляется с помощью тернарного оператора.
{ cartOpened ? <Drawer /> : null }

/* Также, это можно сделать таким способом:
Оператор && сначала проверяет левую часть и если она равна false, то на правую часть даже не смотрит (оптимизация).
Если же она равна true, то выполнение идёт дальше. */
{ cartOpened && <Drawer /> }

// Есть такой сервис, как mockAPi - это некий тестовый бекенд, на котором можно хранить свой JSON. Его мы и будем использовать (ссылку на бек с JSON данными).

// axios - это JS библиотека для обращения к бекенду/серверу и вытаскивания оттуда данных.

// Пример правильного использования fetch с помощью Промисов и .then():
fetch('https://60d381a361160900173c93d3.mockapi.io/items') // ссылка на json данные, хранящиеся на mockApi.
    .then((res) => {
        return res.json();
    })
    .then((json) => {
        setItems(json);
    });

/* Но стоит помнить, что при любом обновлении стейта/пропсов и тд - функция компонента перезапускается.
Поэтому, есть вероятность, что fetch будет отправлять запрос кучу раз, поэтому нам нужно использовать useEffect(), чтобы этого избежать. */
React.useEffect(() => {
    fetch('https://60d381a361160900173c93d3.mockapi.io/items')
        .then((res) => {
            return res.json();
        })
        .then((json) => {
            setItems(json);
        });
}, []); // Делаем это только при первом рендере


// Также, в функциях компонентов, которые получают пропсы, можно использовать деструктуризацию и тут мы используем свойства onClose и items.
function Drawer({ onClose, items = [] }) { } // Используем деструктуризацию, чтобы задать items дефолтное значение.
// Поэтому, можно теперь писать не props.onClose и props.items, а просто - onClose и items.


// Делаем функцию для добавления в корзину
const onAddToCart = (obj) => {
    // Также, более правильным считается такое добавление данных в стейт, а не братие переменной, в которой и храниться значение стейта.
    setCartItems((prev) => [...prev, obj]); // В функцию стейта всегда передаётся предыдущее значение.
};

<Card
    title={item.title}
    price={item.price}
    imageUrl={item.imageUrl}
    onFavorite={() => console.log('Добавили в закладки')}
    onPlus={(obj) => onAddToCart(obj)} // То, что в первых скобках - это то, что передали в само свойство onPlus() при вызове в другом компоненте.
/>


/* УРОК 5 - https://www.youtube.com/watch?v=J22CdUt5OOs&list=PL0FGkDGJQjJEos_0yVkbKjsQ9zGVy3dG7&index=5 */


/* Каждый HTML элемент, сгеенрированный с помощью map должен иметь уникальный идентификатор key.
Это возникает из-за того, что React не умеет различать элементы, которые были рендерены из массива.
Чтобы указать реакту, что элемент уникален, нужно в свойстве key указать уникальные данные,
например индекс элемента в массиве, но это не значит, что нужно делать рандом или типа того.
Это впринципе нужно для того, чтобы когда реакт сверял DOM древо и Virtual DOM, то видел разницу.
Но индекс делать не стоит, т.к реакту нужно более уникальное значение для key и это негативно скажется, если порядок элементов в списке измениться. */

// При изменении props компонент именно обновляется, а при изменение key он удаляется и добавляется на страницу снова (жизненный цикл перезапускается).
// Если до ререндера страницы конкретный key не существовал, то будет didMount.
// А до ререндера key существовал, а теперь его нет, то вызоветься willunmount.
/* Но key не должен соблюдать какое то рандомное значение - оно должно быть связано с элементом,
т.к это тогда никак не будет влиять на оптимизацию (а key и создан для оптимизации). */

/* Контролируемый инпут в реакт это когда ты берешь какие-то данные из инпута, то ты должен эти данные в этот инпут и сохранить.
Т.е сохранять значение инпута, например, в стейт. А потом этот стейт делать как value для инпута. */
const onChangeSearchInput = (event) => {
    setSearchValue(event.target.value);
};
<input value={searchValue}></input>
// И теперь у нас есть контролируемый инпут, т.к мы можем очистить в нём данные, просто очистив стейт.
// А неконтролируемый инпут это тот, чье value мы не можем контролировать с помощью кода.

// includes() ищёт точное совпадение, поэтому при фильтрации надо приводить к нижнему регистру.
{
    arr.filter((item) => item.title.toLowerCase().includes(searchValue)) // Пример обычной реализации поиска
        .map((obj) => (
            <Card
                title={obj.title}
                price={obj.price}
                imageUrl={obj.imageUrl}
            />
        ))
}

// Для установки axios надо прописать "npm install axios", а потом импортировать "import axios from 'axios'".
axios.get('/items').then((res) => { // С помощью axios можно сразу указывать запросы, которые тебе нужны.
    setItems(res.data); // А также тут не нужно переделывать его из json в объект, axios сам это делает и нужно проверять свойство data.
});
// Также, два axios запроса отправленные в одно время будут отправлять параллельно.
axios.get('/cart').then((res) => {
    setCartItems(res.data);
});

// Пример post запроса:
axios.post('/cart', obj);

// В React можно возвращать только один элемент. Т.е, к примеру, если у нас два дива, то они обязательно должны быть обёрнуты в родительский элемент.

// В package.json можно сделать свойство proxy и в него передать ссылку, на которую будут поступать запросы.
axios.get('/cart').then((res) => { // Поэтому, нам теперь не нужно писать всю ссылку - хватит только поддомена.
    setCartItems(res.data);
});

// React Router нужен для многостраничности и чтобы при переходе на другую страницу, был другой адрес в адресной строке, но это будет без перезагрузки страницы.
// Для установки - "npm install react-router-dom". Потом его нужно будет импортировать:
import { BrowserRouter as Router } from 'react-router-dom';

// И в Router надо будет обернуть всё наше приложение в index.js и с помощью этого мы и сможем делать роутинг - переход по страницам без перезагрузки.
ReactDOM.render(
    <React.StrictMode>
        <Router>
            <App />
        </Router>
    </React.StrictMode>,
    document.getElementById('root'),
);

// А в App.js надо будет импортировать Route:
import { Route } from 'react-router-dom';

// И теперь мы можем обернуть любой блок кода в Route и поставить свойство path - то, при каком адресе будет рендериться этот блок.
<div>
    <Route path="/" exact>
        <Home
            items={items}
            searchValue={searchValue}
            setSearchValue={setSearchValue}
            onChangeSearchInput={onChangeSearchInput}
            onAddToFavorite={onAddToFavorite}
            onAddToCart={onAddToCart}
        />
    </Route>

    <Route path="/favorites" exact> - Будет показываться только на странице фаворитов
        <Favorites items={favorites} onAddToFavorite={onAddToFavorite} />
    </Route>
</div>

// Теперь в файле, где юзер и должен попадать на страницу фаворитов, импортируем специальный объект Link:
import { Link } from 'react-router-dom';

// И теперь, нужно обёрнуть тот элемент, по нажатию на который юзер и будет попадать на нужную нам страницу.
// В свойстве to нужно указывать путь к странице, на которую будет ввести ссылка. В целом, Link - это тот же <a>, но с реактовским поведением.
// В HTML это будет как раз отображаться, как <a> с атрибутом href, но React будет это понимать по правильному и давать этой ссылке нужный функционал.
<Link to="/favorites">
    <img width={18} height={18} src="/img/heart.svg" alt="Закладки" />
</Link>

// Проще говоря, в Route надо оборачивать только тот контент, который должен рендериться только по конкретному адресу.

// React сравнивает так, что даже если что то будет идти после favorites, но перед этим будет "/", то тоже допустит. "/favorites/555" - допустимо, "favoriteswew" - нет.
// Но если добавить атрибут exact, то сравнение адреса будет строгое. "/favorites" - только оно допустимо, "/favorites/555" и тд - нет.
{/* <Link to="/favorites" exact>
    <img width={18} height={18} src="/img/heart.svg" alt="Закладки" />
</Link> */}

// Компоненты, которые отображаются только на определённых страницах, по логике, стоит хранить в папке pages.

// Чтобы передать какие либо данные из родительского компонента в дочерний можно просто использовать пропсы.
// Ещё, есть лайфхак - вместо того, чтобы передавать пропсы так:
<Card
    title={obj.title}
    price={obj.price}
    imageUrl={obj.imageUrl}
/>
// Можно так:
{/* <Card
    {...obj} - и все свойства, которые есть в этом объекте автоматически станут пропсами.
/> */}

/* Стоит помнить, что когда используешь async/await, то код стоит оборачивать в try/catch,
т.к без этого при использовании async/await js просто скажет, что произошла ошибка, но не скажет какая именно. */


/* УРОК 6 - https://www.youtube.com/watch?v=2jLFTiytfgg&list=PL0FGkDGJQjJEos_0yVkbKjsQ9zGVy3dG7&index=6 */


