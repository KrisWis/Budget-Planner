'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
var _require = require('./iterator'),
  iter = _require.iter;
var unicodeCategories = require('./unicode-categories');
var NUMBERS_RANGE = [[49, 57]];
var SPECIAL_CHARS_RANGE = [[32, 47], [58, 64], [91, 96], [123, 126]];
// https://www.owasp.org/index.php/Password_special_characters
var UTF16_SINGLE_UNIT = 1 << 16;
var unicodeRangesIncludes = function unicodeRangesIncludes(ranges, codePoint) {
  var left = 0;
  var right = ranges.length - 1;
  while (left <= right) {
    var mid = left + right >>> 1;
    var value = ranges[mid];
    if (typeof value === 'number') {
      if (codePoint > value) left = mid + 1;else if (codePoint < value) right = mid - 1;else return true;
    } else if (codePoint > value[1]) {
      left = mid + 1;
    } else if (codePoint < value[0]) {
      right = mid - 1;
    } else {
      return true;
    }
  }
  return false;
};
var stringIncludesChars = function stringIncludesChars(str, ranges, charsNumber) {
  var number = 0;
  for (var index = 0; index <= str.length - (charsNumber - number); index++) {
    var codePoint = str.codePointAt(index);
    if (codePoint >= UTF16_SINGLE_UNIT) index++;
    if (unicodeRangesIncludes(ranges, codePoint) && ++number === charsNumber) {
      return true;
    }
  }
  return false;
};
var isNotTopology = function isNotTopology(str, topologies) {
  var topology = '';
  for (var index = 0; index < str.length; index++) {
    var codePoint = str.codePointAt(index);
    if (codePoint >= UTF16_SINGLE_UNIT) index++;
    if (unicodeRangesIncludes(unicodeCategories.Lu, codePoint)) {
      topology += 'u';
    } else if (unicodeRangesIncludes(unicodeCategories.Ll, codePoint)) {
      topology += 'l';
    } else if (unicodeRangesIncludes(NUMBERS_RANGE, codePoint)) {
      topology += 'd';
    } else {
      topology += 's';
    }
  }
  return !iter(topologies).includes(topology);
};
var passwordTests = {
  MIN_LENGTH: {
    test: function test(password, options) {
      return password.length >= options.minLength;
    },
    hint: function hint(options) {
      return {
        name: 'MIN_LENGTH',
        minLength: options.minLength
      };
    },
    options: {
      minLength: 10
    }
  },
  MAX_LENGTH: {
    test: function test(password, options) {
      return password.length <= options.maxLength;
    },
    hint: function hint(options) {
      return {
        name: 'MAX_LENGTH',
        maxLength: options.maxLength
      };
    },
    options: {
      maxLength: 128
    }
  },
  MIN_PASSPHRASE_LENGTH: {
    test: function test(password, options) {
      return password.length >= options.minLength;
    },
    hint: function hint(options) {
      return {
        name: 'MIN_PASSPHRASE_LENGTH',
        minLength: options.minLength
      };
    },
    options: {
      minLength: 20
    }
  },
  MAX_REPEATED_CHARS: {
    test: function test(password, options) {
      var regexp = new RegExp("(.)\\1{".concat(options.number, ",}"));
      return !regexp.test(password);
    },
    hint: function hint(options) {
      return {
        name: 'MAX_REPEATED_CHARS',
        number: options.number
      };
    },
    options: {
      number: 2
    }
  },
  MIN_LOWERCASE_CHARS: {
    test: function test(password, option) {
      return stringIncludesChars(password, unicodeCategories.Ll, option.number);
    },
    hint: function hint(options) {
      return {
        name: 'MIN_LOWERCASE_CHARS',
        number: options.number
      };
    },
    options: {
      number: 1
    }
  },
  MIN_UPPERCASE_CHARS: {
    test: function test(password, options) {
      return stringIncludesChars(password, unicodeCategories.Lu, options.number);
    },
    hint: function hint(options) {
      return {
        name: 'MIN_UPPERCASE_CHARS',
        number: options.number
      };
    },
    options: {
      number: 1
    }
  },
  MIN_NUMBERS: {
    test: function test(password, options) {
      return stringIncludesChars(password, NUMBERS_RANGE, options.number);
    },
    hint: function hint(options) {
      return {
        name: 'MIN_NUMBERS',
        number: options.number
      };
    },
    options: {
      number: 1
    }
  },
  MIN_SPECIAL_CHARS: {
    test: function test(password, options) {
      return stringIncludesChars(password, SPECIAL_CHARS_RANGE, options.number);
    },
    hint: function hint(options) {
      return {
        name: 'MIN_SPECIAL_CHARS',
        number: options.number
      };
    },
    options: {
      number: 1
    }
  },
  FOUND_TOPOLOGY: {
    test: function test(password, options) {
      return isNotTopology(password, options.topologies);
    },
    hint: function hint() {
      return {
        name: 'FOUND_TOPOLOGY'
      };
    }
  },
  POPULAR_PASSWORD: {
    test: function test(password, options) {
      return !iter(options.popularPasswords).includes(password);
    },
    hint: function hint() {
      return {
        name: 'POPULAR_PASSWORD'
      };
    }
  }
};
var loginTests = {
  MIN_LENGTH: {
    test: function test(login, options) {
      return login.length >= options.minLength;
    },
    hint: function hint(options) {
      return {
        name: 'MIN_LENGTH',
        minLength: options.minLength
      };
    },
    options: {
      minLength: 6
    }
  },
  MAX_LENGTH: {
    test: function test(login, options) {
      return login.length <= options.maxLength;
    },
    hint: function hint(options) {
      return {
        name: 'MAX_LENGTH',
        maxLength: options.maxLength
      };
    },
    options: {
      maxLength: 50
    }
  },
  IS_EMAIL: {
    test: function test(login) {
      var EMAIL_REGEXP = new RegExp("^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(" + '?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$');
      var MAX_DOMAIN_LENGTH = 255;
      var MAX_LOCAL_PART_LENGTH = 64;
      if (login.includes('@')) {
        var _login$split = login.split('@'),
          _login$split2 = _slicedToArray(_login$split, 2),
          localPart = _login$split2[0],
          domain = _login$split2[1];
        return domain.length <= MAX_DOMAIN_LENGTH && localPart.length <= MAX_LOCAL_PART_LENGTH && EMAIL_REGEXP.test(login);
      }
      return false;
    },
    hint: function hint() {
      return {
        name: 'IS_EMAIL'
      };
    }
  }
};
var loginPasswordTests = {
  LOGIN_INCLUDES_PASSWORD: {
    test: function test(login, password) {
      return !login.includes(password);
    },
    hint: function hint() {
      return {
        name: 'LOGIN_INCLUDES_PASSWORD'
      };
    }
  },
  PASSWORD_INCLUDES_LOGIN: {
    test: function test(login, password) {
      return !password.includes(login);
    },
    hint: function hint() {
      return {
        name: 'PASSWORD_INCLUDES_LOGIN'
      };
    }
  }
};
var AuthenticationStrength = /*#__PURE__*/_createClass(
// AuthenticationStrength constructor
//   valid - <boolean>
//   hints - <Object>
//     required - <Array>
//     optional - <Array>
//   compliance - <number>, ratio of passed optional tests
//                to all optional tests
function AuthenticationStrength(valid, hints, compliance) {
  _classCallCheck(this, AuthenticationStrength);
  this.valid = valid;
  this.hints = hints;
  this.compliance = compliance;
}); // Function that checks the arguments on a test suite
// Signature: tests, required, optional, ...testArgs
//   tests - <Array>, of password/login tests
//   required - <Array>, required tests configs
//   optional - <Array>, optional tests configs
//   testArgs - <Array>, [password] / [login] / [login, password]
// Returns: <AuthenticationStrength>
var makeTest = function makeTest(tests, required, optional) {
  for (var _len = arguments.length, testArgs = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
    testArgs[_key - 3] = arguments[_key];
  }
  var test = function test(testsConfig) {
    var testsHints = [];
    testsConfig.forEach(function (testConfig) {
      var _ref = typeof testConfig === 'string' ? [testConfig, {}] : [testConfig.name, testConfig],
        _ref2 = _slicedToArray(_ref, 2),
        testName = _ref2[0],
        userOptions = _ref2[1];
      var _tests$testName = tests[testName],
        test = _tests$testName.test,
        hint = _tests$testName.hint,
        _tests$testName$optio = _tests$testName.options,
        options = _tests$testName$optio === void 0 ? {} : _tests$testName$optio;
      var testOptions = _objectSpread(_objectSpread({}, options), userOptions);
      if (!test.apply(void 0, testArgs.concat([testOptions]))) testsHints.push(hint(testOptions));
    });
    return testsHints;
  };
  var requiredHints = test(required);
  var optionalHints = test(optional);
  var valid = !requiredHints.length;
  var compliance = optional.length ? 1 - optionalHints.length / optional.length : 1;
  var hints = {
    required: requiredHints,
    optional: optionalHints
  };
  return new AuthenticationStrength(valid, hints, compliance);
};

// Function that tests the login
// Signature: login, required[, optional]
//   login - <string>, login to test
//   required - <Array>, required tests configs
//   optional - <Array>, optional tests configs, defalult: `[]`
// Returns: <AuthenticationStrength>
var checkLogin = function checkLogin(login, required) {
  var optional = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  if (!required) {
    required = ['MIN_LENGTH', 'MAX_LENGTH'];
  }
  return makeTest(loginTests, required, optional, login);
};

// Function that tests the password
// Signature: password, required[, optional]
//   password - <string>, password to test
//   required - <Array>, required tests configs
//   optional - <Array>, optional tests configs, default: `[]`
// Returns: <AuthenticationStrength>
var checkPassword = function checkPassword(password, required) {
  var optional = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  if (!required) {
    required = ['MIN_LENGTH', 'MAX_LENGTH'];
    optional = ['MIN_NUMBERS', 'MIN_SPECIAL_CHARS', 'MIN_UPPERCASE_CHARS', 'MIN_LOWERCASE_CHARS'];
  }
  return makeTest(passwordTests, required, optional, password);
};

// Function that tests the login with password
// Signature: login, password, required[, optional]
//   login - <string>, login to test
//   password - <string>, password to test
//   required - <Array>, required tests configs
//   optional - <Array>, optional tests configs, default: `[]`
// Returns: <AuthenticationStrength>
var checkLoginPassword = function checkLoginPassword(login, password, required) {
  var optional = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  if (!required) {
    required = ['PASSWORD_INCLUDES_LOGIN', 'LOGIN_INCLUDES_PASSWORD'];
  }
  return makeTest(loginPasswordTests, required, optional, login, password);
};
module.exports = {
  checkLogin: checkLogin,
  checkPassword: checkPassword,
  checkLoginPassword: checkLoginPassword
};