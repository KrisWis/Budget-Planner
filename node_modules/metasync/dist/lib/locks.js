'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _readOnlyError(name) { throw new Error("\"" + name + "\" is read-only"); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _require = require('events'),
    EventEmitter = _require.EventEmitter;

var _require2 = require('worker_threads'),
    Worker = _require2.Worker,
    isMainThread = _require2.isMainThread,
    parentPort = _require2.parentPort;

var threads = new Set();
var resources = new Map();
var LOCKED = 0;
var UNLOCKED = 1;

var sendMessage = function sendMessage(message) {
  if (isMainThread) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = threads[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var thread = _step.value;
        thread.worker.postMessage(message);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  } else {
    parentPort.postMessage(message);
  }
};

var Lock = function Lock(name) {
  var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'exclusive';

  _classCallCheck(this, Lock);

  this.name = name;
  this.mode = mode; // 'exclusive' or 'shared'

  this.queue = [];
};

var Mutex =
/*#__PURE__*/
function () {
  function Mutex(resourceName, buffer) {
    var initial = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    _classCallCheck(this, Mutex);

    this.name = resourceName;
    this.flag = new Int32Array(buffer, 0, 1);
    if (initial) Atomics.store(this.flag, 0, UNLOCKED);
    this.owner = false;
    this.trying = false;
    this.queue = [];
    this.current = null;
  }

  _createClass(Mutex, [{
    key: "enter",
    value: function enter(lock) {
      this.queue.push(lock);
      this.trying = true;
      return this.tryEnter();
    }
  }, {
    key: "tryEnter",
    value: function tryEnter() {
      var _this = this;

      if (this.queue.length === 0) return;
      var prev = Atomics.exchange(this.flag, 0, LOCKED);
      if (prev === LOCKED) return;
      this.owner = true;
      this.trying = false;
      var lock = this.queue.shift();
      this.current = lock;
      return lock.callback(lock).then(function () {
        _this.leave();
      });
    }
  }, {
    key: "enterIfAvailable",
    value: function enterIfAvailable(lock) {
      var _this2 = this;

      if (this.owner) return lock.callback();
      var prev = Atomics.exchange(this.flag, 0, LOCKED);
      if (prev === LOCKED) return lock.callback();
      this.owner = true;
      this.trying = false;
      this.current = lock;
      return lock.callback(lock).then(function () {
        _this2.leave();
      });
    }
  }, {
    key: "leave",
    value: function leave() {
      if (!this.owner) return;
      Atomics.store(this.flag, 0, UNLOCKED);
      this.owner = false;
      this.current = null;
      sendMessage({
        kind: 'leave',
        resourceName: this.name
      });
      this.tryEnter();
    }
  }]);

  return Mutex;
}();

var request = function request(resourceName, options, callback) {
  var lock = new Lock(resourceName, options, callback);
  var mutex = resources.get(resourceName);

  if (!mutex) {
    var buffer = new SharedArrayBuffer(4);
    mutex = new Mutex(resourceName, buffer, true);
    resources.set(resourceName, mutex);
    sendMessage({
      kind: 'create',
      resourceName: resourceName,
      buffer: buffer
    });
  }

  if (lock.ifAvailable) return mutex.enterIfAvailable(lock);
  return mutex.enter(lock);
};

var receiveMessage = function receiveMessage(message) {
  var kind = message.kind,
      resourceName = message.resourceName,
      buffer = message.buffer;

  if (kind === 'create') {
    var mutex = new Mutex(resourceName, buffer);
    resources.set(resourceName, mutex);
  } else if (kind === 'leave') {
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = resources[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var _mutex = _step2.value;
        if (_mutex.trying) _mutex.tryEnter();
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
          _iterator2["return"]();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  }
};

if (!isMainThread) {
  parentPort.on('message', receiveMessage);
}

var Thread = function Thread(filename, options) {
  _classCallCheck(this, Thread);

  var worker = new Worker(filename, options);
  this.worker = worker;
  threads.add(this);
  worker.on('message', function (message) {
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = threads[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var thread = _step3.value;

        if (thread.worker !== worker) {
          thread.worker.postMessage(message);
        }
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
          _iterator3["return"]();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    receiveMessage(message);
  });
};

var LockManager =
/*#__PURE__*/
function () {
  function LockManager(name) {
    _classCallCheck(this, LockManager);

    this.collection = new Map();
  }

  _createClass(LockManager, [{
    key: "request",
    value: function () {
      var _request = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(name, options, callback) {
        var _options, _options$mode, mode, _options$signal, signal, lock, finished, aborted, next, _next2, _next3, handler, resolve;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (typeof options === 'function') {
                  callback = options;
                  options = {};
                }

                _options = options, _options$mode = _options.mode, mode = _options$mode === void 0 ? 'exclusive' : _options$mode, _options$signal = _options.signal, signal = _options$signal === void 0 ? null : _options$signal;
                lock = this.collection.get(name);

                if (!lock) {
                  _context.next = 8;
                  break;
                }

                if (!(mode === 'exclusive')) {
                  _context.next = 6;
                  break;
                }

                return _context.abrupt("return", new Promise(function (resolve) {
                  lock.queue.push([callback, resolve]);
                }));

              case 6:
                _context.next = 10;
                break;

              case 8:
                lock = new Lock(name, mode);
                this.collection.set(name, lock);

              case 10:
                finished = callback(lock);
                aborted = null;

                if (!signal) {
                  _context.next = 18;
                  break;
                }

                aborted = (_readOnlyError("aborted"), new Promise(function (resolve, reject) {
                  signal.on('abort', reject);
                }));
                _context.next = 16;
                return Promise.race([finished, aborted]);

              case 16:
                _context.next = 20;
                break;

              case 18:
                _context.next = 20;
                return finished;

              case 20:
                next = lock.queue.pop();

              case 21:
                if (!next) {
                  _context.next = 29;
                  break;
                }

                _next2 = next, _next3 = _slicedToArray(_next2, 2), handler = _next3[0], resolve = _next3[1];
                _context.next = 25;
                return handler(lock);

              case 25:
                resolve();
                next = lock.queue.pop();
                _context.next = 21;
                break;

              case 29:
                this.collection["delete"](name);

              case 30:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function request(_x, _x2, _x3) {
        return _request.apply(this, arguments);
      }

      return request;
    }()
  }]);

  return LockManager;
}();

var AbortError =
/*#__PURE__*/
function (_Error) {
  _inherits(AbortError, _Error);

  function AbortError(message) {
    var _this3;

    _classCallCheck(this, AbortError);

    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(AbortError).call(this, message));
    _this3.name = 'AbortError';
    return _this3;
  }

  return AbortError;
}(_wrapNativeSuper(Error));

var AbortSignal =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(AbortSignal, _EventEmitter);

  function AbortSignal() {
    var _this4;

    _classCallCheck(this, AbortSignal);

    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(AbortSignal).call(this));
    _this4.aborted = false;

    _this4.on('abort', function () {
      _this4.aborted = true;
    });

    return _this4;
  }

  return AbortSignal;
}(EventEmitter);

var AbortController =
/*#__PURE__*/
function () {
  function AbortController() {
    _classCallCheck(this, AbortController);

    this.signal = new AbortSignal();
  }

  _createClass(AbortController, [{
    key: "abort",
    value: function abort() {
      var error = new AbortError('The request was aborted');
      this.signal.emit('abort', error);
    }
  }]);

  return AbortController;
}();

var locks = new LockManager();
module.exports = {
  locks: locks
};