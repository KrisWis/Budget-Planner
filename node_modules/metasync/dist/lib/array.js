'use strict'; // Asynchronous map (iterate parallel)
//   items - <Array>, incoming
//   fn - <Function>, to be executed for each value in the array
//     current - <any>, current element being processed in the array
//     callback - <Function>
//       err - <Error> | <null>
//       value - <any>
//   done - <Function>, on done
//     err - <Error> | <null>
//     result - <Array>

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var map = function map(items, fn, done) {
  var len = items.length;

  if (!len) {
    done(null, []);
    return;
  }

  var errored = false;
  var count = 0;
  var result = new Array(len);

  var next = function next(index, err, value) {
    if (errored) return;

    if (err) {
      errored = true;
      done(err);
      return;
    }

    result[index] = value;
    count++;
    if (count === len) done(null, result);
  };

  for (var i = 0; i < len; i++) {
    fn(items[i], next.bind(null, i));
  }
};

var DEFAULT_OPTIONS = {
  min: 5,
  percent: 0.7
}; // Non-blocking synchronous map
// Signature: items, fn[, options][, done]
//   items - <Array>, incoming dataset
//   fn - <Function>
//     item - <any>
//     index - <number>
//   options - <Object>, map params, optional
//     min - <number>, min number of items in one next call
//     percent - <number>, ratio of map time to all time
//   done - <Function>, call on done, optional
//     err - <Error> | <null>
//     result - <Array>

var asyncMap = function asyncMap(items, fn) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var done = arguments.length > 3 ? arguments[3] : undefined;

  if (typeof options === 'function') {
    done = options;
    options = DEFAULT_OPTIONS;
  }

  if (!items.length) {
    if (done) done(null, []);
    return;
  }

  var min = options.min || DEFAULT_OPTIONS.min;
  var percent = options.percent || DEFAULT_OPTIONS.percent;
  var begin;
  var sum = 0;
  var count = 0;
  var result = done ? new Array(items.length) : null;
  var ratio = percent / (1 - percent);

  var countNumber = function countNumber() {
    var loopTime = Date.now() - begin;
    var itemTime = sum / count;
    var necessaryNumber = ratio * loopTime / itemTime;
    return Math.max(necessaryNumber, min);
  };

  var next = function next() {
    var itemsNumber = count ? countNumber() : min;
    var iterMax = Math.min(items.length, itemsNumber + count);
    begin = Date.now();

    for (; count < iterMax; count++) {
      var itemResult = fn(items[count], count);
      if (done) result[count] = itemResult;
    }

    sum += Date.now() - begin;

    if (count < items.length) {
      begin = Date.now();
      setTimeout(next, 0);
    } else if (done) {
      done(null, result);
    }
  };

  next();
}; // Asynchrous filter (iterate parallel)
//   items - <Array>, incoming
//   fn - <Function>, to be executed for each value in the array
//     value - <any>, item from items array
//     callback - <Function>
//       err - <Error> | <null>
//       accepted - <boolean>
//   done - <Function>, on done
//     err - <Error> | <null>
//     result - <Array>
//
// Example:
// metasync.filter(
//   ['data', 'to', 'filter'],
//   (item, callback) => callback(item.length > 2),
//   (err, result) => console.dir(result)
// );


var filter = function filter(items, fn, done) {
  var len = items.length;

  if (!len) {
    done(null, []);
    return;
  }

  var count = 0;
  var suitable = 0;
  var data = new Array(len);
  var rejected = Symbol('rejected');

  var next = function next(index, err, accepted) {
    if (!accepted || err) {
      data[index] = rejected;
    } else {
      data[index] = items[index];
      suitable++;
    }

    count++;

    if (count === len) {
      var result = new Array(suitable);
      var pos = 0;

      for (var i = 0; i < len; i++) {
        var val = data[i];
        if (val !== rejected) result[pos++] = val;
      }

      done(null, result);
    }
  };

  for (var i = 0; i < len; i++) {
    fn(items[i], next.bind(null, i));
  }
};

var REDUCE_EMPTY_ARR = 'Metasync: reduce of empty array with no initial value'; // Asynchronous reduce
// Signature: items, fn, done[, initial]
//   items - <Array>, incoming
//   fn - <Function>, to be executed for each value in array
//     previous - <any>, value previously returned in the last iteration
//     current - <any>, current element being processed in the array
//     callback - <Function>, callback for returning value
//         back to reduce function
//       err - <Error> | <null>
//       data - <any>, resulting value
//     counter - <number>, index of the current element
//         being processed in array
//     items - <Array>, the array reduce was called upon
//   done - <Function>, on done
//     err - <Error> | <null>
//     result - <Array>
//   initial - <any>, optional value to be used as first
//       argument in first iteration

var reduce = function reduce(items, fn, done, initial) {
  var len = items.length;
  var hasInitial = typeof initial !== 'undefined';

  if (len === 0 && !hasInitial) {
    done(new TypeError(REDUCE_EMPTY_ARR), initial);
    return;
  }

  var previous = hasInitial ? initial : items[0];

  if (len === 0 && hasInitial || len === 1 && !hasInitial) {
    done(null, previous);
    return;
  }

  var count = hasInitial ? 0 : 1;
  var current = items[count];
  var last = len - 1;

  var next = function next(err, data) {
    if (err) {
      done(err);
      return;
    }

    if (count === last) {
      done(null, data);
      return;
    }

    count++;
    previous = data;
    current = items[count];
    fn(previous, current, next, count, items);
  };

  fn(previous, current, next, count, items);
};

var REDUCE_RIGHT_EMPTY_ARR = 'Metasync: reduceRight of empty array with no initial value'; // Asynchronous reduceRight
// Signature: items, fn, done[, initial]
//   items - <Array>, incoming
//   fn - <Function>, to be executed for each value in array
//     previous - <any>, value previously returned in the last iteration
//     current - <any>, current element being processed in the array
//     callback - <Function>, callback for returning value
//         back to reduce function
//       err - <Error> | <null>
//       data - <any>, resulting value
//     counter - <number>, index of the current element
//         being processed in array
//     items - <Array>, the array reduce was called upon
//   done - <Function>, on done
//     err - <Error> | <null>
//     result - <Array>
//   initial - <any>, optional value to be used as first
//       argument in first iteration

var reduceRight = function reduceRight(items, fn, done, initial) {
  var len = items.length;
  var hasInitial = typeof initial !== 'undefined';

  if (len === 0 && !hasInitial) {
    done(new TypeError(REDUCE_RIGHT_EMPTY_ARR), initial);
    return;
  }

  var previous = hasInitial ? initial : items[len - 1];

  if (len === 0 && hasInitial || len === 1 && !hasInitial) {
    done(null, previous);
    return;
  }

  var count = hasInitial ? len - 1 : len - 2;
  var current = items[count];
  var last = 0;

  var next = function next(err, data) {
    if (err) {
      done(err);
      return;
    }

    if (count === last) {
      done(null, data);
      return;
    }

    count--;
    previous = data;
    current = items[count];
    fn(previous, current, next, count, items);
  };

  fn(previous, current, next, count, items);
}; // Asynchronous each (iterate in parallel)
//   items - <Array>, incoming
//   fn - <Function>
//     value - <any>, item from items array
//     callback - <Function>
//       err - <Error> | <null>
//   done - <Function>, on done
//     err - <Error> | <null>
//     items - <Array>
//
// Example:
// metasync.each(
//   ['a', 'b', 'c'],
//   (item, callback) => {
//     console.dir({ each: item });
//     callback();
//   },
//   (err, data) => console.dir('each done')
// );


var each = function each(items, fn, done) {
  var len = items.length;

  if (len === 0) {
    done(null, items);
    return;
  }

  var count = 0;
  var errored = false;

  var next = function next(err) {
    if (errored) return;

    if (err) {
      errored = true;
      done(err);
      return;
    }

    count++;
    if (count === len) done(null);
  };

  for (var i = 0; i < len; i++) {
    fn(items[i], next);
  }
}; // Asynchronous series
//   items - <Array>, incoming
//   fn - <Function>
//     value - <any>, item from items array
//     callback - <Function>
//       err - <Error> | <null>
//   done - <Function>, on done
//     err - <Error> | <null>
//     items - <Array>
//
// Example:
// metasync.series(
//   ['a', 'b', 'c'],
//   (item, callback) => {
//     console.dir({ series: item });
//     callback();
//   },
//   (err, data) => {
//     console.dir('series done');
//   }
// );


var series = function series(items, fn, done) {
  var len = items.length;
  var i = -1;

  var next = function next() {
    i++;

    if (i === len) {
      done(null, items);
      return;
    }

    fn(items[i], function (err) {
      if (err) {
        done(err);
        return;
      }

      setImmediate(next);
    });
  };

  next();
}; // Asynchronous find (iterate in series)
//   items - <Array>, incoming
//   fn - <Function>,
//     value - <any>, item from items array
//     callback - <Function>
//       err - <Error> | <null>
//       accepted - <boolean>
//   done - <Function>, on done
//     err - <Error> | <null>
//     result - <any>
//
// Example:
// metasync.find(
//   [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],
//   (item, callback) => callback(null, item % 3 === 0 && item % 5 === 0),
//   (err, result) => {
//     console.dir(result);
//   }
// );


var find = function find(items, fn, done) {
  var len = items.length;

  if (len === 0) {
    done();
    return;
  }

  var finished = false;
  var last = len - 1;

  var next = function next(index, err, accepted) {
    if (finished) return;

    if (err) {
      finished = true;
      done(err);
      return;
    }

    if (accepted) {
      finished = true;
      done(null, items[index]);
      return;
    }

    if (index === last) done(null);
  };

  for (var i = 0; i < len; i++) {
    fn(items[i], next.bind(null, i));
  }
}; // Asynchronous every
//   items - <Array>, incoming
//   fn - <Function>,
//     value - <any>, item from items array
//     callback - <Function>
//       err - <Error> | <null>
//       accepted - <boolean>
//   done - <Function>, on done
//     err - <Error> | <null>
//     result - <boolean>


var every = function every(items, fn, done) {
  if (items.length === 0) {
    done(null, true);
    return;
  }

  var proceedItemsCount = 0;
  var len = items.length;

  var finish = function finish(err, accepted) {
    if (!done) return;

    if (err || !accepted) {
      done(err, false);
      done = null;
      return;
    }

    proceedItemsCount++;
    if (proceedItemsCount === len) done(null, true);
  };

  var _iterator = _createForOfIteratorHelper(items),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var item = _step.value;
      fn(item, finish);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}; // Asynchronous some (iterate in series)
//   items - <Array>, incoming
//   fn - <Function>
//     value - <any>, item from items array
//     callback - <Function>
//       err - <Error> | <null>
//       accepted - <boolean>
//   done - <Function>, on done
//     err - <Error> | <null>
//     result - <boolean>


var some = function some(items, fn, done) {
  var len = items.length;
  var i = 0;

  var next = function next() {
    if (i === len) {
      done(null, false);
      return;
    }

    fn(items[i], function (err, accepted) {
      if (err) {
        done(err);
        return;
      }

      if (accepted) {
        done(null, true);
        return;
      }

      i++;
      next();
    });
  };

  if (len > 0) next();else done(null, false);
};

module.exports = {
  map: map,
  filter: filter,
  reduce: reduce,
  reduceRight: reduceRight,
  each: each,
  series: series,
  find: find,
  every: every,
  some: some,
  asyncMap: asyncMap
};