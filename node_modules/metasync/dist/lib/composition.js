'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function Composition() {}

var COMPOSE_CANCELED = 'Metasync: asynchronous composition canceled';
var COMPOSE_TIMEOUT = 'Metasync: asynchronous composition timed out'; // Asynchronous functions composition
// Array of functions results in sequential execution: `[f1, f2, f3]`
// Double brackets array of functions results
// in parallel execution: `[[f1, f2, f3]]`
//   flow - <Function[]>, callback-last / err-first
//
// Returns: <Function>, composed callback-last / err-first
//
// Example:
// const composed = metasync([f1, f2, f3, [[f4, f5, [f6, f7], f8]], f9]);

var compose = function compose(flow) {
  var comp = function comp(data, callback) {
    if (!callback) {
      if (typeof data === 'function') {
        callback = data;
        data = {};
      } else {
        comp.data = data;
        return comp;
      }
    }

    comp.done = callback;

    if (comp.canceled) {
      if (callback) {
        callback(new Error(COMPOSE_CANCELED));
      }

      return comp;
    }

    if (comp.timeout) {
      comp.timer = setTimeout(function () {
        comp.timer = null;

        if (callback) {
          callback(new Error(COMPOSE_TIMEOUT));
          comp.done = null;
        }
      }, comp.timeout);
    }

    comp.context = data;
    comp.arrayed = Array.isArray(comp.context);
    comp.paused = false;

    if (comp.len === 0) {
      comp.finalize();
      return comp;
    }

    if (comp.parallelize) comp.parallel();else comp.sequential();
    return comp;
  };

  var first = flow[0];
  var parallelize = flow.length === 1 && Array.isArray(first);
  var fns = parallelize ? first : flow;
  comp.fns = fns;
  comp.parallelize = parallelize;
  comp.context = null;
  comp.timeout = 0;
  comp.timer = null;
  comp.len = fns.length;
  comp.canceled = false;
  comp.paused = true;
  comp.arrayed = false;
  comp.done = null;
  comp.onResume = null;
  Object.setPrototypeOf(comp, Composition.prototype);
  return comp;
};

Composition.prototype.on = function (name, callback) {
  if (name === 'resume') {
    this.onResume = callback;
  }
};

Composition.prototype.finalize = function (err) {
  var _this = this;

  if (this.canceled) return;

  if (this.timer) {
    clearTimeout(this.timer);
    this.timer = null;
  }

  var callback = this.done;

  if (callback) {
    if (this.paused) {
      this.on('resume', function () {
        _this.done = null;
        callback(err, _this.context);
      });
    } else {
      this.done = null;
      callback(err, this.context);
    }
  }
};

Composition.prototype.collect = function (err, result) {
  if (this.canceled) return;

  if (err) {
    var callback = this.done;

    if (callback) {
      this.done = null;
      callback(err);
    }

    return;
  }

  if (result !== this.context && result !== undefined) {
    if (this.arrayed) {
      this.context.push(result);
    } else if (_typeof(result) === 'object') {
      Object.assign(this.context, result);
    }
  }
};

Composition.prototype.parallel = function () {
  var _this2 = this;

  var counter = 0;

  var next = function next(err, result) {
    _this2.collect(err, result);

    if (++counter === _this2.len) _this2.finalize();
  };

  var fns = this.fns;
  var len = this.len;
  var context = this.context;

  for (var i = 0; i < len; i++) {
    var fn = fns[i];
    var fc = Array.isArray(fn) ? compose(fn) : fn;
    fc(context, next);
  }
};

Composition.prototype.sequential = function () {
  var _this3 = this;

  var counter = -1;
  var fns = this.fns;
  var len = this.len;
  var context = this.context;

  var next = function next(err, result) {
    if (_this3.canceled) return;
    if (err || result) _this3.collect(err, result);

    if (++counter === len) {
      _this3.finalize();

      return;
    }

    var fn = fns[counter];
    var fc = Array.isArray(fn) ? compose(fn) : fn;

    if (_this3.paused) {
      _this3.on('resume', function () {
        return fc(context, next);
      });
    } else {
      fc(context, next);
    }
  };

  next();
};

Composition.prototype.then = function (fulfill, reject) {
  if (this.canceled) {
    reject(new Error(COMPOSE_CANCELED));
    return this;
  }

  this(function (err, result) {
    if (err) reject(err);else fulfill(result);
  });
  return this;
}; // Clone composed


Composition.prototype.clone = function () {
  var fns = this.fns.slice();
  var flow = this.parallelize ? [fns] : fns;
  return compose(flow);
}; // Pause execution


Composition.prototype.pause = function () {
  if (this.canceled) return this;
  this.paused = true;
  return this;
}; // Resume execution


Composition.prototype.resume = function () {
  if (this.canceled) return this;
  this.paused = false;

  if (this.onResume) {
    var callback = this.onResume;
    this.onResume = null;
    callback();
  }

  return this;
}; // Set timeout
//   msec - <number>


Composition.prototype.timeout = function (msec) {
  this.timeout = msec;
  return this;
}; // Cancel execution where possible


Composition.prototype.cancel = function () {
  if (this.canceled) return this;
  this.canceled = true;
  var callback = this.done;

  if (callback) {
    this.done = null;
    callback(new Error(COMPOSE_CANCELED));
  }

  return this;
};

module.exports = {
  compose: compose,
  Composition: Composition
};