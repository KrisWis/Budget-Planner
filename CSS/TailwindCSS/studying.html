<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TailwindCSS</title>
    <!-- Чтобы добавить фреймворк TailwindCSS, можно использовать следующую строку: -->
    <script src="https://cdn.tailwindcss.com/"></script>
    <!-- Подключаем css файл со стилями. -->
    <link rel="stylesheet" href="/public/styles.css">
</head>
<body>
    <!-- УСТАНОВКА ОКРУЖЕНИЯ. https://www.youtube.com/watch?v=z36GC0fA4OM&list=PLNkWIWHIRwMFN8qKfZ5Lgr29L5BoJKFfa&index=7 -->   


    <!-- Плагин Live Server нужен для того, чтобы прямо в редакторе кода запускать сервер и динамически изменять страницу. -->
    <!-- Чтобы добавить Tailwind нужно использовать команду "npm json" в терминале, чтобы создать файл "package.json". 
    Потом в терминал пишем команду "yarn add -D tailwindcss postcss". После "npx tailwindcss init". 
    В поле "content" в файле "tailwind.config.js" пишем путь для файлов, который будет использовать tailwind. 
    Создаём папку "src" и в ней файл "main.css". И в ней пишем:
    @tailwind base;
    @tailwind components;
    @tailwind utilities; -->
    <!-- Это элементы, которые обязательно должны быть подключены в проект. 
    Далее, в файле "package.json" в поле "scripts" пишем: 
    "build": "tailwindcss build -i src/main.css -o public/styles.css --watch", где src/main.css - файл в котором будем писать код на TailwindCSS, 
    и он будет компелироваться в файл public/styles.css, в котором будет сам css файл. 
    Флаг --watch нужен, чтобы файл styles.css обновлялся автоматически.
    В этом файле сразу будут стили, которые представляют из себя Normalize CSS. -->

    <!-- С помощью классов из styles.css добавляем стили к элементу.
    text-3xl увеличивает текст, font-bold делает шрифт жирным, underline добавляет подчёркивание, text-black делает текст чёрным. -->
    <h1 class="text-3xl font-bold underline text-black">
        Hello world!
    </h1>
    <!-- ВАЖНО: Импортируем скрипт, чтобы точно все TailwindCSS классы работали. -->
    <script src="https://cdn.tailwindcss.com/"></script>
    

    <!-- ШРИФТЫ И ЦВЕТА. https://www.youtube.com/watch?v=U5Jg69DloXQ&list=PLNkWIWHIRwMFN8qKfZ5Lgr29L5BoJKFfa&index=4 -->


    <!-- Механизм гененерации styles.css следующий: 
    Мы создаём разметку и навешиваем на элементы определённые классы. 
    Tailwind с помощью файла tailwind.config.js, где указан путь до html файла, анализирует эту разметку. 
    И на основании этой разметки, генерирует styles.css с этими классами и стилями, которые к ним относяться. -->
    <!-- Стили подключаются в html разметке с помощью классов - это особенность TailwindCSS. -->

    <!-- header>a{webDev}+nav>ul>li*3>a[href=#]
    С помощью данной конструкции можно создать элемент header c элементами "a" с текстом "webDev" и 
    nav, в котором будет элемент ul с тремя элементами li, каждый с элементом "a", который имеет значение "#" у атрибута href.
    В фигурных скобках указывается текст, а в квадратных атрибуты. -->
    <header>
        <!-- Стилилизуем логотип, делая его всего в верхнем регистре с помощью класса uppercase, 
            увеличиваем ширину текста с помощью font-bold и меняем цвет на фиолетовый c помощью text-purple-800. -->
        <a class="uppercase font-bold text-purple-800" href="">webDev</a>
        <nav>
            <!-- Стилилизуем все элемент "li" путём наследования от родительского элемента ul,
                серым цветом с помощью text-gray-500 и делаем текст полужирным, используя font-semibold. -->
            <ul class="text-gray-500 font-semibold">
                <!-- href="#" переместит положение прокрутки наверх. Чаще всего, это дефолтный заполнитель для элементов ссылок. -->
                <li><a href="#">Home</a></li>
                <li><a href="#">About</a></li>
                <li><a href="#">Contacts</a></li>
            </ul>
        </nav>
    </header>


    <!-- ОТСТУПЫ И ГРАНИЦА. https://www.youtube.com/watch?v=kddzWvIK4pY&list=PLNkWIWHIRwMFN8qKfZ5Lgr29L5BoJKFfa&index=4 -->


    <!-- Напомню, CSS padding - это внутренний отступ объекта. От границы до содержимого. 
        CSS Margin –это внешний отступ от границ объекта до окружающих элементов. -->
    <!-- Чтобы добавлять padding и margin в TailwindCSS есть классы p и m.
    Указывая класс, нужно поставить тире и выбрать размер отступа.
    Если перед классом поставить "-" то margin или padding будет отрицательным. -->
    <header class="m-4"></header>
    <!-- Если перед классом поставить "-" то margin или padding будет отрицательным. -->
    <header class="-m-10"></header>
    <!-- Если отступ нужно добавить только слева и справа или только сверху и снизу, то
    после "m" или "p" нужно поставить "x" или "y", которые определяют по какой оси будет добавлен отступ. -->
    <header class="px-3.5"></header>
    <!-- Добавляем горизонтальный margin и вертикальный padding. -->
    <header class="mx-10 py-5"></header>
    <!-- Чтобы добавить margin или padding только с одной стороны, то
    после "m" или "p" нужно поставить "t" (top), "r" (right), "b" (bottom), "l" (left). -->
    <header class="mt-10 pl-20"></header>
    <!-- Чтобы добавить на элемент границу понадобиться класс border.
    Указывая класс, нужно поставить тире и выбрать размер границы.
    Обводка будет со всех сторон, серая, шириной в 1px и solid. 
    Но выбрав, например цифру 8, размер этой обводки будет 8px. -->
    <header class="border-8"></header>
    <!-- Если обводку нужно добавить только слева и справа или только сверху и снизу, то
    после "border" нужно поставить "x" или "y", которые определяют по какой оси будет добавлен отступ. -->
    <header class="border-x-8"></header>
    <!-- Чтобы добавить border только с одной стороны, то
    после "border" нужно поставить "t" (top), "r" (right), "b" (bottom), "l" (left). -->
    <header class="border-t-8"></header>
    <!-- Чтобы добавить цвет нужно добавить ещё класс, 
    который будет содержать border, сторону (t, r, b, l), и сам цвет с его насыщеностью.
    Чтобы добавить стиль обводки также нужно добавить ещё один класс: 
    после написания border нужно написать стиль обводки (dashed - пунктир). -->
    <header class="border-b-10 border-b-red-900 border-dashed"></header>
    <!-- С помощью класса "inline-block" можно сделать элемент блочно-строчным. -->
    <li><a class="inline-block py-3 px-2" href="#">Home</a></li>
    <!-- Конструкция "main>div>div>a[href=#]*3" создаст следующую структуру: -->
    <main>
        <div>
            <div>
                <a href="#"></a>
                <a href="#"></a>
                <a href="#"></a>
            </div>
        </div>
    </main>
    <!-- Конструкция "footer>div>div>h6+ul>li*2>a[href=#]" создаст следующую структуру: -->
    <footer>
        <div>
            <div>
                <h6></h6>
                <ul>
                    <li><a href="#"></a></li>
                    <li><a href="#"></a></li>
                </ul>
            </div>
        </div>
    </footer>


    <!-- ДЕКОРИРОВАНИЕ. https://www.youtube.com/watch?v=UoNGb6Xn46M&list=PLNkWIWHIRwMFN8qKfZ5Lgr29L5BoJKFfa&index=5 -->


    <!-- Чтобы добавить состояние (псевдоклассы в TailwindCSS) на элемент, используя TailwindCSS, 
    нужно указать название состояния (в нашем случае hover), поставить двоеточие и указать свойство.
    Указать несколько свойств с помощью одного состояния не получиться. -->
    <li><a class="inline-block py-3 px-2 hover:text-black" href="#">Home</a></li>
    <!-- Состояния можно комбинировать, например, в следующем примере, 
    мы изменяем фон на розовый для в темном режиме, в средней точке, при наведении. -->
    <li><a class="dark:md:hover:bg-fuchsia-600" href="#">Home</a></li>
    <!-- Чтобы элемент красиво подчёркивался при наведении задаём ему позицию снизу (border-b-2) 
    и по дефолту делаем её прозрачной (border-transparent), но при наведении делаем её фиолетовой (hover:border-violet-800). -->
    <li><a class="border-b-2 border-transparent hover:border-violet-800" href="#">Home</a></li>
    <!-- Класс decoration изменяет стилилизацию подчёркивания.
    Указав decoration-4, подчёркивание станет жирнее. -->
    <li><a class="hover:underline decoration-4" href="#">Documentation</a></li>
    <!-- Чтобы указать цвет подчёркиванию, после класса decoration указываем нужный цвет и насыщенность. -->
    <li><a class="hover:underline decoration-green-500" href="#">Documentation</a></li>
    <!-- Также, мы можем выбрать стиль подчёркивания, по умолчанию она прямая и сплошная, т.е solid. А также, есть:
    double - двойная черта;
    dotted - подчёркивание точками;
    dashed -  пунктир;
    wavy - волнистая линия. -->
    <li><a class="hover:underline decoration-green-500 decoration-wavy" href="#">Documentation</a></li>
    <!-- Чтобы разделить какие то элементы между друг другом точечной линией, 
    можно использовать пустые блоки div с классами border и border-dotted. -->
    <div class="border border-dotted"></div>
    <!-- Также, мы можем задать то, насколько линия подчёркивания будет отступать от элемента с помощью underline-offset.
    После underline-offset нужно указать то, насколько пикселей будет отступать линия подчёркивания от элемента. -->
    <li><a class="hover:underline underline-offset-2" href="#">Documentation</a></li>
    <!-- С помощью конструкции "div>h5{Subscribe}+p+input[type=email]" получиться следующий код: " -->
    <div>
        <h5>Subscribe</h5>
        <p></p>
        <input type="email"></input>
    </div>
    <!-- Чтобы добавить фон для элемента используют свойство bg. -->
    <input placeholder="your email address" type="email" class="text-gray-700 bg-gray-100"></input>
    <!-- text-lg увеличивает размер текста. Класс w-full говорит о том, что input будет занимать всю ширину. -->
    <h5 class="text-lg w-full">Subscribe</h5>
    <!-- Класс rounded нужен для того, чтобы округлять элемент (работает если есть, что округлять, в нашем случае - обводка). 
    В нашем случае, указан rounded-t, значит обводка будет только сверху. -->
    <input class="border rounded-t"></input>
    

    <!-- КНОПКИ. https://www.youtube.com/watch?v=G1IH3rNpdB4&list=PLNkWIWHIRwMFN8qKfZ5Lgr29L5BoJKFfa&index=6 -->


    <!-- Конструкция "ul>li*2>button" создаст: -->
    <ul>
        <li><button></button></li>
        <li><button></button></li>
    </ul>
    <!-- С помощью padding создаём границу не вплотную на элементе. -->
    <li><button class="py-1 px-3 border-2">Login</button></li>
    <!-- Класс rounded-full округлит все углы границы. -->
    <li><button class="border rounded-full">Login</button></li>
    <!-- Лучше всего, всем элементам на странице, с которыми можно взаимодействовать добавлять изменение при наведении.
    Класс bg отвечает за фон элемента. -->
    <li><button class="text-indigo-600 hover:text-white hover:bg-indigo-800">Login</button></li>
    <!-- Чтобы задать тень элементу, используется класс shadow. 
    Можно определить размер тени используя: 
    shadow-sm - маленькая тень;
    shadow-md - средняя тень;
    shadow-lg - большая тень. 
    Также, можно указать цвет тени, указав его после shadow. -->
    <li><button class="shadow-md shadow-teal-900">Shadow</button></li>
    <!-- Многие выключают дефолтную обводку элемента браузером при нажатии Tab, 
    но лучше, чтобы сохранить доступность и обводка подходила под дизайн сайта сделать свою кастомную обводку.
    Для этого используется состояние focus. 
    С помощью focus:outline-none скрываем дефолтную обводку элемента при нажатии Tab.
    А потом, используя focus:ring задаём нашу круговую обводку и делаем её цветной (focus:ring-indigo-600). -->
    <li><button class="focus:outline-none focus:ring focus:ring-indigo-600">Login</button></li>
    <!-- А чтобы стилилизовать дефолтную браузерную обводку нужно использовать класс outline. -->
    <li><button class="focus:outline-dashed focus:outline-indigo-600">Login</button></li>
    <!-- Красивая кнопка подписки (rounded-b округляет углы снизу кнопки): -->
    <button class="py-2 px-4 border-2 rounded-b w-full bg-indigo-600 text-white hover:bg-indigo-800">Subscribe</button>
    <!-- Как и в CSS, в TailwindCSS элементы ссылок можно легко стилизировать под кнопки. -->
    <!-- Создадим для этого пагинацию. Пагинация — это те цифры внизу сайта, с помощью которых, можно переключаться по страницам. -->
    <!-- С помощью конструкции "div>ul>li*7>a[href=#]" сделаем: -->
    <div>
        <ul">
            <!-- Класс rounded-l-lg сильно (т.к указано lg) округляет левые углы. Также есть: 
            rounded-sm - мало округляет углы;
            shadow-md - средне округляет углы. -->
            <li><a class="rounded-l-lg" href="#">Previous</a></li>
            <li><a href="#"></a></li>
            <li><a href="#"></a></li>
            <li><a href="#"></a></li>
            <li><a href="#"></a></li>
            <li><a href="#"></a></li>
            <li><a href="#"></a></li>
        </ul>
    </div>
    

    <!-- ПРИМЕНЕНИЕ FLEXBOX. https://www.youtube.com/watch?v=mmBIbOfRtOw&list=PLNkWIWHIRwMFN8qKfZ5Lgr29L5BoJKFfa&index=7 -->


    <!-- TailwindCSS представляет большой набор классов для работы с Flexbox. -->
    <!-- С помощью класса flex, делаем элемент flex-container`ом и выравниваем все элементы горизонтально по центру, с помощью justify-center.
    Можно указать также и justify-start, и justify-end и тд. -->
    <ul class="flex justify-center"></ul>
    <!-- Класс flex-col - это аналог flex-direction: column во Flexbox. -->
    <ul class="flex flex-col"></ul>
    <!-- Класс items-center - это аналог align-items: center во Flexbox. -->
    <ul class="flex items-center"></ul>
    <!-- Класс justify-between - это аналог justify-content: space-between во Flexbox. -->
    <ul class="flex justify-between"></ul>
    <!-- Класс inline-flex - это аналог display: inline-flex во Flexbox.
    Делает так, чтобы элемент становился flex-container, но подстраивался под размер элементов внутри себя. -->
    <ul class="inline-flex"></ul>
    <!-- С помощью конструкции "a>div>div>h3+p" можно создать следующий код: -->
    <a href="">
        <div>
            <div>
                <h3></h3>
                <p></p>
            </div>
        </div>
    </a>
    <!-- С помощью класса block можно превратить элемент в блочный элемент. -->
    <a class="block" href="">
            

    <!-- ДИРЕКТИВЫ. https://www.youtube.com/watch?v=GJyXpidSlCU&list=PLNkWIWHIRwMFN8qKfZ5Lgr29L5BoJKFfa&index=8 -->


    <!-- Если произошла ситуация, что в коде много элементов с одинаковым полотном классов, 
    то в файле main.css можно создать класс, который будет включать в себя директиву @apply и после неё нужно указать все те классы, которые нужно заменить одним. Пример: -->
    <!-- .header-link {
        @apply text-gray-500 font-semibold inline-block py-3 px-2 border-b-2 border-transparent hover:text-violet-800 hover:border-violet-800;
    } -->
    <!-- Класс header-link, в примере выше, будет включать в себя те же свойства, что и все перечисленные классы после @apply. 
    Директива @apply можно сказать "вытягивает" все свойства перечисленных классов. -->

    <!-- Если использовать подобный класс, но на самом элементе ещё будут определены дополнительные конкурирующие свойства 
    (например, цвет текста определён в html-разметке, но в классе с @apply определён другой цвет текста), то
    применяться свойства из класса с @apply (т.е примениться цвет текста из класса с @apply, а не тот, который определён в html-разметке). -->
    <!-- Для того, чтобы понизить специфичность стилей и их можно было переопределить в html-разметке используется директива @layer в файле main.css.
    Так как мы работаем с компонентами (или элементами интерфейса), то после директивы пишем components. Пример: -->
    <!-- @layer components {
        .pagination-item {
            @apply inline-block py-1 px-3 border border-gray-300 text-gray-500 hover:bg-gray-100 hover:text-gray-700;
        }
    } -->
    <!-- И так как, класс pagination-item указан в директиве @layer, то его специфичность стала ниже, чем специфичность классов в html-разметке,
    и теперь стили класса pagination-item можно переопределить указав те же стили с другими значениями в html-разметке. -->
    <!-- Создание папки .vscode с файлом settings.json нужно для того, чтобы vscode видел директивы TailwindCSS. -->

            
    <!-- ИКОНКИ. https://www.youtube.com/watch?v=pXawvKcd4zg&list=PLNkWIWHIRwMFN8qKfZ5Lgr29L5BoJKFfa&index=9 -->


    <!-- Изначально в TailwindCSS не поддерживает какие-либо иконки, т.е
    мы не можем добавить какой-то элемент в html-разметку, а потом добавить на него определённый класс, чтобы на странице он отображался, как иконка. -->
    <!-- Для таких целей существует ресурс https://heroicons.com/ c svg иконками, как дополнение к фреймворку. -->
    <!-- Чтобы добавить иконку в разметку, в тегах, где записывается текст, добавляем svg-скрипт,
        который можно получить, набрав на сайте heroicons, в поиске, название иконки, которая нам нужна. -->
    <!-- Следующий пример добавляет иконку домика на страницу: -->
    <a href="#"> 
        <!-- Добавляем иконку домика из Heroicons и задаём ей ширину и высоту.
        Я задаю ширину и высоту с помощью классов h и w (Пример: class="h-5 w-5"). -->
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" class="w-5 h-5">
            <path  stroke-linecap="round" stroke-linejoin="round" d="M2.25 12l8.954-8.955c.44-.439 1.152-.439 1.591 0L21.75 12M4.5 9.75v10.125c0 .621.504 1.125 1.125 1.125H9.75v-4.875c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125V21h4.125c.621 0 1.125-.504 1.125-1.125V9.75M8.25 21h8.25" />
        </svg>          
    </a>
    <!-- Символ ">" в качестве иконки называется "chevron-right", его можно также добавить с помощью svg скрипта. -->
    <span class="mx-2">
        <!-- Параметр fill отвечает за цвет заливки. В примере, у нас будет зелёная иконка. -->
        <!-- Параметр stroke отвечает за цвет обводки. В примере, у нас будет синия обводка иконки. -->
        <!-- Параметр stroke-width отвечает за толщину обводки. В примере, у нас будет обводка размером 5. -->
        <svg xmlns="http://www.w3.org/2000/svg" fill="green" viewBox="0 0 24 24" stroke="blue" stroke-5 class="w-5 h-5">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
        </svg>
    </span>
    <!-- Чтобы элементы шли горизонтально друг за другом, а не вертикально добавляем класс flex. -->
    <ul class="flex"></ul>
    
            
    <!-- СЕТОЧНЫЙ МАКЕТ. https://www.youtube.com/watch?v=NgFumXMTdx8&list=PLNkWIWHIRwMFN8qKfZ5Lgr29L5BoJKFfa&index=10 -->


    <!-- С помощью класса w можно задавать и дробную ширину. 
    Например, если w-1/2 - элемент будет будет занимать половину контейнера (50%), 
    а если w-2/3 - элемент будет занимать 66% контейнера и так далее.
    Если в дизайне учавствуют, например, 4 колонки, то лучше, чтобы класс w принимал значения 1/4, 2/4, 3/4, 4/4.
    TailwindCSS принимает дробные значения вплоть до 12 (1/12, 2/12 и тд). -->
    <a class="w-5/12">Пример</a>
    <!-- Чтобы задать расстояние между колонками или строками grid сетки используется класс space. 
    space-x-{расстояние} задаёт расстояние между колонками, а space-y-{расстояние} задаёт расстояние между строками. -->
    <div class="grid space-x-4 space-y-10"></div>
    <!-- В следующем примере, 1 и 3 элемент будут одинаковыми, а второй будет самым большим. -->
    <section>
        <a class="w-1/5" href="#"></a>
        <a class="w-3/5" href="#"></a>
        <a class="w-1/5" href="#"></a>
    <!-- В следующем примере, 1 и 2 элемент будут одинаковыми, а третий будет самым маленьким. -->
    <section>
        <a class="w-2/5" href="#"></a>
        <a class="w-2/5" href="#"></a>
        <a class="w-1/5" href="#"></a>
    </section>
    <!-- Если нам нужно сделать так, чтобы сайт не растягивался на больших экранах, то нужно использовать класс max-w-screen-xl, который
    ограничивает размеры страницы и поэтому страница не сможет стать больше 1280px.
    А класс mx-auto помогает центрировать лейаут. -->
    <div class="max-w-screen-xl mx-auto"></div>
    <!-- Из конструкции "section>a>div>h2" получается следующее: -->
    <section>
        <a href="">
            <div>
                <h2></h2>
            </div>
        </a>
    </section>

    <!-- Пример создания баннеров, с пояснениями. -->
    <section class="px-2 flex space-x-2">
        <!-- Т.к мы будет позиционировать другой элемент с помощью position: absolute, который работает так, что 
        если у элемента есть родитель, у которого position отличается от static, то элемент позициионируется относительно краёв его родителя.
        Именно поэтому элементу-родителю задаём postion: relative. -->
        <!-- С помощью overflow-hidden обрежем всё, что будет выходить за его пределы. -->
        <a class="w-2/3 bg-violet-300 h-96 mb-4 relative rounded inline-block overflow-hidden" href="#">
            <!-- Задаём элементу position: absolute, а дальше bottom-0 left-0, что переносит наш элемент в нижний левый угол относительно родителя. -->
            <!-- На всякий случай, добавим z-20 (z-index: 20), чтобы элемент перекрывал другие элементы. -->
            <div class="p-4 absolute bottom-0 left-0 z-20">
                <!-- leading-tight немного увеличивает величину пространства между строками, например в тексте. -->
                <h2 class="text-4xl font-semibold text-gray-100 leading-tight">
                    Lorem ipsum dolor sit amet consectetur.
                </h2>
            </div>
        </a>
        <a class="w-1/3 bg-indigo-300 h-96 mb-4 relative rounded inline-block overflow-hidden" href="#">
            <!-- Задаём элементу position: absolute, а дальше bottom-0 left-0, что переносит наш элемент в нижний левый угол относительно родителя. -->
            <!-- На всякий случай, добавим z-20 (z-index: 20), чтобы элемент перекрывал другие элементы. -->
            <div class="p-4 absolute bottom-0 left-0 z-20">
                <!-- leading-tight немного увеличивает величину пространства между строками, например в тексте. -->
                <h2 class="text-4xl font-semibold text-gray-100 leading-tight">
                    Lorem ipsum dolor sit amet, consectetur adipisicing elit.
                </h2>
            </div>
        </a>
    </section>

            
    <!-- ГРАДИЕНТЫ. https://www.youtube.com/watch?v=uCdfvPLtAJs&list=PLNkWIWHIRwMFN8qKfZ5Lgr29L5BoJKFfa&index=11 -->


    <!-- Чтобы элементу применился градиент используется класс bg-gradient. 
    После чего указывается суффикс to и указывается направление из t (верх), r (право), b (низ) и l (лево).
    Например, класс bg-gradient-to-r указывает, что градент будет указан слева направо, а
    bg-gradient-to-t означает, что градиент будет указан снизу вверх. 
    Дальше нужно задать минимум 2 цвета, которые определяются с помощью приставок from (с какого цвета градиент начинается) и to (каким цветом градиент заканчивается). -->
    <a class="bg-gradient-to-l from-red-500 to-blue-500" href="#">
    <!-- Также, градиенты хорошо работают с состояниями, например с hover. -->
    <a class="bg-gradient-to-l from-red-500 to-blue-500 hover:to-green-500" href="#">
    <!-- Чтобы градиент шёл в какой либо угол, после bg-gradient-to указывается один из углов: tl, tr, bl, br. 
    В следующем примере градиент будет направлен в верхний правый угол. -->
    <a class="bg-gradient-to-tr from-red-500 to-blue-500" href="#">
    <!-- Если нужно указать промежуточный цвет градиента указывается приставка via.
    И по итогу, заключительный набор приставок такой:
    from - с какого цвета начинаем;
    via - через какой цвет идём;
    to -  каким цветом завершаем. -->
    <a class="bg-gradient-to-tr from-red-500 via-purple-500 to-blue-500" href="#">
    <!-- Чтобы добавить прозрачность для какого либа цвета в градиенте, 
    нужно, когда указал цвет поставить дробную черту и указать прозрачность в целых числах. 
    Данное значение варьируется от 0 (полная прозрачность) до 100 (полная непрозрачность). -->
    <a class="bg-gradient-to-tr from-red-500 via-purple-500/50 to-blue-500" href="#">
    <!-- Использовав конструкцию "div>h5+ul>li>a[href=#]>span+span" получим следующее: -->
    <div>
        <h5></h5>
        <ul>
            <li><a href="#"><span></span><span></span></a></li>
        </ul>
    </div>

    <!-- Создание блока "самым популярных новостей" справа на странице. -->
    <div class="mb-5">
        <!-- Добавляем заголовок. -->
        <h5 class="font-bold text-lg uppercase text-gray-700 mb-2">
            Popular News
        </h5>
        <ul>
            <!-- Каждый элемент списка будет одной "популярной новостью". -->
            <!-- Первая популярная новость. -->
            <li class="px-1 py-4 border-y border-white hover:border-gray-200">
                <!-- Создаём из элемента ссылки flex-container и центрируем элементы по вертикали. -->
                <a class="flex items-center text-gray-600" href="#">
                    <!-- Это квадратик, который идёт вначале текста, с градиентом логотипа фреймворка (в нашем случае - это Vue с зелёным логотипом). -->
                    <span class="inline-block w-4 h-4 mr-3 bg-gradient-to-tr from-green-500 to-green-700"></span>
                    <!-- Сам текст "популярной новости". -->
                    Vue
                    <!-- С помощью ml-auto прибьём к правому краю flex-container`а текст с числом статей. -->
                    <span class="text-gray-500 ml-auto">23 articles</span>
                </a>
            </li>
            <!-- Вторая популярная новость. Всё тоже самое, что и у первой новости, только изменяется цвет градиента квадратика и текст. -->
            <li class="px-1 py-4 border-y border-white hover:border-gray-200">
                <a class="flex items-center text-gray-600" href="#">
                    <span class="inline-block w-4 h-4 mr-3 bg-gradient-to-tr from-orange-500 to-orange-700"></span>
                    Svelte
                    <span class="text-gray-500 ml-auto">20 articles</span>
                </a>
            </li>
    
            
    <!-- ОТЗЫВЧИВЫЙ МАКЕТ. https://www.youtube.com/watch?v=C1uDlLylTyc&list=PLNkWIWHIRwMFN8qKfZ5Lgr29L5BoJKFfa&index=12 -->


    <!-- В TailwindCSS есть набор модификаторов классов, которые определяют какая у пользователя ширина экрана:
    sm - у пользователя экран размером 640px;
    md - у пользователя экран размером 768px (планшеты);
    lg - у пользователя экран размером 1024px (ноутбуки);
    xl - у пользователя экран размером 1280px;
    2xl - у пользователя экран размером 1536px.
    После модификатора ставиться двоеточние и после него - классы, которое нужно обновить. -->
    <nav class="hidden md:flex items-center"></nav>

    <!-- Когда все ссылки в header слипаются из-за маленького разрешения, 
    то используют иконку гамбургер навигации (все ссылки заменяют на иконку, при клике на которую, все ссылки станут снова видимыми). -->
    <!-- При работе с TailwindCSS ВАЖНО ПОМНИТЬ: перестройка макета происходит от телефона к компьютеру, т.е 
    если нам нужно скрыть какой то элемент на телефоне, но она будет видна на компьютерах, то
    к самому элементу добавляем класс hidden, а уже через модификатор md делаем так, чтобы элемент был виден на компьютерах. 
    Вообщем, модификаторы нужно подстраивать под компьютеры, а не под телефоны. -->
    <!-- Например, на телефоне кнопка меню будет строчно-блочной, а на компьютерах её будет не видно из-за класса hidden. -->
    <button class="inline-block md:hidden"></button>
    <!-- Делаем lg:flex, чтобы на разрешении lg, макет был двухколоночным, а по дефолту, на мобильных - одноколоночный.
    Также делаем lg:space-x-2, чтобы не было расстояния между элементами. -->
    <section class="px-2 lg:flex lg:space-x-2">
    <!-- На телефонах, элемент будет шириной во весь экран, а на мониторах с разрешением lg(1024px) будет занимать 2/3 экрана. -->
    <a class="w-full lg:w-2/3" href="#">
    <!-- Когда мы превращаем элемент во flex-container только на определённом разрешении, 
    то на телефонах, элементы будут идти сверху вниз. -->
    <div class="md:flex"></div>

    <!-- Точно также, можно менять не только глобальные блоки, но и отдельные элементы, меняя их стили. -->

    <!-- На разрешении md, скрываем разделитель, а на разрешении lg снова показываем с помощью block. -->
    <div class="border border-dotted md:hidden lg:block"></div>
    
    <!-- Иногда, если нужно чтобы элементы были на разных строках, то нужно задать им w-full. -->
        
            
    <!-- КАРТИНКИ. https://www.youtube.com/watch?v=eQkfcnhPLT8&list=PLNkWIWHIRwMFN8qKfZ5Lgr29L5BoJKFfa&index=13 -->


    <!-- Чтобы добавить картинки на страницу, нужно в папку public добавить папку images со всеми картинками. -->
    <!-- Чтобы добавить изображение на страницу используется стандартный тег img. -->
    <!-- В атрибут alt нужно передавать текст, который будет отображаться, если картинка не прогрузиться, а в src путь до картинки.
    Класс object-cover заставляет ширину и высоту изображения соответствовать высоте и ширине элемента.
    Также, задаём абсолютное позиционирование в левый верхний угол и растягиваем картинку максимально по высоте и ширине. 
    И задаём z-0, чтобы если был текст, то картинка была под ним. -->
    <img class="absolute left-0 top-0 w-full h-full z-0 object-cover" src="public/images/img-1.jpg" alt="news">
    <!-- Добавляем "затемнение" на всю картинку, чтобы текст читался лучше.
    Располагается оно точно там же где и картинка, но имеет z-10, а значит она находиться над картинкой.
    Задаём градиент и получается "затемнение" для картинки. -->
    <div class="absolute left-0 top-0 w-full h-full z-10 bg-gradient-to-b from-black/10 to-black/70"></div>
    <!-- Картинка с фиксированной высотой и шириной и непрозрачностью 80. -->
    <img class="w-48 h-48 opacity-80 object-cover mr-4" src="public/images/img-3.jpg" alt="img">
    <!-- Чтобы картинка с текстом хорошо выглядели на телефонах, делаем для телефонов элемент блочным и во всю ширину экрана. -->
    <img class="block w-full lg:flex mb-10" href="#">
    <!-- На телефонах картинка будет во всю ширину экрана, а на разрешении lg будет фиксированная ширина 48. -->
    <img class="w-full lg:w-48" src="public/images/img-3.jpg" alt="img">

    <!-- Если мне кажется, что у элемента есть какое то ненужное пространство, то нужно проверить его margin и padding. -->
            
    <!-- Если нужна фотка случайного человека, то можно воспользоваться сайтом https://randomuser.me/. -->
    <!-- Класс rounded-full можно применять и к картинкам. -->
    <img class="h-10 w-10 mr-2 rounded-full object-cover" src="https://randomuser.me/api/portraits/men/90.jpg" alt="author"></img>

            
    <!-- ПЛАВНЫЕ ПЕРЕХОДЫ. https://www.youtube.com/watch?v=w0DOvTtZ3_c&list=PLNkWIWHIRwMFN8qKfZ5Lgr29L5BoJKFfa&index=14 -->


    <!-- Основным классом, который добавляет плавный переход является transition. 
    У него может быть какое-то определённое значение по типу: color, shadow, opacity и тд. 
    И это значит, что переход будет применяться именно для указанного свойства. -->
    <li><button class="transition-color">Login</button></li>
    <!-- А можно использовать transition-all, чтобы плавный переход применялся ко всем свойствам. -->
    <li><button class="transition-all ">Login</button></li>
    <!-- Класс duration определяет сколько милисекунд будет длиться переход. -->
    <li><button class="transition-all duration-1000">Login</button></li>
    <!-- Класс ease нужен, чтобы более точно установить анимацию перехода.
    Может быть: 
    ease-in - начало перехода медленное, к концу идёт ускорение.
    ease-out - начало перехода быстрое, к концу идёт замедление.
    ease-in-out - начало и конец перехода медленные.
    ease-linear - скорость перехода одинаковая во всех частях -->
    <li><button class="transition-all duration-1000 ease-linear">Login</button></li>
    <!-- Класс delay нужен для того, чтобы плавный переход выполнился через какое-то время в милисекундах. -->
    <li><button class="transition-all duration-1000 ease-linear delay-1000">Login</button></li>
    <!-- Использование "transition-all duration-300" чаще всего самое оптимальное.
    А найти элементы с переходом, можно введя в поиск "hover". -->
    <!-- Конструкция "div>img>div>p+time" сделает следующее: -->
    <div>
        <img src="" alt="">
            <div>
                <p></p>
                <time></time>
            </div>
        </img>
    </div>
    <!-- Классы можно также применять к тексту даты и времени. -->
    <time class="text-gray-400 text-xs">14 March</time>
    
    
    <!-- ТЁМНАЯ ТЕМА. https://www.youtube.com/watch?v=_hy4L-__NOQ&list=PLNkWIWHIRwMFN8qKfZ5Lgr29L5BoJKFfa&index=15 -->


    <!-- Тёмная тема добавляется в файле tailwind.config.js. 
    Там, добавляется свойство darkMode со значением "class", но данный флаг нужен чисто для разработки, когда сайт будет сделан, этот флаг можно убрать. -->
    <!-- Дальше в тег html записываем class="dark". -->
    <html lang="en" class="dark"></html>
    <!-- Чтобы задать элементу тёмную тему, нужно добавить модификатор dark и свойство, которое будет при тёмной теме. -->
    <body class="bg-white dark:bg-slate-900">
    <!-- И теперь, когда пользователь в своём браузере включить тёмную тему, то и наш сайт тоже станет "темнее". -->

    <!-- Директива @apply не принимает тёмный режим, поэтому мы не можем указать тёмный режим для класса header-link, поэтому
    надо делать это здесь, в html-разметке. -->
    <li><a class="header-link dark:text-slate-200 " href="#">Home</a></li>
    <!-- Чтобы использовать состояния при тёмном режиме, нужно сначала написать dark, потом состояние, а потом стили. -->
    <li><a class="dark:hover:border-purple-500" href="#">Home</a></li>
    <!-- Когда в светлой теме, при наведении на элемент появляется обводка, то иногда в тёмной теме эта обводка будет всегда на элементе.
    Поэтому мы обесцвечиваем обводку для тёмной темы, и для тёмной темы при наведении делаем свою обводку. -->
    <li class="dark:border-transparent dark:hover:border-gray-200">

        
    <!-- ПОЛЬЗОВАТЕЛЬСКИЕ НАСТРОЙКИ. https://www.youtube.com/watch?v=vtWafRDajD0&list=PLNkWIWHIRwMFN8qKfZ5Lgr29L5BoJKFfa&index=16 -->


    <!-- Если например, нужно прибить footer к низу, то нужно использовать класс h-screen, который делает высоту элемента высоте видимой области страницы. 
    Потом, мы делаем из элемента grid-container и дальше должно идти свойство grid-template-rows: auto 1fr auto,
    которое сделает так, чтобы header и footer был размером auto (т.е строки подстроються под контент),
    а основной контент будет размером 1fr, т.е займёт большую высоту экрана. И таким образом, footer будет прибит к низу. -->
    <div class="max-w-screen-xl mx-auto h-screen grid"></div>
    <!-- Но свойство grid-template-columns слишком специфичное, поэтому для него нет никаких классов.
    Но в новой версии TailwindCSS, у нас появилась возможность добавлять несуществующие в TailwindCSS классы с помощью квадратных скобок. -->
    <!-- Прямо в класах, мы указываем grid-rows, а далее ставим тире и квадратные скобки. 
    В квадратных скобках, разделяя значения нижним подчёркиванием добавляем наши значения (auto, 1fr, auto). -->
    <div class="max-w-screen-xl mx-auto h-screen grid grid-rows-[auto_1fr_auto]"></div>
    <!-- То есть, если нужного класса нету, то необходимые значения должны быть указаны в квадратных скобках. -->

    <!-- Но также, можно в файле tailwind.config.js, создать новый класс, который можно будет применять в проекте.
    Внутри блока extend нужно добавить значение, которое отвечает за соответствующий класс. В нашем случае, это GridTemplateRows.
    В фигурных скобках, нужно указать имя суффикса, который будет идти вместо значений в квадратных скобках. В нашем случае, это будет layout.
    И layout`у добавляем значения, которые нам нужны, в нашем случае, это те же самые 'auto 1fr auto'. 
    И теперь файл tailwind.config.js выглядит так: -->
    <!-- 
    module.exports = {
        content: ["./index.html"],
        theme: {
            extend: {
                gridTemplateRows: {
                    'layout': 'auto 1fr auto',
                },
            },
        },
        plugins: [],
    }
    -->
    <!-- Ну а вместо наших прошлых значений в квадратных скобках, мы можем указать просто суффикс layout. -->
    <div class="max-w-screen-xl mx-auto h-screen grid grid-rows-layout"></div>
    <!-- Точно также, можно сделать и для других несуществующих классов - просто добавить их в конфиг. -->
    <!-- Если нам нужен, какой-либо специфичный цвет, которого нет в палитре, то нужно указать глобальное свойство colors. Файл tailwind.config.js:
    module.exports = {
        content: ["./index.html"],
        theme: {
            extend: {
                colors: {
                    'logo-main': '#9b0404',
                }
            },
        },
        plugins: [],
    } -->
    <!-- И мы также, можем по суффиксу указать цвет текста. -->
    <a class="text-logo-main" href="">webDev</a>
    <!-- Если нам нужно добавить свой новый шрифт, то делаем анологичные действия. 
    Ищём нужный нам шрифт в GoogleFonts и выбираем все варианты начертания для покрытия всех кейсов.
    Нажимаем кнопку @import и копируем предложенный CSS код, который идёт в тегах <style>.
    И данный код вставляем в main.css, в самое начало. -->
    <!-- Шрифт мы импортировали и теперь его нужно применить в tailwind.config.js. Для шрифтов есть свойство fontFamily.
    Внутри определяем суффикс 'main', а его значением, в квадратных скобках, указываем название шрифта, как тут: -->
    <!--
        module.exports = {
            content: ["./index.html"],
            theme: {
                extend: {
                    fontFamily: {
                        'main': ['Montserrat'],
                    },
                },
            },
            plugins: [],
        }
    -->
    <!-- И указываем наш класс для всего элемента body, чтобы всем элементам применился данный шрифт. -->
    <body class="font-main"></body>

    <!-- Информацию о том, как добавить то или иное свойство или переопределить существующее, можно найти на сайте https://v2.tailwindcss.ru/docs/. -->
    <!-- Но чтобы не запоминать все свойства, то можно создать специальный конфигурационный файл, в котором будут написаны все свойства. 
    Чтобы всё сработало, нужно прошлый файл конфигурации переименовать во что то другое, например, tailwind.config2.js.
    После, в терминал нужно написать команду "npx tailwindcss init --full" для создания нового конфигурационного файла. 
    И теперь у нас создался новый файл tailwind.config.js, 
    в котором есть информация о всех свойствах, структурах и классах, и в случае необходимости, это всё можно переопределить.
    Также, удобнее будет использовать его, как справочник, о том, как правильно добавить какое-либо свойство.
    Для удобства, я переименовал его в guide.js, а прошлому файлу вернул имя tailwind.config.js. -->
</body>
</html>