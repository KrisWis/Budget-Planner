

/* ОСНОВНЫЕ ПОНЯТИЯ. https://www.youtube.com/watch?v=9MxBkY2_WNA&list=PLNkWIWHIRwMG0EUBS8rvTRVNL9IcxcawW&index=3 */


/* В flexbox есть 2 оси - основная и поперечная.
Основная ось - горизонтальная и вдоль неё располагаются элементы flex-container. ПО УМОЛЧАНИЮ, она идёт слева направо.
Поперечная ось - вертикальная, нужна для выравнивания элементов друг относительно друга по вертикали. ПО УМОЛЧАНИЮ, она идёт сверху вниз. */
/* Т.е Flexbox - это блок, элементы которого, располагаются по горизонтали и вертикали. */

body {
    /* flex-container это элемент со свойством display со значением flex или inline-flex.
    Это основной родительский блок, внутри которого размещаются элементы (flex-items).
    По умолчанию, они располагаются слева направо и сверху вниз. 
    Их ШИРИНА зависит от размера их контента внутри.
    А их ВЫСОТА подстраивается под высоту flex-container (растягиваются на всю длину поперечной оси). */
    display: flex;
    /* Если у свойства display будет значение inline-flex, то flex-container подстроиться под размер контента внутри себя. */
    display: inline-flex
}


/* НАПРАВЛЕНИЯ ОСЕЙ. https://www.youtube.com/watch?v=OQ6GyMD5E-s&list=PLNkWIWHIRwMG0EUBS8rvTRVNL9IcxcawW&index=3 */


.flex-container {
  display: flex;
  /* Свойство flex-direction отвечает за то, как будет располагаться основная ось (определяется для flex-container). Принимает значения: 
  row - дефолтное значение, элементы идут слево направо;
  row-reverse - основная ось поворачивается и теперь элементы идут справа налево;
  column - основная ось располагается вертикально вверх, а поперечная горизонтально налево, поэтому теперь элементы идут сверху вниз.
  column-reverse - основная ось располагается вертикально вниз, а поперечная горизонтально налево, поэтому теперь элементы идут снизу вверх.*/
  flex-direction: row;
  /* Делаем блок на всю высоту экрана. */
  min-height: 100vh;
}

.flex-item {
  /* flex: 1 убирает пустое пространство во flex-container. */
  flex: 1;
}

/* Для мобильных устройств делаем направление основной оси вертикально вверх, чтобы элементы располагались сверху вниз. */
@media screen and (max-width: 650px) {
  .flex-container {
    flex-direction: column;
  }
}


/* ПЕРЕНОС ЭЛЕМЕНТОВ И ОТСТУПЫ. https://www.youtube.com/watch?v=zvkE0MY1cxE&list=PLNkWIWHIRwMG0EUBS8rvTRVNL9IcxcawW&index=4 */


/* По умолчанию, flex-items внутри flex-container не переносяться на новый ряд. Они занимают всю ширину только одной строки.
Если сделать элементам внутри flex-container ширину, например, 200px, то их ширина не будет равна 200px, они просто займут всю ширину строки, если она меньше 200px. */
.flex-container {
  display: flex;
  /* Есть свойство flex-wrap, которое применяется для flex-container, оно нужно для переноса элементов на новый ряд. Принимает значения:
  nowrap - не разрешает перенос на новые строки;
  wrap - если элементам не хватает места, то они будут переноситься на новые строки. И все элементы будут иметь ширину, которую им задали;
  wrap-reverse - разрешает элементам переноситься на новые строки, но они переносяться слева направо, но снизу вверх. Поперечная ось была развернута на 180 градусов. */
  flex-wrap: wrap;
  /* Если мы растянем flex-container на всю ширину экрана, то элементы займут всю доступную им высоту. */
  height: 100vh;
  /* Если поменять основную ось и поперечную, то элементы будут идти сверху вниз и если не поместяться в колонку, 
  то перенесуться на новую колонку, если есть свойство flex-wrap. 
  Но если его нет, то все элементы отобразяться в одной колонке и выйдут за пределы flex-container, если задана чёткая высота.
  Если же чёткая высота не задана, то элементы просто растянут flex-container.  */
  flex-direction: column; 
  /* В свойстве flex-flow сочетаются значения свойств flex-direction и flex-wrap. */
  flex-flow: column wrap; 
  /* Чтобы выровнять наш лейаут, то можно поставить padding, который создаёт пространство между контентом и границей контейнера. */
  padding: 5px; 
  /* Свойство gap, которое применяется для flex-container, нужно для того, чтобы создавать отступы между элементами flex-container. */
  gap: 15px
}

.flex-item {
  /* Чтобы не было пустого пространства в правой части контейнера, нужно указывать ширину не в точных величинах (px например), а в процентах, например. 
  Когда мы указываем ширину в процентах, то она высчитывается в зависимости от ширины экрана.
  (если 50%, то в одной строке будет 2 элемента (100 / 50 = 2), если 33% то 3 (100 / 33.33 = 3). */
  width: 33.33%;
  /* Если добавить ко всем элементам margin, то они будут уже рассчитаны на 2 колонки, а не на 3, т.к он увеличивает элемент.
  Также, margin суммируется у элементов, а не схлопывается как в обычном css. */
  margin: 5px; 
  /* Но если отнять у width 10 пикселей (справа и слева от элемента), то мы сможем вернуть 3 колонку. */
  width: calc(33.33% - 10px)
}


/* ВЫРАВНИВАНИЕ ВДОЛЬ ГЛАВНОЙ ОСИ. https://www.youtube.com/watch?v=FKDfECxwC54&list=PLNkWIWHIRwMG0EUBS8rvTRVNL9IcxcawW&index=5 */


/* Напоминание: по высоте элемент подстраивается под контент. Также, если не задавать фиксированную высоту/ширину, то элемент растянется по всей поперечной оси. */
.flex-container {
  display: flex;
  height: 100vh;
  /* Свойство justify-content нужно для выравнивания элементов вдоль основной оси, но оно не работает, если flex-direction равен column и высота flex-container не задана.
  Принимает значения: 
  flex-start - элементы располагаются как обычно, слева направо горизонтально; 
  flex-end - элементы располагаются справа налево (но последний элемент всё равно будет в самом конце, т.е это не равно reverse) горизонтально;
  center - все элементы располагаются в центре основной оси;
  space-between - первый и последний элемент располагаются в начале и в конце flex-container. 
  А элементы между ними равномерно распределены с одинаковым пространством между друг другом;
  space-around - все элементы располагаются с одинаковым расстоянием между друг другом 
  (но расстояние у первого/последнего элемента между стенками flex-container будет меньше, 
  чем расстояние между друг другом других элементов, т.к расстояние между ними суммируется);
  space-evenly - теперь вообще все элементы располагаются с одинаковым расстоянием по всему flex-container. */
  justify-content: space-evenly;
}


/* ВЫРАВНИВАНИЕ ВДОЛЬ ПОПЕРЕЧНОЙ ОСИ. https://www.youtube.com/watch?v=_9idibPDs1s&list=PLNkWIWHIRwMG0EUBS8rvTRVNL9IcxcawW&index=6 */


.flex-container {
  display: flex;
  /* ОБЯЗАТЕЛЬНО нужно указать высоту flex-container, если собираюсь использовать align-items. */
  height: 100vh;
  /* Свойство align-items нужно для выравнивания элементов вдоль поперечной оси. Принимает значения: 
  strech - дефолтное значение. Растягивает элементы вдоль поперечной оси;
  flex-start -  элементы переместяться вверх flex-container, т.к там находиться начало поперечной оси;
  flex-end - элементы переместяться вниз flex-container, т.к там находиться конец поперечной оси;
  center - элементы перестяться в середину поперечной оси;
  baseline - работает только если элементы имеют разную высоту (устанавливать нужно с помощью font-size). 
  baseline выравнивает их по базовой линии, которая будет проходить где-то посередине всех элементов.
  Если значение свойства flex-direction равно column, то baseline будет отрабатывать, как flex-start. */
  align-items: flex-start;
  /* Если задать свойству flex-direction значение column, то элементы будут располагаться вертикально слева. */
  flex-direction: column; 
  justify-content: center;
  align-items: center;
}

.flex-item {
  /* Если указать width у всех элементов, но указать font-size у определённых, то font-size будет влиять только на высоту элемента. */
  width: 100px; 
}


/* МНОГОСТРОЧНОЕ ВЫРАВНИВАНИЕ. https://www.youtube.com/watch?v=sDkL7o0LXF0&list=PLNkWIWHIRwMG0EUBS8rvTRVNL9IcxcawW&index=7 */


.flex-container {
  display: flex;
  /* Если не будет указана высота, то контейнер подстроиться под контент и элементы по вертикали будут идти плотно друг к другу. */
  height: 100vh;
  flex-wrap: wrap;
  flex-direction: column;
  /* Свойство align-content предназначено для выравнивания многострочного контента (когда элементы на нескольких строках). 
  Это свойство располагает элементы анологично justify-content, за исключением значения space-evenly. Только, это распределение идёт именно вдоль поперечной оси.
  Оно срабатывает только если в flex-container есть дополнительное свойство flex-wrap со значением wrap. 
  Принимает значения: 
  strech - дефолтное значение. Растягивает многострочный контент по поперечной оси. Не работает, если указана ширина элементов и есть свойство flex-direction: column;
  flex-start - выравнивает многострочный контент к началу поперечной оси (вверху). ;
  flex-end - выравнивает многострочный контент к концу поперечной оси (внизу);
  center - все элементы выравниваются в центре по поперечной оси;
  space-between - добавляет одинаковое расстояние между строчками с элементами. 
  Первая строчка элементов находиться в начале поперечной оси, а последняя в конце поперечной оси;
  space-around - добавляет одинаковое расстояние между строчками с элементами, а также между первыми/последними элементами и границами flex-container. */
  align-content: stretch;
}


/* ИНДИВИДУАЛЬНОЕ ВЫРАВНИВАНИЕ ЭЛЕМЕНТОВ. https://www.youtube.com/watch?v=WeFMfoK9R2o&list=PLNkWIWHIRwMG0EUBS8rvTRVNL9IcxcawW&index=8 */


.flex-container {
  display: flex;
  /* Все выравнивания по поперечной оси видно, только если указана высота. */
  height: 100vh;
  flex-wrap: wrap;
}

.flex-item {
  width: 300px;
}

/* Свойство aling-self применяется для выравнивания определённых элементов в flex-container ПО ПОПЕРЕЧНОЙ ОСИ. */
.item-1 {
  /* strech - дефолтное значение, растягивает элемент по поперечной оси. 
  При flex-wrap: wrap элемент располагается сверху и равен установленной ширине. */
  align-self: stretch;
}

.item-2 {
  /* flex-start - элемент расположиться в начале поперечной оси и высотой подстроиться под контент.
  При flex-wrap: wrap элемент располагается в начале поперечной оси или в начале своей строки элементов и равен размеру контента. */
  align-self: flex-start;
}

.item-3 {
  /* center - элемент расположиться в центре поперечной оси и высотой подстроиться под контент.
  При flex-wrap: wrap элемент располажиться в центре поперечной оси и будет равен размеру контента. */
  align-self: center;
}

.item-4 {
  /* flex-end - элемент расположиться в конце поперечной оси и высотой подстроиться под контент.
  При flex-wrap: wrap элемент располажиться в конце поперечной оси или вплотную к следующей строке элементов, если такая есть, и будет равен размеру контента. */
  align-self: flex-end;
}

.item-5 {
  /* baseline - это свойство работает только если, свойство flex-direction не равно column и
  ещё у какого то элемента есть свойство align-self со значением baseline, в ином случае работает, как flex-start. */
  align-self: baseline;
}

.item-6 {
  /* Теперь мы установили свойство align-self: baseline для ещё одного элемента 
  и эти 2 элемента выравнились по базовой линии (чтобы они были на примерно одинаковой высоте). */
  /* Работает также и при flex-wrap: wrap. */
  align-self: baseline;
  /* Свойство от baseline видно, только если один из элементов больше или меньше другого/других. */
  font-size: 100px;
}


/* РАЗМЕРЫ ЭЛЕМЕНТОВ. https://www.youtube.com/watch?v=rDdUWDaJzQ8&list=PLNkWIWHIRwMG0EUBS8rvTRVNL9IcxcawW&index=9 */


.flex-container {
  display: flex;
}

.flex-item {
  /* Свойство flex-grow увелечивает элемент таким образом, чтобы пространство распределялось по пропорции, т.е: 
  если у первого элемента flex-grow: 1, у второго flex-grow: 2, а у третьего flex-grow: 3,
  То, 3 элемент будет занимать в 3 раза больше свободного места, чем первый, который будет самым маленьким.
  А если у всех элементов определить свойство flex-grow: 1, то они займут одинакового свободного пространства во flex-container. 
  Если вкратце, то чем больше цифра в свойстве flex-grow, то тем больше элемент занимает свободного пространства во flex-container. */
  /* Также, у многострочных элементов свободное пространство распределяется именно по строке, в которой они находятся. 
  И изменения элементов происходят именно в этой строке, на другие строки они не влияют. */
  flex-grow: 1; 
}

.item-2 {
  /* Свойство flex-shrink определяет то, сколько элемент готов отдать свободного пространства другим элементам (если у них указана ширина), т.е
  Если у первого элемента flex-shrink: 1 (дефолт), у второго flex-shrink: 2, а у третьего flex-shrink: 3, то
  ПРИ УМЕНЬШЕНИИ ЭКРАНА, третий элемент отдаст своё свободное пространство первому и второму элементу и станет самым маленьким;
  второй элемент отдаст своё свободное пространство первому элементу и станет меньше него;
  а первый элемент станет самым большим, т.к ему все другие элементы отдали свободное пространство.
  Если flex-shrink: 0, то элемент не будет отдавать свою ширину другим элементам. */
  flex-shrink: 2;
}

.item-3 {
  /* Свойство flex-basis определяет размер элемента в зависимости от того, как расположена основная ось - 
  если горизонтально - то ширину, если вертикально - то высоту. */
  flex-basis: 300px;
  /* Свойство flex объединяет в себе свойства flex-grow, flex-shrink и flex-basis, которые перечисляются через пробел. */
  flex: 1 0 300px;
}


/* ОПРЕДЕЛЕНИЕ ПОРЯДКА ЭЛЕМЕНТОВ. https://www.youtube.com/watch?v=o_ozA-YMttU&list=PLNkWIWHIRwMG0EUBS8rvTRVNL9IcxcawW&index=10 */


.flex-container {
  display: flex;
  height: 100vh;
}

.flex-item {
  /* Делаем элементам увеличение, чтобы они одинаково распространялись по всему flex-container. */
  flex: 1;
}

/* По умолчанию, все элементы имеют свойство order, которое равно 0. */
.item-1 {
  /* Можно изменить позицию элемента в контейнере с помощью свойства order. 
  Данная система устроена так, что сначала идут элементы с наименьшим значением order, а потом по нарастающей.
  Поэтому первый элемент будет идти в самом конце (т.к индексы всех остальных элементов равны 0). */
  order: 1;
}

/* Если ширина окна будет меньше 650px... */
@media screen and (max-width: 650px) {
  /* То трёхколоночный макет должен идти в одну колонку. */
  .flex-container {
    flex-direction: column;
  }

  /* И второй элемент будет стоять в самом начале. */
  .item-2 {
    order: -1;
  }
}

.item-7 {
  /* Свойство order может принимать отрицательные значения.
  Теперь 7 элемент стоит в самом начале, т.к -1 меньше 0, который стоит по умолчанию у всех элементов. */
  order: -1;
}

/* Если свойства order у элементов равны, то они идут так, как идут в HTML-документе. */
.item-4 {
  order: 2;
}
.item-5 {
  order: 2;
} 


/* ВЛОЖЕННОСТЬ. ОБЁРТКА ЭЛЕМЕНТОВ С РАЗМЕРАМИ. https://www.youtube.com/watch?v=ar1F5IwBeSc&list=PLNkWIWHIRwMG0EUBS8rvTRVNL9IcxcawW&index=11 */


/* Создаём flex-container и задаём ему свойства. */
.flex-container {
  display: flex;
  flex-wrap: wrap;
  flex-direction: column;
  height: 100vh;
}

/* Чтобы превратить flex-item во flex-container нужно элементу просто добавить свойство display со значением flex. */
.flex-item-2 {
  display: flex;
}

/* Напоминание: если во flex-container не разрешён перенос элементов, 
то установленный для них размер будет игнорироваться (на маленьких экранах) и они будут идти в одну линию. */
.flex-item {
  /* Если элемент со свойством flex-basis будет во flex-container со свойством flex-direction: column, 
  то ширина растянется по поперечной оси (по дефолту), а flex-basis будет влиять уже на высоту, а не на ширину. */
  /* Лучше всего, при задании размеров использовать именно flex-basis. */
  flex-basis: 100px;
  /* flex-grow: 1 убирает пустое пространство справа во flex-container, увеличивая элементы. */
  flex-grow: 1;
}

.item-3 {
  /* При flex-direction: column, элемент становиться больше по высоте, а не по ширине. */
  flex-grow: 5;
}


/* ПРАКТИЧЕСКИЕ ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ FLEXBOX. https://www.youtube.com/watch?v=GGiHxIOmPaE&list=PLNkWIWHIRwMG0EUBS8rvTRVNL9IcxcawW&index=12 */


/* ТРЁХКОЛОНОЧНЫЙ ЛЕЙАУТ. */
.flex-container {
  /* Создаём flex-container. */
  display: flex;
  /* Меняем направление главной оси для колонок и задаём высоту, равную высоте экрана. */
  flex-direction: column;
  min-height: 100vh;
}

/* Блок main тоже делаем flex-container. */
main {
  display: flex;
  /* И разрешаем ему забирать свободное пространство других элементов. */
  flex: 1
}

/* Если сайт открывают с телефона... */
@media screen and (max-width: 650px) {

  /* Меняем направление главной оси в main. */
  main {
    flex-direction: column;
  }

  /* И главный блок section теперь идёт первым. */
  section {
    order: -1;
  }
}

/* Увеличиваем элементы aside. */
aside {
  flex: 1;
}

/* Но пусть элемент section будет больше. */
section {
  flex: 3;
}


/* ЦЕНТРАЛИЗАЦИЯ ЭЛЕМЕНТОВ FLEX-CONTAINER. */
.flex-container {
  display: flex;
  justify-content: center;
  align-items: center;
}


/* КАК СДЕЛАТЬ КАРТОЧКУ С ТЕКСТОМ И КАРТИНКОЙ. */
.flex-container {
  display: flex;
  /* Выравниваем элементы в начале поперечной оси (сверху). Но как я понял, на картинку это не распространяется. */
  align-items: flex-start;
  /* Чтобы было легко менять положение картинки и текста, например
  чтобы картинка шла справа, то можно изменить значение свойства flex-direction на row-reverse. */
  flex-direction: row;
  /* Добавляем отступ. */
  gap: 1em
}

/* Разрешаем тексту забирать свободное пространство. */
.content {
  flex: 1
}


/* СОЗДАНИЕ НАВИГАЦИИ НА САЙТЕ. */
.flex-container {
  /* Создаём flex-container. */
  display: flex;
  /* Меняем направление главной оси для колонок и задаём высоту, равную высоте экрана. */
  min-height: 100vh;
}


aside {
  /* Создаём flex-container. */
  display: flex;
  /* Задаём минимальный размер для навигационного блока. */
  min-width: 280px;
  /* Меняем направление главной оси, чтобы элементы шли вертикально вниз. */
  flex-direction: column;
  /* И добавляем между ними пространство. */
  justify-content: space-between;
}
