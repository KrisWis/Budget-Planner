/* Основы Sass - https://sass-scss.ru/guide/. */


/* ПРЕПРОЦЕССИНГ. */


/* Препроцессор Sass помогает в крупных проектах.
Sass позволяет использовать функции недоступные в самом CSS, например,
переменные, вложенности, миксины, наследование и другие приятные вещи, возвращающие удобство написания CSS. */
/* Чтобы скомпилировать Sass файл в CSS файл, всего лишь нужно сообщить Sass, где взять файл Sass и в какой файл CSS его скомпилировать. 
Например, запустив команду sass input.scss output.css в терминале, вы сообщаете Sass взять один Sass файл, input.scss, и скомпилировать в файл output.css.*/
/* Если вы хотите отслеживать изменения (вместо ручной перекомпиляции) вашего файла, например, input.scss, то вам необходимо просто добавить флаг в команду:
"sass –watch input.scss output.css" (вводить в терминал). */
/* Вы также можете указать папки для отслеживания изменений и куда сохранять компилированные CSS файлы, для этого достаточно указать пути и разделить их двоеточием:
"sass --watch app/sass:public/stylesheets" (вводить в терминал).
Sass будет отслеживать все файлы в директории app/sass и компилировать CSS в директорию public/stylesheets. */


/* ПЕРЕМЕННЫЕ. */


/* Вы можете хранить в переменных цвета, стеки шрифтов или любые другие значения CSS, которые вы хотите использовать. 
Чтобы создать переменную в Sass нужно использовать символ $. */

/* Объявляем переменные font-stack и primary-color, в которых храним шрифт и цвет. */
$font-stack: Helvetica, sans-serif;
$primary-color: #333;

/* Указываем переменные вместо свойств. */
body {
  /* Когда Sass обрабатывается, он принимает значения, заданные нами в $font-stack и $primary-color и
  вставляет их в обычном CSS-файле в тех местах, где мы указывали переменные как значения. */
  font: 100% $font-stack;
  color: $primary-color;
}


/* ВЛОЖЕННОСТИ. */


/* Sass позволит вам вкладывать CSS селекторы таким же образом, как и в визуальной иерархии HTML. 
Но помните, что чрезмерное количество вложенностей делает ваш документ менее читабельным и воспринимаемым, что считается плохой практикой. */

/* Это Sass код, в котором есть элемент nav и вложенные в него элементы ul, li, a. */
nav {
  ul {
    margin: 0;
    padding: 0;
    list-style: none;
  }

  li { display: inline-block; }

  a {
    display: block;
    padding: 6px 12px;
    text-decoration: none;
  }
}

/* Вот как этот код будет выглядеть в CSS. */
nav ul {
  margin: 0;
  padding: 0;
  list-style: none;
}
nav li {
  display: inline-block;
}
nav a {
  display: block;
  padding: 6px 12px;
  text-decoration: none;
}


/* ФРАГМЕНТИРОВАНИЕ. */


/* Вы можете создавать фрагменты Sass-файла, которые будут содержать в себе небольшие отрывки CSS, которые можно будет использовать в других Sass-файлах.
Это отличный способ сделать ваш CSS модульным, а также облегчить его обслуживание.
Фрагмент — это простой Sass-файл, имя которого начинается с нижнего подчеркивания, например, _partial.scss.
Нижнее подчеркивание в имени Sass-файла говорит компилятору о том, что это только фрагмент и он не должен компилироваться в CSS. 
Фрагменты Sass подключаются при помощи директивы @import. */


/* ИМПОРТ. */


/* CSS имеет возможность импорта, которая позволяет разделить ваш CSS-файл на более мелкие фрагменты. При использовании @import в CSS создается еще один HTTP-запрос.
Sass берет идею импорта файлов через директиву @import, но вместо создания отдельного HTTP-запроса Sass импортирует указанный в директиве файл в тот, где он вызывается,
т.е. на выходе получается один CSS-файл, скомпилированный из нескольких фрагментов. */


// Первый SASS файл (first.scss).
html,
body,
ul,
ol {
  margin:  0;
  padding: 0;
}

// Основной SASS файл (base.scss).
/* Чтобы импортировать файл, нужно использовать директиву @import и в кавычках написать название файла без расширения. */
@import 'first';
body {
  font: 100% Helvetica, sans-serif;
  background-color: #efefef;
}

/* После компиляции в CSS файл, образуется следующий фрагмент, состоящий из свойств обоих файлов, но
свойства импортированного файла идут первее. */
html,
body,
ul,
ol {
  margin:  0;
  padding: 0;
}
body {
  font: 100% Helvetica, sans-serif;
  background-color: #efefef;
}


/* МИКСИНЫ. */


/* Миксины - блоки Sass кода, которые могут принимать аргументы (необязательно) и
позволяют значительно расширить возможности написания стилей и сократить затраты времени на применении однотипных правил и даже целых CSS блоков.
Это что-то вроде функции, как в Python, которая может принять аргумент, выполнить огромный объем работы и выдать результат в зависимости от входного параметра. */
/* Миксины удобно использовать для вендорных префиксов и для однотипных и повторяющихся блоков кода.  */

/* Чтобы объявить миксин используют директиву @mixin и задают ей имя (в нашем случае это - transform).
В скобках можно ничего не передать, а можно передать переменную, чтобы использовать её как аргумент.
Свойствам -webkit-transform, -ms-transform, transform мы задали одинаковые значения с помощью переменной. */
@mixin transform($property) {
  -webkit-transform: $property;
  -ms-transform: $property;
  transform: $property;
}
/* Чтобы объявить миксин нужно использовать директиву @include и дальше передать имя миксина (в нашем случае это - transform). 
А дальше в скобках передаём значение, на которое замениться переменная $property. */
.box { 
    @include transform(rotate(30deg))
}

/* Вот как будет выглядеть класс box, когда мы скомпилируем SCSS файл в CSS. */
.box {
    -webkit-transform: rotate(30deg);
    -ms-transform: rotate(30deg);
    transform: rotate(30deg);
  }
  

/* РАСШИРЕНИЕ/НАСЛЕДОВАНИЕ. */


/* Используя директиву @extend можно наследовать наборы свойств CSS от одного селектора другому. Это позволяет держать Sass-файл в «чистоте».
В следующем примере будут стили оповещений об ошибках, предупреждениях и удачных исходах, которые будут сделаны, используя другие возможности Sass,
которые идут рука-об-руку с расширением, классами-шаблонами. 
Класс-шаблон - особый тип классов, который начинается с % и выводится только при использовании расширения - 
это позволит сохранить ваш скомпилированный CSS чистым и аккуратным. */
/* Вообщем, расширение делает так, чтобы разраб саморучно не объявлял одни и теже свойства по нескольку раз, 
а был специальный шаблон, который можно использовать на любые другие селектора. */

/* Чтобы использовать наследование нужно перед селектором поставить %.
Класс-шаблон %message-shared будет использован, т.к используется с помощью @extend, дальше в коде.  */
%message-shared {
    border: 1px solid #ccc;
    padding: 10px;
    color: #333;
  }
  
// Класс-шаблон %equal-heights не будет использован в коде, т.к нигде не вызывается с помощью @extend.
%equal-heights {
    display: flex;
    flex-wrap: wrap;
}

/* Класс message будет иметь все те же свойства, что и %message-shared, т.е наследует все его свойства. */
.message {
    @extend %message-shared;
}

/* Класс success будет иметь все те же свойства, что и %message-shared, но также будет иметь зеленую обводку. */
.success {
    @extend %message-shared;
    border-color: green;
}

/* Класс error будет иметь все те же свойства, что и %message-shared, но также будет иметь красную обводку. */
.error {
    @extend %message-shared;
    border-color: red;
}

/* Класс warning будет иметь все те же свойства, что и %message-shared, но также будет иметь жёлтую обводку. */
.warning {
    @extend %message-shared;
    border-color: yellow;
}

/* Вот как это будет выглядеть при компиляции в CSS.*/
/* Классы message, success, error, warning имеют свойства, которые были объявлены в %message-shared. */
.message, .success, .error, .warning {
    border: 1px solid #ccc;
    padding: 10px;
    color: #333;
  }
  
/* Но success, error, warning также имеют собственные свойства. */
.success {
    border-color: green;
}

.error {
    border-color: red;
}

.warning {
    border-color: yellow;
}
  

/* МАТЕМАТИЧЕСКИЕ ОПЕРАТОРЫ. */


/* Sass имеет несколько стандартных математических операторов, таких как +, -, *, / и %. */

// Атрибут role в позволяет наиболее четко указать семантическое предназначение блока/элемента страницы при взаимодействии пользователя с сайтом.
/* Стилилизуем элементы article, у которых значение атрибута role равно "main". */
article[role="main"] {
  float: left;
  /* Определяем ширину используя деление и умножение. */
  width: 600px / 960px * 100%;
}

/* Стилилизуем элементы aside, у которых значение атрибута role равно "complementary". */
aside[role="complementary"] {
  float: right;
  /* Определяем ширину используя деление и умножение. */
  width: 300px / 960px * 100%;
}