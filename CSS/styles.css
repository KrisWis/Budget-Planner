/* БАЗОВЫЙ СИНТАКСИС И ПРИМЕНЕНИЕ СТИЛЕЙ. https://www.youtube.com/watch?v=qxAnaoPI8cE&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=2*/
@import "main.css"; /* Импортируем файл main.css - импортируются все стили из него. */

/* h2 - это селектор, к которому применяются стили. */
h2 {
  /* Задаём свойству color значение green, чтобы цвет стал зелёным. */
  /* Несколько объявлений (определение значения для свойства) в селекторе называются блоком объявлений. */
  color: green;
  text-decoration: underline;
}


/* ПРОСТЫЕ СЕЛЕКТОРЫ. https://www.youtube.com/watch?v=vnmfn31G988&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=3 */


/* Селектор * определяет все элементы на страницы. */
* {
  color: red;
}

/* Селекторы могут быть в качестве html тегов. */
p {
  color: green;
}

/* Чаще всего селекторы определяются с помощью классов, имена которых должны начинаться с точки. */
.heading1 {
  /* Задаём свойству text-decoration значение underline, чтобы текст был подчёркнутым. */
  text-decoration: underline;
}

/* Задаём свойству text-transorm значение undercase, чтобы текст был в верхнем регистре. */
.heading2 {
  text-transform: uppercase;
}

/* Если мы хотим, чтобы стили применились только к определённым элементам (например, к тегам <p>), то перед названием класса указываем данный тег. */
p.fz20 {
  font-size: 20px;
}

/* Также можно, но НЕ НУЖНО, определять стили с помощью id элементов, которые должны начиться с #
  Селекторы, которые определяются с помощью id весят 100.  */
#heading,
#heading2 {
  font-size: 40px;
  border: 1px solid #000;
}

/* Селектор включающий в себя только тег весит 1. */
q {
  color: blue;
}

/* А селектор, который включает в себя тег q(1) и проверяет каждый тег на наличие класса simple(10) весит уже 11. */
q.simple {
  color: aqua;
}

/* Данный селектор, который включает в себя тег body(1) и тег q(1) и класс simple(10) весит 12. */
body q.simple {
  color: fuchsia;
}

/* Данный селектор, который включает в себя id: main(100), 3 класса: container, post, giga (30), 3 тега: article, header, h1 (3) равен 133.
Браузер сравнивает вес "#main .container article.post", равный 121 и вес "header h1.giga", равный 12.
И естественно, применяет стили к части "#main .container article.post".
Это нужно для того, если разработчику лень считать веса самому. */
#main .container article.post > header h1.giga {
  color: #777;
}


/* СОСТАВНЫЕ СЕЛЕКТОРЫ. https://www.youtube.com/watch?v=fyI_K_Oya74&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=4 */


/* ЛУЧШЕ И БЫСТРЕЕ ИСПОЛЬЗОВАТЬ КЛАССЫ, А ЭТО ПРОСТО ЗНАТЬ ДЛЯ ОБЩЕГО РАЗВИТИЯ. */

/* Составные селекторы можно сделать путём перечисления простых селекторов через запятую. */
h1,
h2,
span {
  color: red;
}

/* Тег <p> является потомком тега <div> и стили определяются только для этого <p>. */
div p {
  color: green;
}

/* Здесь тег <p> является потомком тега <div>, но также является родителем для тега <span> и стили определяются именно для <span>. */
div p span {
  color: blue;
}

/* Если мы хотим указать, что стилизируемый элемент должен быть потомком другого без каких-либо доп.вложений, 
то между тегом родителя (ul li) и тегом потомка (span) ставиться знак < 
(Чтобы перед span были только теги ul li, без каких либо других.) */
ul li > span {
  font-weight: bold;
}

/* В данном примере все элементы, которые идут после первого li окрашиваются в голубой.
Т.к мы складываем элементы li, и получается 2 li, значит все li элементы со второго li окрашиваются в голубой.  */
ul li + li {
  color: aqua;
}

/* С помощью знака ~ (тильда) разделяются основной элемент и те, которые будут стилилизоваться.
Т.е ко всем элементы <p>, идущим после тега <br> стилилизуются. */
br ~ p {
  font-size: 30px;
}

/* Стилилизуем элементы <a>, у которых есть атрибут target. */
a[target] {
  background-color: yellow;
}

/* Стилилизуем элементы <a>, у которых есть значение атрибута target равно "_blank". */
a[target="_blank"] {
  background-color: blue;
}

/* Если перед знаком "=" поставить знак "^", то проверяются элементы <a>, у которых атрибут href начинается с "http://123" */
a[href^="http://123"] {
  background-color: aqua;
}

/* Если перед знаком "=" поставить знак "$", то проверяются элементы <a>, у которых атрибут href в конце имеет ".jpg",
то есть проверка начинается с конца. */
a[href$=".jpg"] {
  background-color: teal;
}

/* Если перед знаком "=" поставить знак "*", то проверяются элементы <a>, у которых атрибут href ИМЕЕТ "link" (то есть link может находиться в любой части строки). */
a[href*="link"] {
  background-color: rebeccapurple;
}


/* ПСЕВДОЭЛЕМЕНТЫ И ПСЕВДОКЛАССЫ. https://www.youtube.com/watch?v=C40ePbYJxmM&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=5 */


/* Псевдокласс в CSS — это ключевое слово, добавленное к селектору, которое определяет его особое состояние. */
a {
  color: black;
  /* Значение none у свойства text-decoration убирает подчёркивания и прочее у текста. */
  text-decoration: none;
}

/* Перед псевдоклассами ставиться двоеточие. Псевдоклассы стоят после селектора. */
/* Псевдокласс hover может быть использован для изменения цвета кнопки при наведении курсора на неё. */
a:hover {
  color: red;
}

/* Псевдокласс visited может быть использован для изменения цвета кнопки, если ресурс данной ссылки был посещён ранее. */
a:visited {
  color: aqua;
}

/* Псевдокласс active может быть использован для изменения цвета кнопки, если нажать на ссылку мышкой, но не отжимать клавишу (зажимаем, а не нажимаем 1 раз). */
a:active {
  color: green;
}

/* Псевдокласс focus может быть использован для изменения цвета кнопки, если пользователь перемещается по странице с помощью кнопки Tab 
(нажатие на Tab и элементу, на котором стоит фокус применяются стили). */
a:focus {
    /* Значение bold у свойства font-weight устанавливает насыщенность шрифта. bold — полужирное начертание */
  font-weight: bold;
}

/*Псевдоэлемент — это дополнение к селектору, с помощью которого можно стилизовать элемент, не определённый в структуре HTML документа. 
Добавляется он к селектору c помощью символов :: */
/* Псевдоэлемент применяет стили к первой букве элементов p (в нашем случае). */
p::first-letter {
  font-size: 40px;
}

/* Псевдоэлемент применяет стили к первой строке элементов p (в нашем случае). */
p::first-line {
  text-decoration: underline;
}

/* Псевдоэлемент selection позволяет применить стили к части документа, который был выделен пользователем (например, с помощью мыши).
selection поддерживает только изменение фона и цвета. */
p::selection {
  background-color: yellow;
  color: red;
}

/*Псевдоэлементы before и after позволяют показать на веб-странице что-то, что может отсутствовать в HTML-контенте. */
/*Псевдоэлемент before, в данном примере, добавляет перед текстом элемента h1 фразу "This is " в верхнем регистре. */
h1::before {
  content: "This is ";
  text-transform: uppercase;
}

/*Псевдоэлемент after, в данном примере, добавляет после текста элемента h1 фразу " channel" красного цвета. */
h1::after {
  content: " channel";
  color: red;
}

/*Псевдоэлементы для списков. */
/*Определяем класс list1 и тег li, который будет определяться, как "элемент списка" и потом определяем псевдоэлемент first-child, который применяет стили к первому элементу списка. */
.list1 li:first-child {
  color: blue;
}

/*Определяем класс list1 и тег li, который будет определяться, как "элемент списка" и потом определяем псевдоэлемент last-child, 
который применяет стили к последнему элементу списка. */
.list1 li:last-child {
  color: green;
}

/*Определяем класс list2 и тег li, который будет определяться, как "элемент списка" и потом определяем псевдоэлемент nth-child(even), 
который применяет стили к каждому чётному элементу списка. */
.list2 li:nth-child(even) {
  color: blue;
}

/*Определяем класс list2 и тег li, который будет определяться, как "элемент списка" и потом определяем псевдоэлемент nth-child(odd), 
который применяет стили к каждому нечётному элементу списка. */
.list2 li:nth-child(odd) {
  color: green;
}

/*Определяем класс list3 и тег li, который будет определяться, как "элемент списка" и потом определяем псевдоэлемент nth-child(индекс элемента), 
который применяет стили к элементу, индекс которого указан в скобках. */
.list3 li:nth-child(2) {
  color: blue;
}

/*Определяем класс list3 и тег li, который будет определяться, как "элемент списка" и потом определяем псевдоэлемент nth-child(уравнение), 
который применяет стили к каждому 3-ему элементу начиная с 1 включительно. */
.list3 li:nth-child(3n + 1) {
  text-transform: uppercase;
}

/*Определяем класс list3 и тег li, который будет определяться, как "элемент списка" и потом определяем псевдоэлемент nth-child(уравнение), 
который применяет стили к каждому 4-ему элементу начиная с 2 включительно. */
.list3 li:nth-child(4n + 2) {
  /* Добавляем чёрную рамку в 1 пиксель. */
  border: 1px solid black;
}

/* Определяем класс list4 и тег li, который будет определяться, как "элемент списка" и потом определяем псевдоэлемент not(название класса), 
который применяет стили к элементам, которые не имеют класса, указанного в скобках.
not(.item) равен 1 (вес псевдоэлемента, а не псевдоэлемента + класса, в нём) */
.list4 li:not(.item) {
  border: 1px solid blue;
}

/* Определяем класс text и тег span, который будет определяться, как "элемент списка" и потом определяем псевдоэлемент first-of-type, 
который применяет стили к первому дочернему элементу. */
.text span:first-of-type {
  color: red;
}

/* Определяем класс text и тег span, который будет определяться, как "элемент списка" и потом определяем псевдоэлемент last-of-type, 
который применяет стили к последнему дочернему элементу. */
.text span:last-of-type {
  color: green;
}

/* Определяем класс text и тег span, который будет определяться, как "элемент списка" и потом определяем псевдоэлемент nth-of-type(индекс элемента), 
который применяет стили к дочернему элементу, индекс которого определён в скобочках. */
.text span:nth-of-type(2) {
  border: 1px solid black;
}


/* КАСКАДНОСТЬ И НАСЛЕДОВАНИЕ. https://www.youtube.com/watch?v=Y8UFzOoKkvQ&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=6 */


/* ЗДЕСЬ, КОГДА Я ГОВОРЮ, ЧТО ПРИМЕНЯЮТСЯ СТИЛИ ТОГО ИЛИ ИНОГО ЭЛЕМЕНТА, ТО ИМЕЮ ВВИДУ КОНФЛИКТНЫЕ ЭЛЕМЕНТЫ.
(т.е если в классе и id есть backround-color, то применяется background-color id, т.к вес id больше веса класса). */
/* Если селектора имеют одинаковый вес, то применяется то свойство, которое написано ниже в коде. */
/* Также, если к селектору, например тегу <p>, применены стили, но в нём определён класс, то применяются именно стили класса, а не тега, 
т.к вес класса больше веса тега (10 > 1). */
/* Тоже самое, если в теге определён класс и id, то применяются стили для id, 
т.к его вес больше чем классов (100 > 10). */
/* Точно тоже самое, если в файле css применены стили к id, но в html файле написаны inline стили, то к элементу применяются именно inline стили, 
т.к их вес больше веса id (1000 > 100). */
/* CSS правило !important дает больше значимости, чем любое другое свойство, т.е будет применяться именно зелёный цвет, а не цвет, указанный например в классе. 
Свойство, помеченное таким флагом применяется к селектору В ЛЮБОМ СЛУЧАЕ (но ладно, оно может не примениться если ниже в коде, к такому же свойству применен тоже !important). */
p { 
  color: green !important; 
  }

/* none!important отменяет свойство у элемента (в данном случае, убирает обводку). Оно также как и !important применяется В ЛЮБОМ СЛУЧАЕ. */
p { 
  border: none!important; 
  }

/* В CSS есть свойства, которые наследуются (т.е те, которые появяться у всех элементов в теге <body>) а есть те, которые не наследуются (т.е появяться только у тега <body>). */
body {
  /* Например, красным окраситься весь текст, который есть в тегах <body>. */
  color: red;
  /* А рамка появиться только у тега <body>. */
  border: 1px solid black;
  /* Увеличенный отступ в 30px появиться только у <body>. */
  margin-bottom: 30px;
}

p {
  /* Так как, в теге <body> у нас находиться теги <p>, то он и будет здесь селектором. 
  В свойства border мы пишем значение inherit, чтобы свойство границы было унаследовано у селектора <body>, который написан выше. */
  border: inherit;
  /* Если тут указать значение inherit, то <p> также, унаследует значение margin, которые было в <body>. */
  margin: inherit;
}

/* Не стоит забывать про то, что у браузера есть свои собственные стили (например, ссылка, которая окрашивается в синий цвет). */
/* Есть два подхода, чтобы стили сайта отображались одинаково на любом браузере - CSS normalize или CSS reset. 
Оба этих подхода - всего лишь css файлы со своими стилями, которые нужно подключить перед css файлом разработчика. */
/* CSS Normilize делает стили для каждого из браузеров примерно одинаковыми.
А CSS Reset обнуляет стили для каждого из браузеров, чтобы разработчик писал стили "с полного нуля". */
/* Можно использовать CSS Reset и CSS Normilize в паре при разных ситуациях 
(если бесит синий цвет ссылок, то используем CSS Reset, а если хотим, чтобы теги везде одинаково отображались, то используем CSS Normilize). */


/* БЛОЧНАЯ МОДЕЛЬ И ОТСТУПЫ. https://www.youtube.com/watch?v=1jvIi039-i4&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=7*/


/* Блочный элемент (например, обёрнутый в тег <div>) занимает всю строку экрана, а строчный элемент занимает место по размеру текста в нём (например, обёрнутый в тег <span>). */
span,
div {
  /* Обводка, чтобы видеть размер элемента */
  border: 10px solid red;
  /* padding создаёт пространство между содержимом тега (текстом) и его границей. */
  padding: 10px; 
  /* margin создаёт пространство между содержимым тега (текста) и содержимыми других тегов. Это пространство создаётся за границей, которую создаёт padding. */
  margin: 10px;
  /* В padding можно передать значения, которые определяются как отступы между содержимого тега и его границей:
  отступ сверху - 10 px
  отступ справа - 20 px.
  отступ снизу - 30 px.
  отступ слева - 40 px. */
  padding: 10px 20px 30px 40px;
  /* В margin можно передать значения, которые определяются как отступы, отделяемые один тег от другого.
  Если значения сверху и снизу, и справа и слева одинаковы, то можно записать так, передав только 2 значения, и значит:
  отступ сверху и снизу - 10 px
  отступ справа и слева - 20 px. */
  margin: 10px 20px;
  /* С помощью padding-top (для margin - margin-top, но он не работает для строчных элементов) создать отступ сверху. */
  padding-top: 10px;
  /* С помощью padding-right (для margin - margin-right) создать отступ справа. */
  padding-right: 20px;
  /* С помощью padding-bottom (для margin - margin-bottom, но он не работает для строчных элементов) создать отступ снизу. */
  padding-bottom: 30px;
  /* С помощью padding-left (для margin - margin-left) создать отступ слева. */
  padding-left: 40px;
}
/* Также, если 2 элемента с разныи margin стоят рядом, то расстояние между ними будет равно значению большего margin (это называется схлопывание margin`ов). */


/* Есть элемент <div> (который делает блочный элемент) с классом test, но с помощью значения inline свойства display можно сделать его строчным. */
.test {
  display: inline;
}

/* Указав значение block у свойства display, мы можем сделать элемент блочным. */
.test {
  display: block;
}

/* Указав значение inline-block у свойства display, мы можем сделать элемент строчно-блочным. Тогда этот элемент будет иметь свойства обоих типов, но не их ограничения. */
.test {
  display: inline-block;
}

/* Свойства width и height не применяются для строчных элементов. */
span {
  width: 100px;
  height: 100px;
}

.mar {
  margin-top: 50px;
  /* Свойства width и height не меняют размер текста, а создают пространство для контента, написанный в тегах. */
  width: 100px;
  height: 100px;
  display: inline-block;
  /* При значении content-box свойства box-sizing, width и height применяются к области контента, а сами границы расширяются.
  При значении border-box свойства box-sizing, width и height применяются ко всей области всего элемента,
  От этого, область для контента уменьшается (т.к нужно ещё оставить пиксели для padding, margin и тд).
  Значение border-box нужно, если требуется, чтобы элемент(div) был фиксированной ширины при любых значениях padding и border.
  А ещё, если блоков много, то они переделываются на другую строчку, а при border-box они все находяться в одной строке.  */
  box-sizing: border-box;
}


/* ПОЗИЦИОНИРОВАНИЕ И РАЗМЕРЫ. https://www.youtube.com/watch?v=iydD985acAc&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=9 */


/* Поток описывает, как элементы располагаются относительно друг друга. 
По умолчанию родственные элементы находятся в одном потоке и их расположение на странице статично; порядок появления элементов на странице такой же, как и в коде. 
С помощью CSS можно перемещать элементы в отдельные потоки. Это дает больше возможностей для дизайна страницы и контроля схемы размещения элементов над кодом.*/

/* Изначально, все элементы находяться в основном потоке документа, 
но есть свойства (position), которые "вырывают" элемент из основного потока и формируют новый.  */
.test {
  /* static применяется к каждому элементу по дефолту и он остаётся в основном потоке документа. */
  position: static;
  /* relative создаёт новый поток для элемента и теперь мы можем управлять его положением.
  ПРИ RELATIVE ОТСЧЁТ ПОЗИЦИИ СОВЕРШАЕТСЯ ОТНОСИТЕЛЬНО ПРОШЛОЙ ПОЗИЦИИ ЭЛЕМЕНТА, А НЕ ДОКУМЕНТА.
  Если изменять элемент с помощью position: relative, то соседние элементы останутся на своих местах и никак на это не отрагируют.  */
  position: relative;
  /* top, right, bottom, left - это свойства для position.
  top говорит, оттолкнись от вверха на 20 px (т.е вниз на 20px) */
  top: 20px;
  /* right говорит, оттолкнись от права на 20 px (т.е влево на 20px) */
  right: 20px;
  /* bottom говорит, оттолкнись от низа на 20 px (т.е вверх на 20px) */
  bottom: 20px;
  /* left говорит, оттолкнись от лева на 20 px (т.е вправо на 20px) */
  left: 20px;
  /* absolute делает так, что основной поток теряет связь с элементом и его место в тексте заполняется.
  ПРИ ABSOLUTE ОТСЧЁТ ПОЗИЦИИ ЭЛЕМЕНТА СОВЕРШАЕТСЯ ОТНОСИТЕЛЬНО ДОКУМЕНТА (т.е от края окна страницы). */
  /* НО если у элемента есть родитель, у которого position отличается от static, то элемент позициионируется относительно краёв его родителя. */
  position: absolute;
  /* fixed делает так, чтобы позиция элемента ВСЕГДА отсчитывалась от края окна страницы. */
  position: fixed;
  /* sticky делает так, чтобы позиция элемента остаётся в своём блоке (как обычно).
  НО когда "потолок" страницы доходит до этого элемента (во время прокрутки), то он начинает ползти вниз до пола своего блока. */
  position: sticky;
  /* Когда разработчик задаёт width и height, то элемент никогда не подстроиться под контент и его размер всегда будет постоянным. */
  /* Но при свойствах min-width и min-height исходный блок растягивается под контент (если контент не вмещяется в этот блок).
  Но если контента нет или он меньше 100 px, то блок так и останеться равным 100px. */
  min-width: 100px;
  min-height: 100px;
  /* Свойства max-width и max-height задают максимальную ширину/высоту, на которую элемент способен измениться (растянуться). */
  max-width: 500px;
  max-height: 500 px
}


/* ЕДИНИЦЫ, ПЕРЕПОЛНЕНИЕ И УРОВНИ ЭЛЕМЕНТОВ. https://www.youtube.com/watch?v=pEdt0afL2-o&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=9 */


/* px - это абсолютная величина (это всегда одинаковая) */
.main {
  font-size: 40px;
}

/* % - это относительная величина (изменяется от того, какой размер текста у родителя) 
Здесь берётся 80% от размера предыдущего пункта в списке.
А первый пункт будет размера, равному 80% от абсолютного размера данного тега. */
li {
  font-size: 80%;
}

/* em - это относительная величина, которая увеличивается в 2 раза, в зависимости от  размера родителя (её количество - сколько раз перемножать). */
li {
  font-size: 2em;
}

/* rem - это относительная величина, которая своё количество (тут 2) умножает на дефолтный размер текста в браузере. */
li {
  font-size: 2rem;
}

/* селектор html изменяет стили для всего, только с помощью него можно изменять стили, которые по дефолту стоят в браузере. */
html {
  font-size: 2rem;
}

/* overlay - это штука, которая "затемняет" задний фон, когда на сайте появляется новое окно. */
.overlay {
  background-color: rgba(0, 0, 0, 0.5);
  color: white;
  position: absolute;
  /*vw и vh - это как бы "проценты" заполненности всего экрана устройства (также полностью заполняется для мобильных устройств и тд). */
  width: 100vw;
  height: 100vh;
  top: 0;
  left: 0;
  /* С помощью calc можно производить вычисления для размеров. */
  width: calc(100px + 200px + 1rem); 

  /* z-index - это число, которое определяет уровень элемента. 
  Т.е допустим, есть два окна в одной позиции, и 2 окно перекрывает 1, т.к находиться ниже в коде.
  Но если, у первого окна поставить z-index=2, а у 2 окна он по дефолту равен 0 (но, это можно изменить с помощью z-index), 
  то теперь 1 окно будет перекрывать 2.
  z-index может принимать отрицательные значения, чтобы окно было ПОД основными. */
  z-index: 1;
}

.modal {
  border: 2px solid black;
  width: 300px;
  height: 100px;
  background-color: cornflowerblue;
  font-size: 20px;
  color: white;
  position: absolute;
  /* overflow - это свойство, если текст не помещается в блок. */
  /* Значение auto создаёт ползунок в блоке (если текст в него не поместился), чтобы можно было листать её и видеть текст, который находиться ниже. */
  overflow: auto;
  /* Значение scroll также, как и auto создаёт ползунок в блоке, но создаёт его в любом случае, даже если текст поместился в блок. */
  overflow: scroll;
  /* Значение hidden жёстко обрезает текст, который не поместился в блок. */
  overflow: hidden;
  /* overflow-y принимает те же самые значения, что и overflow, но применяет эти свойства только для вертикального направления элемента. */
  overflow-y: auto;
  /* overflow-x принимает те же самые значения, что и overflow, но применяет эти свойства только для горизонтального направления элемента. */
  overflow-x: scroll;
}


/* ПЛАВАЮЩИЕ ЭЛЕМЕНТЫ И ОЧИСТКА ПОТОКА. https://www.youtube.com/watch?v=1kZ9FTp2IiE&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=10 */


.item {
  /* float вырывает документ из основного потока документа и формирует для него новый. А это значит, что другие элементы перестают его видеть. */
  /* при использовании float, элемент на котором мы его используем, изменит свой размер под размер своего контента,
  а следующий элемент изменит своё положение, станет вплотную к первому элементу. 
  Если сделать float:right для 3 элемента, то он просто изменит своё положение в правую сторону и изменит свой размер под контент. */
  /* Если же 1 элементу сделать float:left, а 2 элементу float:right,
  то 1 элемент будет слева, 3 элемент между ними (но будет находиться под ними и перекрываться ими, он занял их место), а 2 элемент справа. */
  /* В html разметке, сначала идёт левый элемент, потом правый и уже потом, то что между ними. */
  /* float можно задать и строчным элементам, но они начнут ввести себя, как блоки. */
  /* Если float элементы не влезают в строку, то будут перенесены на следующую. */
  float: left;
  width: 150px;
}


/* Штука, чтобы заставлять элемент родителя "расхлопываться" (чтобы в нём были float элементы и они не перекрывали основной контент). */
.clearfix:after {
  /* Если задавать float какому-либо элементу, то нужно указать clearfix для родителя. */
  content: "";
  display: block;
  /* сlear: both означает, 
  что в рамках одного блочного отформатированного контекста обе стороны элемента 
  не могут примыкать к элементам, к которым ранее применено float.
  Если вкратце, то она очищает обтекание, чтобы float элементы находились в родительском блоке. */
  clear: both;
  /* clear:left делает очистку слева. */
  clear: left;
  /* clear:right делает очистку справа. */
  clear: right;
  /* clear:none отменяет очистку. */
  clear: none;
}


/* ШРИФТЫ И ТЕКСТ. https://www.youtube.com/watch?v=TAB8pVUKiI4&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=11 */


h1 {
  /* font-family определяет приоритетный список из одного или нескольких названий семейства шрифтов и/или общее имя шрифта для выбранного элемента. */
  /* serif - чтобы шрифт был с засечками, а sans-serif без засечек.  
  Это нужно, если на компьютере не будет указанного шрифта, то взялся бы любой с засечками или без. */
  /* Сначала, в кавычках, указываем шрифт, который будет использоваться,
  Потом шрифты, которые будут использоваться если того шрифта не будет на устройстве, 
  И потом, указываем то будет ли шрифт с засечками или без, если ни одного из указанных шрифтов нету на устройстве. */
  font-family: "Roboto", Arial, Helvetica, sans-serif;
}


/* Чтобы взять шрифты из Google fonts - https://fonts.google.com/, нужно в HTML документ вставить ссылку на шрифт: 
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@100;500;900&display=swap" rel="stylesheet"> */
/* А в CSS документе определить шрифты: */
body {
  font-family: "Roboto", sans-serif;
  /* font-size определяет размер шрифта. */
  font-size: 100px;
  /* А font-weight определяет толщину шрифта. */
  font-weight: 100px;
  /* font-style определяет стиль написания шрифта (тут курсив). */
  font-style: italic;
}

/* Чтобы подключить локальный шрифт на страницу, указывается специальная директива @font-face*/
@font-face {
  /* Где указываем имя шрифта, */
  font-family: "Roboto";
  /* Путь до файла со шрифтом,
  Для лучшей кроусбраузерности, наш один шрифт нужно определить в несколько форматов с разными расширениями. */ 
  src: url("/fonts/Roboto-Regular.ttf") format("truetype"),
    url("/fonts/Roboto-Regular.woff") format("woff"),
    url("/fonts/Roboto-Regular.woff2") format("woff2"),
    url("/fonts/Roboto-Regular.otf") format("opentype");
  /* Толщину шрифта, */
  font-weight: 500;
  /* Начертание шрифта, */
  font-variant: normal;
  /* узкое, нормальное или широкое начертание шрифта, */
  font-stretch: wider;
  /* И его стиль написания. */
  font-style: normal;
}

/* Если хотим подключить ещё один стиль, делаем те же самые действия. */
@font-face {
  font-family: "RobotoBoldItalic";
  src: url("/fonts/Roboto-BoldItalic.ttf") format("truetype"),
       url("/fonts/Roboto-BoldItalic.woff") format("woff"),
       url("/fonts/Roboto-BoldItalic.woff2") format("woff2"),
       url("/fonts/Roboto-BoldItalic.otf") format("opentype");
  font-weight: 900;
  font-style: italic;
} 

h1 {
  /* С помощью свойства color, тексту можно задать цвет. */
  color: blueviolet;
  /* text-decoration задаёт варианты подчёркивания текста: 
  underline - подчёркивание снизу; 
  overline - подчёркивание сверху;
  line-through - перечёркивание;
  none - убирает подчёркивание. */
  text-decoration: underline overline line-through none;
  /* letter-spacing задаёт расстояние между символами. */
  letter-spacing: 2px;
  /* word-spacing задаёт расстояние между словами. */
  word-spacing: 10px;
  /* line-height задаёт расстояние между строчками. */
  line-height: 100px;
  /* text-transform помогает трансформировать текст: 
  uppercase - все символы в теге трансформируются в верхний регистр. 
  lowercase - все символы в теге трансформируются в нижний регистр. 
  capitalize - каждый первый символ любого слова в теге будет писаться с большой буквы.
  none - отмена любых ранее применённых текстовых трансформаций. */
  text-transform: capitalize;
  /* text-align выравнивает текст по: 
  right - правому краю,
  left - левому краю,
  center - центру,
  justify - левому и правому краю, растягивая предложения в середине. */
  text-align: justify;
  /* text-indent задаёт отступ в начале текста (красная строка). 
  В этом свойстве нужно указывать размер отступа. */
  text-indent: 20px;
}


/* ГРАНИЦЫ И ТЕНИ. https://www.youtube.com/watch?v=dAHu16pgBrg&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=12 */


.example {
  /* border находиться между padding и margin (border - это обводка элемента). */
  /* border-width задаёт толщину обводки. */
  border-width: 10px;
  /* border-style опреляет стиль границы:
  solid отображает одну прямую сплошную линию, 
  dotted отображает ряд из точек,
  dashed отображает линию с помощью чёрточек,
  double отображает две прямые линии, которые в сумме соответствуют размеру пикселя, определяемому border-width,
  none убирает отображение границы.
  Очень редко используемые значения: groove, inset, outset, ridge. Они просто играются со светом/размером. */
  border-style: solid;
  /* border-color опреляет цвет границы. */
  border-color: red; 

  /* Все вышесказанные значения можно перечислить в свойстве border, просто перечислив их пробелом. */
  border: 10px solid red;

  /*С помощью border-right, border-left, border-top и border-bottom можно менять правые, левые, верхние и нижние стороны границы. */
  border-right: none;
  /* Ко всем им применяются те же свойства, что и к border. */
  border-right-style: none;
  border-bottom-width: 20px;
  border-left-color: blue;

  /* outline делает тоже самое, что и border, но не участвует в блочной модели и не влияет на размеры элемента и её можно задать только со всех сторон. */
  outline: 10px solid aqua;
}

/* Когда кнопка или поле input находяться в фокусе, то обводяться голубой обводкой. */
button:focus,
input:focus {
  outline: 2px solid aqua;
}

h1 {
  /* text-shadow нужно для определения тени у текста. 
  1 значение - горизонтальное смещение (то, насколько она будет смещена вправо относительно текста. Отрицательные числа перенесут тень на левую сторону.) ; 
  2 значение - вертикальное смещение (то, насколько она будет смещена вниз относительно текста. Отрицательные числа перенесут тень вверх.);
  3 значение - степень размытости;
  4 значение - цвет тени. */
  /* Можно применять множественные тени, перечисляя их через запятую. */
  text-shadow: 1px 2px 5px red, -1px -2px 5px green;
}

.shadow {
  /* box-shadow нужно для определения тени у элементов. 
  1 значение - горизонтальное смещение (то, насколько она будет смещена вправо относительно текста. Отрицательные числа перенесут тень на левую сторону.);
  2 значение - вертикальное смещение (то, насколько она будет смещена вниз относительно текста. Отрицательные числа перенесут тень вверх.);
  3 значение - степень размытости;
  4 значение - цвет тени.
  Если есть значение inset, то тень будет отрисована внутри элемента и получиться эффект "вдавленности". */
  box-shadow: 1px 2px 5px blue inset, -1px -2px 5px aqua inset;
}


/* СКРУГЛЕНИЕ УГЛОВ, СПИСКИ И ЦВЕТА. https://www.youtube.com/watch?v=zaJh6CymejM&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=13 */


.example {

  /* border-radius нужен для скругления углов прямоугольника. Его значения это то, насколько сильно они будут скруглены (значения применяются для каждого угла: 
  1 значение - к левому верхнему углу;
  2 значение - к правому верхнему углу;
  3 значение - к правому нижнему углу;
  4 значение - к левому нижнему углу. ). */
  border-radius: 50px 40px 30px 20px; 

  /* Если задать свойства таким образом, то 1 значение задаёт радиус по горизонтали, а 2 значение по вертикали. */
  border-radius: 20px/40px; 

  /* Если нужно по отдельности работать с каждым из углов, то можно применять отдельные свойства. */
  border-top-left-radius: 50px;
  border-top-right-radius: 40px;
  border-bottom-right-radius: 30px;
  border-bottom-left-radius: 20px;
}

/* Свойства для списков */
ul li {
  /* С помощью list-style-type определяем маркер списка. 
  Значение disc задаёт черную точку. 
  Значение circle задаёт небольшой круг (посередине ничего). 
  Значение square задаёт чёрный квадрат.
  Значение decimal задаёт цифры, вместо маркеров. 
  Значения upper-alpha и lower-alpha задают буквы, вместо маркеров (отличаются тем, каким регистром будут написаны буквы).
  Значения upper-roman и lower-roman задают римские цифры, вместо маркеров (отличаются тем, каким регистром будут написаны буквы).
  Значение decimal-leading-zero задаёт цифры, которые будут начинаться с нуля, вместо маркеров.
  Значение none скрывает любые маркеры в списке. */
  list-style-type: decimal-leading-zero;
  /* Свойство list-style-position принимает значения outside и inside.
  При outside маркеры списка находяться за пределами границы элемента.
  При inside маркеры списка находяться внутри границы элемента. */
  list-style-position: inside;
  /* С помощью list-style-image можно вместо маркера сделать изображения передав путь или ссылку. */
  list-style-image: url(https://image.flaticon.com/icons/png/128/66/66738.png); 
}

h1 {
  /* Цвет можно задать с помощью слова. */
  color: red; 
  /* Или с помощью HEX кода. */
  color: #ff0000; 
  /* Чёрный цвет с помощью HEX кода. */
  color: #000;
  /* Белый цвет с помощью HEX кода. */
  color: #fff;
  /* Или с помощью rgb кода. */
  color: rgb(255, 0, 0); 
  /* Или с помощью hsl кода (значения это: оттенок, насыщенность, освещённость). */
  color: hsl(0, 100%, 50%);
  /* Или с помощью rgba. "a" на конце обозначает альфа-канал (непрозрачность). 
  4 значением применяется аргументом, который делает текст более прозрачным (чем меньше цифра, тем прозрачнее текст). 
  Значение можно указать от 0 до 1.
  0 - полная прозрачность.
  1 - полная непрозрачность. */
  color: rgba(255, 0, 0, 0.5);
}


/* ОТОБРАЖЕНИЕ ЭЛЕМЕНТОВ, ВЕНДОРНЫЕ ПРЕФИКСЫ. https://www.youtube.com/watch?v=pyBjcMRLMoQ&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=14 */


/* display: none предназначен для того, чтобы полностью убрать элемент на странице. 
Оно полностью убирает элемент на странице и он никак не отображается.
Он не виден для поисковых систем. */
.first {
  display: none
}

/* visibility: hidden предназначен для того, чтобы скрыть текст элемента на странице.
Оно не убирает элемент, а лишь скрывает текст в нём. Сам элемент можно увидеть, наведя на него в панели разработчика. 
Он виден для поисковых систем. */
.second {
  visibility: hidden;
}

/* opacity: 0 делает текст полностью прозрачным и убирает элемент со страницы. */
.third {
  opacity: 0;
}

/* Вендорные префиксы - префиксы, для отображения элемента в определённых браузерах.
Каждый браузер — это отдельный вендор (от англ. vendor — продавец) услуг просмотра сайтов, интернета. Отсюда и слово «вендорный».
Если свойство с вендорным префиксом, значит что оно работает в тестовом режиме.
Чтобы узнать какое свойство, в каком браузере не используется (чтобы ставить префикс этого браузера у этого свойства) нужно использовать https://caniuse.com/ */
.example {
  /* -webkit- для Chrome. */
  -webkit-opacity: 0.5;
  /* -moz- для Firefox. */
  -moz-opacity: 0.5;
  /* -ms- для браузеров Microsoft. */
  -ms-opacity: 0.5;
  /* -o- для Opera. */
  -o-opacity: 0.5;
  /* И в конце указывается само свойство. */
  opacity: 0.5;
}

div { 
  background-image: url("image.png");
  background-image: -webkit-image-set(url("image.png") 1x, url("image-2x.png") 2x);
  background-image: image-set("image.png" 1x, "image-2x.png" 2x);
  /* Сначала браузер прочитает свойство background-image со значением url(), которое он точно понимает. 
  Потом увидит такое же свойство с другим значением, и если он его поймёт, то забудет первое свойство и применит второе. Это называется фолбэк.
  Но браузер на этом не остановится и пойдёт дальше: если он поддерживает значение без префикса, то он предпочтёт его — ведь оно последнее. 
  Поэтому порядок следования свойств с префиксами в значениях тоже важен: 
  сначала идут значения с префиксами, потом — без, чтобы браузеры выбрали последний, максимально современный вариант. */
}


/* ФОН. https://www.youtube.com/watch?v=5k-x7FUnDuE&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=15 */


.background {
  /* Чтобы фон занимал всю ширину и высоту экрана. */
  height: 100vh;
  width: 100%;

  /* background-color задаёт определённый цвет фону. */
  background-color: gainsboro;
  /* background-image задаёт картинку, как фоновое изображения элемента.
  Если картинка слишком большая для элемента, то автоматически обрезается под его размеры. */
  background-image: url(https://images.pexels.com/photos/691571/pexels-photo-691571.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260);
  /* background-size определяет размер фонового изображения и принимает как точные значения так и специальные слова: 
  contain - делает так, чтобы изображение само подстраивалось под ширину и высоту экрана. И если оно слишком маленькое, то дублируется;
  cover - заставляет ширину и высоту изображения соответствовать ширине и высоте элемента.*/
  background-size: cover;
  /* Можно жёстко задать размеры изображения и тогда оно сожмётся и будет дублироваться на странице. */
  background-size: 100px 200px;
  /* Чтобы изображение не дублировалось на странице нужно воспользоваться свойством background-repeat: no-repeat. */
  background-repeat: no-repeat;
  /* Чтобы изображение дублировалось только по горизонтали используют background-repeat: repeat-x */
  background-repeat: repeat-x;
  /* Чтобы изображение дублировалось только по вертикали используют background-repeat: repeat-y */
  background-repeat: repeat-y;
  /* Ключевое слово auto делает, так чтобы сторона считалась автоматически в зависимости от пропорций картинки. */
  background-size: auto 300px;
  /* Чтобы управлять позицией картинки нужно использовать свойство background-position.
  Например, значение right bottom помещает картинку в правый нижний угол. 
  Первое значение принимает горизонтальную позицию (right, left, center), а второе вертикальную позицию (top, bottom, center). */
  background-position: right bottom;
  /* Для определения горизонтальной позиции картинки также можно использовать свойство background-position-x. */
  background-position-x: left;
  /* Для определения вертикальной позиции картинки также можно использовать свойство background-position-y. */
  background-position-y: top;
  /* Также можно в background-position указывать проценты или пиксели. Например, 50% 50% изменит позицию картинки в середину экрана. */
  background-position: 50% 50%;
  /* background-attachment: fixed делает так, чтобы картинка была всегда на одном месте. 
  И даже когда пользователь скроллит страницу, картинка всегда будет посередине экрана. */
  background-attachment: fixed; 

  /* Все описанные выше свойства можно указать в одном свойстве background.
  Сначала идёт цвет, потом ссылка на картинку, позиция, повторение и положение. Можно указывать не все свойства. */
  background: red
  url(https://seeklogo.com/images/C/css3-logo-8724075274-seeklogo.com.png)
  50% 50% no-repeat fixed;
  /* Можно создавать множественные фоновые изображения, перечисляя их url и свойства (необязательно) через запятую. 
  Добавление картинок идёт с конца, т.е сначала добавится картинка леса (вторая), а потом на эту картинку леса добавится логотип CSS (первая указанная картинка). */
  background: url(https://seeklogo.com/images/C/css3-logo-8724075274-seeklogo.com.png)
      center no-repeat,
    url(https://images.pexels.com/photos/691571/pexels-photo-691571.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260);
}


/* ГРАДИЕНТЫ. https://www.youtube.com/watch?v=8mzap9y6ECE&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=16 */


.wrapper {

  /* Чтобы создать градиент используется свойство background-image или просто background. */
  /* Далее прописывается значение linear-gradient, в который передаётся угол наклона (выражается в deg), начальный и далее конечный цвет градиента. */
  background-image: linear-gradient(90deg, white, black); 
  /* Чтобы указать то, куда будет распространятся градиент нужно указать ключевое слово "to" и после него писать направление.
  Значение transparent создаёт прозрачный цвет. */
  background: linear-gradient(to top right, white, transparent); 
  /* Чтобы создать градиент из нескольких цветов нужно просто указать соответсвующие цвета через запятую. */
  background-image: linear-gradient(45deg, red, orange, yellow, green, aqua, blue); 
  /* Также, около цветов можно указать процент, того когда один цвет перейдёт в другой.
  То, где находяться градиенты - это отрезок, где проценты выступают в качестве длины отрезка.
  Если установить один градиент 50%, который переходит в другой на 50%, то будет жёсткий неплавный переход.
  Красный переходит в оранжевый на 10%, оранжевый переходит в жёлтый на 50% (оранжевый занимает самую большую территорию 40%), жёлтый переходит в зелёный на 70%. */
  background-image: linear-gradient(45deg, red 10%, orange 50%, yellow 70%, green, aqua, blue); 

  /* Вместо процентов можно использовать пиксели, но отрезок будет равен не 100, а будет подстраиваться под размер страницы. */
  /* repeating-linear-gradient делает, так чтобы цвет повторялся по всему экрану, пока не заполнит его полностью. 
  Т.е мы описали часть градиента до 75px, а потом сказали, что он должен повторяться. */
  background-image: repeating-linear-gradient(45deg, yellow 25px, black 25px, black 50px, yellow 50px, yellow 75px, black 75px);

  /* Функция radial-gradient() создает изображение, состоящее из постепенного перехода между двумя или более цветами, которые исходят из источника. 
  Его форма может быть кругом или эллипсом. */
  background-image: radial-gradient(aqua, red);
  /* Первым аргументом можно указать как будет выглядеть градиент: ellipse или circle. */
  background-image: radial-gradient(ellipse, aqua, red);
  /* Чтобы указать размер градиента используют одно из ключевых слов, которые пишутся после определения формы: 
  closest-side - распространение градиента идёт из центра до ближайшей стороны;
  closest-corner - распространение градиента идёт из центра до ближайшего угла;
  farthest-side - распространение градиента идёт из центра до самой дальней стороны;
  farthest-corner - распространение градиента идёт из центра до самого дальнего угла. */
  background-image: radial-gradient(ellipse closest-side, aqua, red);
  /* Для radial-gradient можно задать значение распространения с помощью процентов и тогда переход автоматически становиться жёстким. */
  background-image: radial-gradient(circle, aqua 80%, red 20%);
  /* Используя repeating-radial-gradient() можно сделать градиент, который будет повторяться, пока не заполнит всю страницу. */
  background-image: repeating-radial-gradient(circle, aqua 20%, red 80%);
  /* Также, вместо процентов можно использовать пиксели. */
  background-image: repeating-radial-gradient(circle, aqua 20px, red 80px);
}


/* ФИЛЬТРЫ. https://www.youtube.com/watch?v=k-qqZ7rcy-E&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=17 */


body {
  padding: 0;
  margin: 0;
  height: 100vh;
  /* display: flex делает, так чтобы блочные элементы занимали не всю строку, а место, которое занимает их контент. 
  Т.е элемент растягивается или сжимается для заполнения собой пустого пространства. */
  display: flex;
  /* justify-content: center делает так, чтобы все элементы в body находились в центре страницы (распределяет пространство между элементами содержимого). 
  https://developer.mozilla.org/en-US/docs/Web/CSS/justify-content */
  justify-content: center;
  /* align-items: center делает, так чтобы элементы занимали не всю строку, а место, которое занимает их контент и находились в центре страницы 
  (выравнивание элементов по поперечной оси).
  https://developer.mozilla.org/en-US/docs/Web/CSS/align-items */
  align-items: center;
}

img {
  /* transition делает переход между двумя состояниями элемента (здесь transition нужен для плавного перехода). 
  all - значит, что переход применяется ко всем элементам (в нашем случае ко всем элементам img);
  1s - переход длиться одну секунду;
  ease - указывает, что переход начинается медленно, резко ускоряется, а затем постепенно замедляется к концу. */
  transition: all 1s ease;
}

/* Чтобы добавить треугольник к блоку с текстом, используют следующую конструкцию: */
.block::after {
  content: ''; 
  position: absolute; /* Абсолютное позиционирование */
  left: 20px; bottom: -20px; /* Положение треугольника */
  border: 10px solid transparent; /* Прозрачные границы */
  border-top: 10px solid green; /* Добавляем треугольник */
 }

img:hover {
  /* Добавление фильтра осуществляется свойством filter. */ 

  /* Чтобы добавить блюр используем значение blur(). Размытие изображения происходит на величину этих пикселей. */
  filter: blur(2px); 
  /* Чтобы создать тень у картинки можно использовать значение drop-shadow. Оно принимает те же аргументы, что и box-shadow, кроме inset и множественных теней. */
  filter: drop-shadow(5px 6px 4px rgba(0, 0, 0, 0.5));
  /* Чтобы сделать изображения чёрно-белым используют значение grayscale(). 
  Аргументы, которые передаются в него ввиде процентов - это то, насколько сильно будет обезцвециваться картинка. */
  filter: grayscale(80%);
  /* Чтобы сделать изображение более тусклым или более ярким используют brightness().
  Аргументы, которые передаются ввиде процентов - это то, насколько яркая будет картинка (от -50% до 150%). */
  filter: brightness(150%); 
  /* Чтобы придать изображению контрастность используют contrast().
  Аргументы, которые передаются ввиде процентов - это то, насколько контрастная будет картинка (от -50% до 150%). */
  filter: contrast(150%); 
  /* hue-rotate() меняет цветовую палитру изображения так, что она меняется на противоположную в RGB круге. 
  Т.е если у нас жёлтая картинка, то она станет зелёной, т.к в RGB круге жёлтый цвет смотрит на зелёный.
  В это значение передаются градусы, которые обозначают то, на какой цвет будет смотреть цвет картинки на RGB круге. */
  filter: hue-rotate(180deg);
  /* Чтобы инвертировать изображение используется значение invert().
  В него передаются проценты от 0 до 100, в зависимости от того, насколько будет инвертировано изображение. */
  filter: invert(100%);
  /* Чтобы сделать изображение более насыщенным используется значение saturate().
  В него передаются проценты от 0 до бесконечности, в зависимости от того, насколько будет насыщенно изображение. */
  filter: saturate(165%);
  /* Чтобы сделать изображение более "старым" используется значение sepia().
  В него передаются проценты от 0 до 100, в зависимости от того, насколько будет "старым" изображение. */
  filter: sepia(100%);
  /* Чтобы сделать изображение прозрачным используется значение opacity().
  В него передаются проценты от 0(полная прозрачность) до 100(полная непрозрачность). */
  filter: opacity(50%);
  /* Так как можно создавать собственные фильтры с помощью svg, то можно передать значение url(), куда будет помещена ссылка на ваш фильтр. */
  filter: url(#toSvg);
  /* Фильтры можно комбинировать, указывая несколько значений в свойстве filter. */
  filter: blur(2px) brightness(150%);
}


/* ТРАНСФОРМАЦИИ. https://www.youtube.com/watch?v=vbdw3iHzkFo&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=18 */


/* К трансформациям можно отнести: вращение, увеличение или уменьшение размеров, перемещение и наклон.
При трансформации, формируется новый поток для элемента и соседние элементы никак не реагируют на трансформацию элемента.
Т.е если элемент, к примеру, увеличиться, то все соседние элементы остануться на своих местах. */

img {
  /* Свойство transform-origin задает опорную точку для трансформации элемента. Опорная точка - это точка, относительно которой будет изменяться элемент. 
  В качестве аргументов можно использовать ключевые слова right, left, top, bottom. */
  transform-origin: left top;
  /* Также, в качестве аргументов можно использовать пиксели или проценты:
  1 аргумент - ось x, 2 аргумент - ось y. 
  Тогда отсчёт начинается с левого верхнего угла элемента (т.е при значениях "0 0" картинка будет изменяться относительно него). */
  /* В данном примере, опорная точка переместится на 50px вправо и на 100px вниз от левого верхнего угла элемента. */
  transform-origin: 50px 100px;
}

img:hover {
  /* Все трансформации задаются с помощью свойства transform. */
  /* Указав значение rotate() элемент начнёт вращаться. 
  Это значение принимает градусы в качестве аргумента - это то, насколько будет повернут элемент.
  Можно задавать отрицательные числа, чтобы делать поворот в обратную сторону. */
  transform: rotate(360deg);
  /* Чтобы увеличить или уменьшить элемент используется значение scale().
  В качестве аргумента ему передаётся цифры - это называется коэффицентом масштабирования. Если передадим, к примеру 2, то элемент увеличиться в 2 раза.
  От 0 до 1 - уменьшение элемента, больше 1 - увеличение. */
  transform: scale(1.2);
  /* Также, в scale() можно указать два аргумента - масштабирование по оси x и по оси y. */
  transform: scale(0.2, 1.2);
  /* Также, есть отдельные значение scaleX для масштабирования по оси x и scaleY для масштабирования по оси y. */
  transform: scaleX(0.2);
  /* Но эти два свойства нету смысла использовать в одном коде, т.к они взаимо исключают друг друга.
  Т.е применяется то свойство, которое идёт ниже в коде и если нужно увеличить/уменьшить элемент и по оси x и по оси y, то используется scale() с двумя аргументами. */
  transform: scaleY(1.2);
  /* Чтобы переместить элемент используют значение translate. 
  (При перемещении, перемещается только сам элемент, а блок, в котором он нвходиться - нет.)
  Оно принимает 2 значения - перемещение по оси x и перемещение по оси y.
  Положительные значение - это вправо и вниз.
  Отрицательные значение - это влево и вверх. */
  transform: translate(-50px, -80px);
  /* Также, есть отдельные значение translateX для перемещения по оси x и translateY для перемещения по оси y. */
  transform: translateX(50px);
  /* Но эти два свойства нету смысла использовать в одном коде, т.к они взаимо исключают друг друга.
  Т.е применяется то свойство, которое идёт ниже в коде и если нужно переместить элемент и по оси x и по оси y, то используется translate() с двумя аргументами. */
  transform: translateY(80px);
  /* Чтобы сделать элементу наклон, используют значение skew.
  Оно принимает 2 значения (градусы или 0, если наклон не нужен) - наклон по оси x и наклон по оси y. */
  transform: skew(0, 45deg);
  /* Чтобы наклонить элемент только по оси x используют свойство skewX(). */
  transform: skewX(45deg);
  /* Чтобы наклонить элемент только по оси y используют свойство skewY(). */
  transform: skewY(45deg);
  /* В свойстве transform можно указать несколько различных значений. */
  transform: rotate(10deg) scale(1.2) skew(10deg);
}

/* ПРИКОЛЬНАЯ ФИЧА */

/* Если картинке сделать увеличение при наведение на неё курсора (с помощью псевдоэлемента hover). */
img:hover {
  transform: scale(1.5);
}

/* А блоку, в котором находиться картинка сделать overflow: hidden (он обрезает то, что выходит за пределы блока), 
то при наведение курсора на картинку, она как бы увеличиться "вглубь".*/
.wrapper {
  overflow: hidden;
}


/* ПЛАВНЫЕ ПЕРЕХОДЫ. https://www.youtube.com/watch?v=hwWIm6DSSoE&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=19 */


.example {

  /* С помощью transition-duration можно задать то, сколько будет длиться переход (определяется в секундах или милисекундах). */
  transition-duration: 500ms;
  /* С помощью transition-property мы определяем какие конкретно свойства элемента должны определять плавный переход.
  Нужно написать свойства через запятую или воспользоваться ключевым словом all (чтобы все свойства элемента имели плавный переход). 
  transition-property может принимать и одно и несколько значений. */
  transition-property: transform, background-color;
  /*Так как в прошлом transition-duration мы указали только одно значение, то переходы и transform и background-color будут занимать 500 милисекунд.
  Но в transition-duration можно указать несколько значений (учитывая, сколько значений передано в transition-property).
  И теперь переход transform будет занимать 500 милисекунд, а переход background-color будет занимать 2 секунды. */
  transition-duration: 500ms, 2s;
  /* С помощью transition-delay можно задать определённое время до начала перехода.
  Т.е первое значение это 0, значит переход transform сработает через 0 секунд после наведения курсора на элемент (т.к стоит hover).
  А переход background-color сработает только через 10 секунд после наведения курсора на элемент (т.к передано второе значение - 10s). */
  transition-delay: 0, 10s;
  /* Свойство transition-timing-function определяет, как будет распределяться скорость перехода по времени.
  Принимает значения: 
  ease - начало перехода медленное, к середине скорость повышается, к концу опять замедляется.
  ease-in - начало перехода медленное, к концу идёт ускорение.
  ease-out - начало перехода быстрое, к концу идёт замедление.
  ease-in-out - начало и конец перехода медленные.
  linear - скорость перехода одинаковая во всех частях.
  step-start - переход происходит моментально.
  step-end - По истечению заданного времени, происходит моментальный переход.
  steps() - переход происходит ступенчато. Передаются два аргумента: 
  Первый - количество шагов, за которое должен произойти переход;
  Второй - start (переход начинается в начале первого шага) или end (переход начинается в конце первого шага).
  cubic-bezier() - функция, которая помогает создать свою собственную анимацию на основании кривых Бизье. 
  Чем круче линия, тем быстрее происходит анимация.
  https://matthewlein.com/tools/ceaser - сайт для создания своей анимации на основе кривых Бизье */
  transition-timing-function: ease; 
  /* Все выше описанные свойства можно записать в одном свойстве transition.
  1 значение - transition-property;
  2 значение - transition-duration;
  3 значение - transition-timing-function
  4 значение - transition-delay. */
  transition: all 1s ease .5s;
}


/* АНИМАЦИИ. https://www.youtube.com/watch?v=XG5JulRHSV8&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=20 */


/* Анимации отличаются от переходов тем, что переходы анимируют процесс перехода одного набора свойств в другие, 
а анимации анимируют процесс перехода одного набора свойств в другие, потом во вторые, третьи и тд. */
.example {
  border: 2px solid black;
  width: 200px;
  height: 200px;
  background-color: aqua;

  /* В свойстве animation-name передаётся имя анимации, которая будет применяться к элементу. */
  animation-name: myAnimation;
  /* В свойстве animation-duration передаётся время, которое определяет сколько будет длиться функция. */
  animation-duration: 5s;
  /* Свойство animation-timing-function определяет, как будет распределяться скорость перехода по времени.
    Принимает значения: 
    ease - начало перехода медленное, к середине скорость повышается, к концу опять замедляется.
    ease-in - начало перехода медленное, к концу идёт ускорение.
    ease-out - начало перехода быстрое, к концу идёт замедление.
    ease-in-out - начало и конец перехода медленные.
    linear - скорость перехода одинаковая во всех частях.
    step-start - переход происходит моментально.
    step-end - По истечению заданного времени, происходит моментальный переход.
    steps() - переход происходит ступенчато. Передаются два аргумента: 
    Первый - количество шагов, за которое должен произойти переход;
    Второй - start (переход начинается в начале первого шага) или end (переход начинается в конце первого шага).
    cubic-bezier() - функция, которая помогает создать свою собственную анимацию на основании кривых Бизье. 
    Чем круче линия, тем быстрее происходит анимация.
    https://matthewlein.com/tools/ceaser - сайт для создания своей анимации на основе кривых Бизье */
  animation-timing-function: linear;
  /* В свойстве animation-iteration-count передаётся число, которое обозначает то, сколько раз будет запущена анимация до автоматической остановки. 
  Также, можно передать значение infinite для бесконечной анимации. */
  animation-iteration-count: infinite;
  /* Свойство animation-direction (чтобы анимация шла не просто от from до to) принимает значения: 
  normal - все повторы анимации будут воспроизводиться в нормальном направлении;
  alternate - каждый нечётный повтор цикла в анимации будет идти в нормальном направлении, а каждый чётный будет идти в обратном направление;
  reverse - все повторы анимации будут воспроизводиться в обратном направлении;
  alternate-reverse - каждый чётный повтор цикла в анимации будет идти в нормальном направлении, а каждый нечётный будет идти в обратном направление. */
  animation-direction: reverse;
  /* animation-fill-mode: forwards нужно, чтобы по окончанию анимации, не возращать элемент к первоначальным свойствам, а оставить те, которые были на конце анимации. */
  animation-fill-mode: forwards;
  /* В свойстве animation-delay (задержка) передаётся время, которое определяет через сколько запуститься новый повтор цикла анимации. */
  animation-delay: 3s; 

  /* Все выше описаннык свойства можно описать в свойстве animation, в которое передаётся: 
  animation-name, animation-duration, animation-timing-function, animation-delay, animation-iteration-count, animation-direction, animation-fill-mode. 
  Но необязательно передавать все эти значения. */
  animation: bgChange 5s linear infinite;

  /* Также, к одному элементу можно применять сразу несколько анимаций (множественные анимации). 
  Для этого нужно просто перечислить их через запятую с нужными свойствами. */
  animation: bgChange 8s 3, sizeChange 5s linear infinite;
}

.example:hover {
  /* Свойсво animation-play-state принимает значения running и paused, чтобы либо запустить, либо остановить анимацию. */
  animation-play-state: paused;
}

/* Чтобы создать анимацию указываем директиву @keyframes и даём название анимации. */
@keyframes bgChange {
  /* Ключевое слово from определяет начальный кадр. */
  from { 
    background-color: aqua; 
  }
  /* Проценты это то, как будет меняться анимация по мере своего произведения. При 50% она меняется на середине. */
  50% { 
    background-color: red;
  }
  /* Ключевое слово to определяет заключительный кадр. */
  to { 
    background-color: green;
  }
}

/* Также, применима такая форма записи. */
@keyframes sizeChange {
  from { transform: scale(1); }
  30% { transform: scale(1.2); }
  50% { transform: scale(1.4); }
  /* Чтобы цикличная анимация была плавной, нужно в конечном кадре присваивать ей свойства, которые были в начале. */
  to { transform: scale(1); }
}


/* ТАБЛИЦЫ И КУРСОР. https://www.youtube.com/watch?v=Y5MwssNWetI&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=21 */


/* Также, к таблицам можно применить отступы, скругления углов, цвета фона и контента, градиенты и тд. */
table,
/* Звёздочка после table, нужна для того, чтобы свойства применялись ко всем дочерним элементам элемента. */
table * {
  /* max-width чтобы её сильно таблицу не растягивало. */
  max-width: 600px;
  border: 1px solid black;
  /* Свойство border-collapse нужно для того, чтобы не было двойной обводки и прочей херни с обводками. Принимает значения: 
  collapse - объединяет обводки, которые находяться рядом в одну. 
  separate - значение по умолчанию и каждый элемент разделяется отдельной обводкой. */
  border-collapse: separate;
  /* Свойство border-spacing принимает значение/значения, которые означают расстояния между обводками (ячейками и тд).
  Первое значение отвечает за расстояние по горизонтали, а второе - за расстояние по вертикали. */
  border-spacing: 10px 50px; 
  /* Свойство caption-side нужно для того, чтобы определять положение заголовка в таблице в строке. 
  Принимает 2 значения - top (заголовок вверху таблицы) и bottom (заголовок снизу таблицы). */
  caption-side: top;
  /* Свойство text-align нужно для горизонтального центрирования текста. Принимает значения: 
    left - выравнивает контент по левому краю элемента;
    right - выравнивает контент по правому краю элемента;
    center - выравнивает контент по центру элемента. */
  text-align: right;
  /* Свойство vertical-align нужно для вертикального центрирования текста. Принимает значения: 
    baseline - будут занимать позицию исходя из своих дефолтных настроек (если не задано другого) внутри их родительского элемента.;
    bottom - выравнивает контент по нижней границе элемента;
    top - выравнивает контент по верхней границе элемента;
    middle - выравнивает контент по центру элемента;
    sub - выравнивает контент так, как будто он подстрочный;
    text-bottom - выравнивает нижнюю границу элемента по самому нижнему краю текущей строки;
    text-top - выравнивает границу элемента по самому высокому элементу текущей строки. */
  vertical-align: middle;
  /* Свойство empty-cells нужно, чтобы производить какие-либо действия с пустыми ячейками таблицы.
  Принимает 2 значения - show (дефолтное. Пустые ячейки видны) и hide (все пустые ячейки лишаются границ и фона). */
  empty-cells: hide;
  /* Свойство cursor нужно для того, чтобы изменять внешний вид курсора (когда пользователь наводит на элементы, которые являются селекторами). Принимает значения: 
  pointer - курсор становиться ввиде руки;
  crosshair - курсор будет отображаться ввиде перекрестия;
  url() - нужно чтобы сделать свой собственный курсор. В скобках передаётся путь или ссылка на картинку, которая будет использоваться вместо курсора.
  Все виды курсоров можно посмотреть на сайте https://csscursor.info/. */
  cursor: pointer;
}

.dis,
td {
  /* Свойство pointer-events позволяет контролировать то, как элементы будут контролировать на события мыши или прикосновения к сенсорному экрану.
  Значение none делает, так чтобы элементы не воспринимали никакие взаимодействия с курсором (даже копирования текста). 
  Оно нужно если нужно отключить взаимодействия пользователя и элементов интерфейса. */
  pointer-events: none;
}


/* ТЕКСТОВЫЕ ЭФФЕКТЫ И МНОГОКОЛОНОЧНЫЙ ТЕКСТ. https://www.youtube.com/watch?v=6sc-gmz_MYQ&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=22 */


.example {

  /* Свойство text-overflow нужно для того, чтобы что-то делать с текстом, который не помещается в блок. Принимает значения: 
  ellipsis - текст обрезается, и последние 3 символа этого обрезанного текста заменяются троеточием;
  clip - текст просто обрезается в конце. */
  text-overflow: ellipsis; 
  /* Свойство white-space: nowrap делает так, чтобы текст не переносился на новые строки. */
  white-space: nowrap; 
  /* Свойство word-wrap: break-word делает так, чтобы слова переносились на новые строки, если не влезают в блок 
  (но на новой строке может оказаться всего одна буква из-за особенностей переноса). */
  word-wrap: break-word;
  /* Свойство word-break показывает то, как должно переноситься слово на новую строку. 
  Если задать значение break-all, то все слова будут разбиваться в конце строки посимвольно (тоже самое, что и word-wrap: break-word, как я понял). */
  word-break: break-all;
  /* Свойство writing-mode определяет то, какой будет способ написания текста. 
  Например, значение vertical-rl перевёрнет текст так, чтобы он был написан справа снизу вверх.*/
  writing-mode: vertical-rl;
}

.container {
  /*Свойство column-count применяется к блочным элементам.
  Они занимают всю строку, но мы можем контролировать это.
  С помощью этого свойства можно задать количество колонок на которое будет разбит весь текст в одной строке. */
  column-count: 3;
  /* Свойство column-rule разделяет колонки с помощью линии между ними. Принимает теже самые значения, что и свойство border. */
  column-rule: 1px solid black;
  /* Свойство column-width задаёт ширину колонок. 
  Это свойство, при узком экране (если колонкам не хватает места) может даже сделать текст одноколоночным, не взирая на свойство column-count. */
  column-width: 300px;
  /* Свойство column-gap определяет расстояние между колонками. */
  column-gap: 100px;
}


/* МЕДИАЗАПРОСЫ. https://www.youtube.com/watch?v=lv47xClJolw&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=23 */


/* Медиазапросы нужны, чтобы страница одинаково хорошо отображалась на всех устройствах. */
/* Чтобы скрывать определённые элементы на телефоне (у кого разрешение экрана 350px). screen значит, что контент предназначается только для экранов. */

/* Сначала нужно использовать директиву @media.
Далее, описываем набор правил и пишем слово, которое проверяет то, на каких устройстваз будут проверяться правила. Значения:
screen - проверка на то, что правила будут проверяться только на устройствах с экраном;
print - проверка на то, что правила будут проверяться только на принтерах или в режиме предварительного просмотра перед печатью;
speech - проверка на то, что правила будут проверяться только на скринридерах;
all - дефолтное значение. Правила будут проверяться на всех устройствах. */
@media print {
  /* Сюда пишем свойства, которые применяться, только в том случае, если выполняться заданные условия 
  (в нашем случае, если устройство - это принтер или пользователь находиться в режиме предварительного просмотра перед печатью). */
  body {
    color: blue;
  }
}

/* Правила могут разделяться 3 операторами: 
and - требуется выполнение всех указанных условий;
, - требуется выполнение хотя-бы одного из указанных условий (местный or);
not - отрицание указанного условия. */
/* Здесь происходит проверка на то, что сайт открыт на устройстве с дисплеем и имеет максимальную ширина экрана равна 350px.
То что указано в скобках называется медиафункцией. 
Есть такие значений, которые можно указать в медиафункции: width, height, min-width, min-height, max-width, max-height и ещё некоторые.
Т.е можно задать использование определённых свойств в зависимости от разрешения экрана. */
@media screen and (max-width:350px) {
  .object {
      display: none; 
  }
}

/* Здесь происходит проверка на то, что сайт открыт на устройстве с дисплеем и ширина экрана находиться в пределах 992-1200px. */
@media screen and (min-width: 992px) and (max-width: 1200px) {
  body {
    background-color: aqua;
  }
}

/* Медиафункция orientation помогает определить в каком из двух режимов находиться функция. Принимает значения: 
landscape - горизонтальный режим устройства (когда ширина больше высоты);
portrait - вертикальный режим устройства (когда высота больше ширины). */
@media screen and (orientation: portrait) {
  /* Убираем заголовок h1. */
  h1 {
    display: none;
  }
}

/* Медиафункция device-aspect-radio помогает указать то, как ширина устройства относиться к его высоте. 
В качестве единиц измерения принимаются только целые числа. */
@media screen and (device-aspect-radio: 16/9) {
  body {
    background-color: green;
  }
}

/* Медиафункция min-resolution помогает указывает плотность пикселей устройства вывода.
В качестве единиц измерения принимаются dppx (относится к количеству пикселей, содержащихся в одном дюйме изображения, отображенного на мониторе компьютера)
или dpi (относится к количеству точек, содержащихся в одном дюйме изображения, распечатанного принтером на бумаге). */
/* Здесь свойства применяются к экранам, имеющим высокую плотность пикселей. */
@media screen and (min-resolution: 2dppx) {
  body {
    background-color: green;
  }
}


/* СТИЛИЗАЦИЯ ПЛЕЙСХОЛДЕРА И СКРОЛЛА, CSS-СПРАЙТЫ. https://www.youtube.com/watch?v=_eO1urQ71Lw&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=24 */


/* Если применить свойства к input, то свойства изменяться только у текста, который вводит пользователь (или который находиться в поле ввода), но не у плейсхолдера. */
input {
  font-size: 24px;
  padding: 5px 10px;

  color: red;
}

/* Следующие 3 селектора нужны для стилилизации плейсхолдера. 
Они могут применять одни свойства, т.к разные селектора нужны для разных браузеров. */

/* Значение ::placeholder применяет свойства к плейсхолдеру у всех современных браузеров (Chrome, Firefox, Opera, Safari 10.1+). */
::placeholder {
  color: blue;
  /* opacity: 1 применяется только у браузера Firefox. */
  opacity: 1; 
}

/* Данная конструкция используется для изменения плейсхолдера в браузере Edge. */
::-ms-input-placeholder {
  color: blue;
}

/* Данная конструкция используется для изменения плейсхолдера в браузере Internet Explorer 10-11. */
:-ms-input-placeholder {
  color: blue;
}

/* СТИЛИЛИЗИРОВАТЬ ТАКИЕ INPUT ЭЛЕМЕНТЫ, КАК КАЛЕНДАРЬ ИЛИ ВРЕМЯ МОЖНО ТОЛЬКО ЕСЛИ ВОССОЗДАТЬ ИХ С НУЛЯ С ПОМОЩЬЮ JS. */

/* Стилилизация скролла в каждом браузере специфична, поэтому тут мы стилилизуем скролл для Chrome (используем вендорный префикс ::-webkit). */
/* Свойство scrollbar стилилизует именно место, которое отводиться для полосы прокрутки скролла. */
::-webkit-scrollbar {
  width: 25px;
  background: #101124;
}

/* Свойство scrollbar-track стилилизует именно подложку, которая идёт под ползунком. */
::-webkit-scrollbar-track {
  border: 5px solid rgba(255, 255, 255, 0.25);
  box-shadow: inset 0 0 2.5px 2px rgba(0, 0, 0, 0.5);
}

/* Свойство scrollbar-thumb стилилизует сам ползунок. */
::-webkit-scrollbar-thumb {
  background: linear-gradient(45deg, #00ffa1, #00ffff);
  /* border-radius для скругления углов. */
  border-radius: 15px;
}

/* Создаём CSS-спрайт (что то типа анимации с помощью простого изменения позиции картинки кнопки) для кнопки. */
/* Прикольная анимация при наведении и нажатии на кнопку с помощью изменения позиции её картинки. */
button {
  width: 200px;
  height: 79px;
  /* Определяем картинку для фона. */
  background-image: url(./23.png);
  /* Картинка будет находиться вверху. */
  background-position: top;
  /* Картинка будет подстраиваться под высоту и ширину кнопки. */
  background-size: cover;

  /* Свойства, чтобы убрать дефолтные стили кнопки. */
  /* text-indent убирает текст кнопки туда, где пользователь его не видит (за границу экрана). */
  text-indent: -9999px;
  /* Убираем дефолтную обводку в 1px. */
  border: none;
  /* Делаем дефолтный фон кнопки прозрачным. */
  background-color: transparent;
  /* Показываем, что кнопки - это элемент взаимодействия и на неё можно кликнуть. */
  cursor: pointer;
  /* Делаем серую обводку. */
  outline: grey;
}

/* Когда пользователь наводит курсор на кнопку. */
button:hover {
  background-position: center;
}

/* Когда пользователь нажимает на кнопку. */
button:active {
  background-position: bottom;
}