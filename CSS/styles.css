/* БАЗОВЫЙ СИНТАКСИС И ПРИМЕНЕНИЕ СТИЛЕЙ. https://www.youtube.com/watch?v=qxAnaoPI8cE&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=2*/
@import "main.css";
/* Импортируем файл main.css - импортируются все стили из него. */

/* h2 - это селектор, к которому применяются стили. */
h2 {
  /* Задаём свойству color значение green, чтобы цвет стал зелёным. */
  /* Несколько объявлений (определение значения для свойства) в селекторе называются блоком объявлений. */
  color: green;
  text-decoration: underline;
}


/* ПРОСТЫЕ СЕЛЕКТОРЫ. https://www.youtube.com/watch?v=vnmfn31G988&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=3 */


/* Селектор * определяет все элементы на страницы. */
* {
  color: red;
}

/* Селекторы могут быть в качестве html тегов. */
p {
  color: green;
}

/* Чаще всего селекторы определяются с помощью классов, имена которых должны начинаться с точки. */
.heading1 {
  /* Задаём свойству text-decoration значение underline, чтобы текст был подчёркнутым. */
  text-decoration: underline;
}

/* Задаём свойству text-transorm значение undercase, чтобы текст был в верхнем регистре. */
.heading2 {
  text-transform: uppercase;
}

/* Если мы хотим, чтобы стили применились только к определённым элементам (например, к тегам <p>), то перед названием класса указываем данный тег. */
p.fz20 {
  font-size: 20px;
}

/* Также можно, но НЕ НУЖНО, определять стили с помощью id элементов, которые должны начиться с #
  Селекторы, которые определяются с помощью id весят 100.  */
#heading,
#heading2 {
  font-size: 40px;
  border: 1px solid #000;
}

/* Селектор включающий в себя только тег весит 1. */
q {
  color: blue;
}

/* А селектор, который включает в себя тег q(1) и проверяет каждый тег на наличие класса simple(10) весит уже 11. */
q.simple {
  color: aqua;
}

/* Данный селектор, который включает в себя тег body(1) и тег q(1) и класс simple(10) весит 12. */
body q.simple {
  color: fuchsia;
}

/* Данный селектор, который включает в себя id: main(100), 3 класса: container, post, giga (30), 3 тега: article, header, h1 (3) равен 133.
Браузер сравнивает вес "#main .container article.post", равный 121 и вес "header h1.giga", равный 12.
И естественно, применяет стили к части "#main .container article.post".
Это нужно для того, если разработчику лень считать веса самому. */
#main .container article.post>header h1.giga {
  color: #777;
}


/* СОСТАВНЫЕ СЕЛЕКТОРЫ. https://www.youtube.com/watch?v=fyI_K_Oya74&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=4 */


/* ЛУЧШЕ И БЫСТРЕЕ ИСПОЛЬЗОВАТЬ КЛАССЫ, А ЭТО ПРОСТО ЗНАТЬ ДЛЯ ОБЩЕГО РАЗВИТИЯ. */

/* Составные селекторы можно сделать путём перечисления простых селекторов через запятую. */
h1,
h2,
span {
  color: red;
}

/* Тег <p> является потомком тега <div> и стили определяются только для этого <p>. */
div p {
  color: green;
}

/* Здесь тег <p> является потомком тега <div>, но также является родителем для тега <span> и стили определяются именно для <span>. */
div p span {
  color: blue;
}

/* Если мы хотим указать, что стилизируемый элемент должен быть потомком другого без каких-либо доп.вложений, 
то между тегом родителя (ul li) и тегом потомка (span) ставиться знак < 
(Чтобы перед span были только теги ul li, без каких либо других.) */
ul li>span {
  font-weight: bold;
}

/* В данном примере все элементы, которые идут после первого li окрашиваются в голубой.
Т.к мы складываем элементы li, и получается 2 li, значит все li элементы со второго li окрашиваются в голубой.  */
ul li+li {
  color: aqua;
}

/* С помощью знака ~ (тильда) разделяются основной элемент и те, которые будут стилилизоваться.
Т.е ко всем элементы <p>, идущим после тега <br> стилилизуются. */
br~p {
  font-size: 30px;
}

/* Стилилизуем элементы <a>, у которых есть атрибут target. */
a[target] {
  background-color: yellow;
}

/* Стилилизуем элементы <a>, у которых есть значение атрибута target равно "_blank". */
a[target="_blank"] {
  background-color: blue;
}

/* Если перед знаком "=" поставить знак "^", то проверяются элементы <a>, у которых атрибут href начинается с "http://123" */
a[href^="http://123"] {
  background-color: aqua;
}

/* Если перед знаком "=" поставить знак "$", то проверяются элементы <a>, у которых атрибут href в конце имеет ".jpg",
то есть проверка начинается с конца. */
a[href$=".jpg"] {
  background-color: teal;
}

/* Если перед знаком "=" поставить знак "*", то проверяются элементы <a>, у которых атрибут href ИМЕЕТ "link" (то есть link может находиться в любой части строки). */
a[href*="link"] {
  background-color: rebeccapurple;
}


/* ПСЕВДОЭЛЕМЕНТЫ И ПСЕВДОКЛАССЫ. https://www.youtube.com/watch?v=C40ePbYJxmM&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=5 */


/* Псевдокласс в CSS — это ключевое слово, добавленное к селектору, которое определяет его особое состояние. */
a {
  color: black;
  /* Значение none у свойства text-decoration убирает подчёркивания и прочее у текста. */
  text-decoration: none;
}

/* Перед псевдоклассами ставиться двоеточие. Псевдоклассы стоят после селектора. */
/* Псевдокласс hover может быть использован для изменения цвета кнопки при наведении курсора на неё. */
a:hover {
  color: red;
}

/* Псевдокласс visited может быть использован для изменения цвета кнопки, если ресурс данной ссылки был посещён ранее. */
a:visited {
  color: aqua;
}

/* Псевдокласс active может быть использован для изменения цвета кнопки, если нажать на ссылку мышкой, но не отжимать клавишу (зажимаем, а не нажимаем 1 раз). */
a:active {
  color: green;
}

/* Псевдокласс focus может быть использован для изменения цвета кнопки, если пользователь перемещается по странице с помощью кнопки Tab 
(нажатие на Tab и элементу, на котором стоит фокус применяются стили). */
a:focus {
  /* Значение bold у свойства font-weight устанавливает насыщенность шрифта. bold — полужирное начертание */
  font-weight: bold;
}

/*Псевдоэлемент — это дополнение к селектору, с помощью которого можно стилизовать элемент, не определённый в структуре HTML документа. 
Добавляется он к селектору c помощью символов :: */
/* Псевдоэлемент применяет стили к первой букве элементов p (в нашем случае). */
p::first-letter {
  font-size: 40px;
}

/* Псевдоэлемент применяет стили к первой строке элементов p (в нашем случае). */
p::first-line {
  text-decoration: underline;
}

/* Псевдоэлемент selection позволяет применить стили к части документа, который был выделен пользователем (например, с помощью мыши).
selection поддерживает только изменение фона и цвета. */
p::selection {
  background-color: yellow;
  color: red;
}

/*Псевдоэлементы before и after позволяют показать на веб-странице что-то, что может отсутствовать в HTML-контенте. */
/*Псевдоэлемент before, в данном примере, добавляет перед текстом элемента h1 фразу "This is " в верхнем регистре. */
h1::before {
  content: "This is ";
  text-transform: uppercase;
}

/*Псевдоэлемент after, в данном примере, добавляет после текста элемента h1 фразу " channel" красного цвета. */
h1::after {
  content: " channel";
  color: red;
}

/*Псевдоэлементы для списков. */
/*Определяем класс list1 и тег li, который будет определяться, как "элемент списка" и потом определяем псевдоэлемент first-child, который применяет стили к первому элементу списка. */
.list1 li:first-child {
  color: blue;
}

/*Определяем класс list1 и тег li, который будет определяться, как "элемент списка" и потом определяем псевдоэлемент last-child, 
который применяет стили к последнему элементу списка. */
.list1 li:last-child {
  color: green;
}

/*Определяем класс list2 и тег li, который будет определяться, как "элемент списка" и потом определяем псевдоэлемент nth-child(even), 
который применяет стили к каждому чётному элементу списка. */
.list2 li:nth-child(even) {
  color: blue;
}

/*Определяем класс list2 и тег li, который будет определяться, как "элемент списка" и потом определяем псевдоэлемент nth-child(odd), 
который применяет стили к каждому нечётному элементу списка. */
.list2 li:nth-child(odd) {
  color: green;
}

/*Определяем класс list3 и тег li, который будет определяться, как "элемент списка" и потом определяем псевдоэлемент nth-child(индекс элемента), 
который применяет стили к элементу, индекс которого указан в скобках. */
.list3 li:nth-child(2) {
  color: blue;
}

/*Определяем класс list3 и тег li, который будет определяться, как "элемент списка" и потом определяем псевдоэлемент nth-child(уравнение), 
который применяет стили к каждому 3-ему элементу начиная с 1 включительно. */
.list3 li:nth-child(3n + 1) {
  text-transform: uppercase;
}

/*Определяем класс list3 и тег li, который будет определяться, как "элемент списка" и потом определяем псевдоэлемент nth-child(уравнение), 
который применяет стили к каждому 4-ему элементу начиная с 2 включительно. */
.list3 li:nth-child(4n + 2) {
  /* Добавляем чёрную рамку в 1 пиксель. */
  border: 1px solid black;
}

/* Определяем класс list4 и тег li, который будет определяться, как "элемент списка" и потом определяем псевдоэлемент not(название класса), 
который применяет стили к элементам, которые не имеют класса, указанного в скобках.
not(.item) равен 1 (вес псевдоэлемента, а не псевдоэлемента + класса, в нём) */
.list4 li:not(.item) {
  border: 1px solid blue;
}

/* Определяем класс text и тег span, который будет определяться, как "элемент списка" и потом определяем псевдоэлемент first-of-type, 
который применяет стили к первому дочернему элементу. */
.text span:first-of-type {
  color: red;
}

/* Определяем класс text и тег span, который будет определяться, как "элемент списка" и потом определяем псевдоэлемент last-of-type, 
который применяет стили к последнему дочернему элементу. */
.text span:last-of-type {
  color: green;
}

/* Определяем класс text и тег span, который будет определяться, как "элемент списка" и потом определяем псевдоэлемент nth-of-type(индекс элемента), 
который применяет стили к дочернему элементу, индекс которого определён в скобочках. */
.text span:nth-of-type(2) {
  border: 1px solid black;
}


/* КАСКАДНОСТЬ И НАСЛЕДОВАНИЕ. https://www.youtube.com/watch?v=Y8UFzOoKkvQ&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=6 */


/* ЗДЕСЬ, КОГДА Я ГОВОРЮ, ЧТО ПРИМЕНЯЮТСЯ СТИЛИ ТОГО ИЛИ ИНОГО ЭЛЕМЕНТА, ТО ИМЕЮ ВВИДУ КОНФЛИКТНЫЕ ЭЛЕМЕНТЫ.
(т.е если в классе и id есть backround-color, то применяется background-color id, т.к вес id больше веса класса). */
/* Если селектора имеют одинаковый вес, то применяется то свойство, которое написано ниже в коде. */
/* Также, если к селектору, например тегу <p>, применены стили, но в нём определён класс, то применяются именно стили класса, а не тега, 
т.к вес класса больше веса тега (10 > 1). */
/* Тоже самое, если в теге определён класс и id, то применяются стили для id, 
т.к его вес больше чем классов (100 > 10). */
/* Точно тоже самое, если в файле css применены стили к id, но в html файле написаны inline стили, то к элементу применяются именно inline стили, 
т.к их вес больше веса id (1000 > 100). */
/* CSS правило !important дает больше значимости, чем любое другое свойство, т.е будет применяться именно зелёный цвет, а не цвет, указанный например в классе. 
Свойство, помеченное таким флагом применяется к селектору В ЛЮБОМ СЛУЧАЕ (но ладно, оно может не примениться если ниже в коде, к такому же свойству применен тоже !important). */
p {
  color: green !important;
}

/* none!important отменяет свойство у элемента (в данном случае, убирает обводку). Оно также как и !important применяется В ЛЮБОМ СЛУЧАЕ. */
p {
  border: none !important;
}

/* В CSS есть свойства, которые наследуются (т.е те, которые появяться у всех элементов в теге <body>) а есть те, которые не наследуются (т.е появяться только у тега <body>). */
body {
  /* Например, красным окраситься весь текст, который есть в тегах <body>. */
  color: red;
  /* А рамка появиться только у тега <body>. */
  border: 1px solid black;
  /* Увеличенный отступ в 30px появиться только у <body>. */
  margin-bottom: 30px;
}

p {
  /* Так как, в теге <body> у нас находиться теги <p>, то он и будет здесь селектором. 
  В свойства border мы пишем значение inherit, чтобы свойство границы было унаследовано у селектора <body>, который написан выше. */
  border: inherit;
  /* Если тут указать значение inherit, то <p> также, унаследует значение margin, которые было в <body>. */
  margin: inherit;
}

/* Не стоит забывать про то, что у браузера есть свои собственные стили (например, ссылка, которая окрашивается в синий цвет). */
/* Есть два подхода, чтобы стили сайта отображались одинаково на любом браузере - CSS normalize или CSS reset. 
Оба этих подхода - всего лишь css файлы со своими стилями, которые нужно подключить перед css файлом разработчика. */
/* CSS Normilize делает стили для каждого из браузеров примерно одинаковыми.
А CSS Reset обнуляет стили для каждого из браузеров, чтобы разработчик писал стили "с полного нуля". */
/* Можно использовать CSS Reset и CSS Normilize в паре при разных ситуациях 
(если бесит синий цвет ссылок, то используем CSS Reset, а если хотим, чтобы теги везде одинаково отображались, то используем CSS Normilize). */


/* БЛОЧНАЯ МОДЕЛЬ И ОТСТУПЫ. https://www.youtube.com/watch?v=1jvIi039-i4&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=7*/


/* Блочный элемент (например, обёрнутый в тег <div>) занимает всю строку экрана, а строчный элемент занимает место по размеру текста в нём (например, обёрнутый в тег <span>). */
span,
div {
  /* Обводка, чтобы видеть размер элемента */
  border: 10px solid red;
  /* padding создаёт пространство между содержимом тега (текстом) и его границей. */
  padding: 10px;
  /* margin создаёт пространство между содержимым тега (текста) и содержимыми других тегов. Это пространство создаётся за границей, которую создаёт padding. */
  margin: 10px;
  /* В padding можно передать значения, которые определяются как отступы между содержимого тега и его границей:
  отступ сверху - 10 px
  отступ справа - 20 px.
  отступ снизу - 30 px.
  отступ слева - 40 px. */
  padding: 10px 20px 30px 40px;
  /* В margin можно передать значения, которые определяются как отступы, отделяемые один тег от другого.
  Если значения сверху и снизу, и справа и слева одинаковы, то можно записать так, передав только 2 значения, и значит:
  отступ сверху и снизу - 10 px
  отступ справа и слева - 20 px. */
  margin: 10px 20px;
  /* С помощью padding-top (для margin - margin-top, но он не работает для строчных элементов) создать отступ сверху. */
  padding-top: 10px;
  /* С помощью padding-right (для margin - margin-right) создать отступ справа. */
  padding-right: 20px;
  /* С помощью padding-bottom (для margin - margin-bottom, но он не работает для строчных элементов) создать отступ снизу. */
  padding-bottom: 30px;
  /* С помощью padding-left (для margin - margin-left) создать отступ слева. */
  padding-left: 40px;
}

/* Также, если 2 элемента с разныи margin стоят рядом, то расстояние между ними будет равно значению большего margin (это называется схлопывание margin`ов). */


/* Есть элемент <div> (который делает блочный элемент) с классом test, но с помощью значения inline свойства display можно сделать его строчным. */
.test {
  display: inline;
}

/* Указав значение block у свойства display, мы можем сделать элемент блочным. */
.test {
  display: block;
}

/* Указав значение inline-block у свойства display, мы можем сделать элемент строчно-блочным. Тогда этот элемент будет иметь свойства обоих типов, но не их ограничения. */
.test {
  display: inline-block;
}

/* Свойства width и height не применяются для строчных элементов. */
span {
  width: 100px;
  height: 100px;
}

.mar {
  margin-top: 50px;
  /* Свойства width и height не меняют размер текста, а создают пространство для контента, написанный в тегах. */
  width: 100px;
  height: 100px;
  display: inline-block;
  /* При значении content-box свойства box-sizing, width и height применяются к области контента, а сами границы расширяются.
  При значении border-box свойства box-sizing, width и height применяются ко всей области всего элемента,
  От этого, область для контента уменьшается (т.к нужно ещё оставить пиксели для padding, margin и тд).
  Значение border-box нужно, если требуется, чтобы элемент(div) был фиксированной ширины при любых значениях padding и border.
  А ещё, если блоков много, то они переделываются на другую строчку, а при border-box они все находяться в одной строке.  */
  box-sizing: border-box;
}


/* ПОЗИЦИОНИРОВАНИЕ И РАЗМЕРЫ. https://www.youtube.com/watch?v=iydD985acAc&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=9 */


/* Поток описывает, как элементы располагаются относительно друг друга. 
По умолчанию родственные элементы находятся в одном потоке и их расположение на странице статично; порядок появления элементов на странице такой же, как и в коде. 
С помощью CSS можно перемещать элементы в отдельные потоки. Это дает больше возможностей для дизайна страницы и контроля схемы размещения элементов над кодом.*/

/* Изначально, все элементы находяться в основном потоке документа, 
но есть свойства (position), которые "вырывают" элемент из основного потока и формируют новый.  */
.test {
  /* static применяется к каждому элементу по дефолту и он остаётся в основном потоке документа. */
  position: static;
  /* relative создаёт новый поток для элемента и теперь мы можем управлять его положением.
  ПРИ RELATIVE ОТСЧЁТ ПОЗИЦИИ СОВЕРШАЕТСЯ ОТНОСИТЕЛЬНО ПРОШЛОЙ ПОЗИЦИИ ЭЛЕМЕНТА, А НЕ ДОКУМЕНТА.
  Если изменять элемент с помощью position: relative, то соседние элементы останутся на своих местах и никак на это не отрагируют.  */
  position: relative;
  /* top, right, bottom, left - это свойства для position.
  top говорит, оттолкнись от вверха на 20 px (т.е вниз на 20px) */
  top: 20px;
  /* right говорит, оттолкнись от права на 20 px (т.е влево на 20px) */
  right: 20px;
  /* bottom говорит, оттолкнись от низа на 20 px (т.е вверх на 20px) */
  bottom: 20px;
  /* left говорит, оттолкнись от лева на 20 px (т.е вправо на 20px) */
  left: 20px;
  /* absolute делает так, что основной поток теряет связь с элементом и его место в тексте заполняется.
  ПРИ ABSOLUTE ОТСЧЁТ ПОЗИЦИИ ЭЛЕМЕНТА СОВЕРШАЕТСЯ ОТНОСИТЕЛЬНО ДОКУМЕНТА (т.е от края окна страницы). */
  /* НО если у элемента есть родитель, у которого position отличается от static, то элемент позициионируется относительно краёв его родителя. */
  position: absolute;
  /* fixed делает так, чтобы позиция элемента ВСЕГДА отсчитывалась от края окна страницы. */
  position: fixed;
  /* sticky делает так, чтобы позиция элемента остаётся в своём блоке (как обычно).
  НО когда "потолок" страницы доходит до этого элемента (во время прокрутки), то он начинает ползти вниз до пола своего блока. */
  position: sticky;
  /* Когда разработчик задаёт width и height, то элемент никогда не подстроиться под контент и его размер всегда будет постоянным. */
  /* Но при свойствах min-width и min-height исходный блок растягивается под контент (если контент не вмещяется в этот блок).
  Но если контента нет или он меньше 100 px, то блок так и останеться равным 100px. */
  min-width: 100px;
  min-height: 100px;
  /* Свойства max-width и max-height задают максимальную ширину/высоту, на которую элемент способен измениться (растянуться). */
  max-width: 500px;
  max-height: 500 px
}


/* ЕДИНИЦЫ, ПЕРЕПОЛНЕНИЕ И УРОВНИ ЭЛЕМЕНТОВ. https://www.youtube.com/watch?v=pEdt0afL2-o&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=9 */


/* px - это абсолютная величина (это всегда одинаковая) */
.main {
  font-size: 40px;
}

/* % - это относительная величина (изменяется от того, какой размер текста у родителя) 
Здесь берётся 80% от размера предыдущего пункта в списке.
А первый пункт будет размера, равному 80% от абсолютного размера данного тега. */
li {
  font-size: 80%;
}

/* em - это относительная величина, которая увеличивается в 2 раза, в зависимости от  размера родителя (её количество - сколько раз перемножать). */
li {
  font-size: 2em;
}

/* rem - это относительная величина, которая своё количество (тут 2) умножает на дефолтный размер текста в браузере. */
li {
  font-size: 2rem;
}

/* селектор html изменяет стили для всего, только с помощью него можно изменять стили, которые по дефолту стоят в браузере. */
html {
  font-size: 2rem;
}

/* overlay - это штука, которая "затемняет" задний фон, когда на сайте появляется новое окно. */
.overlay {
  background-color: rgba(0, 0, 0, 0.5);
  color: white;
  position: absolute;
  /*vw и vh - это как бы "проценты" заполненности всего экрана устройства (также полностью заполняется для мобильных устройств и тд). */
  width: 100vw;
  height: 100vh;
  top: 0;
  left: 0;
  /* С помощью calc можно производить вычисления для размеров. */
  width: calc(100px + 200px + 1rem);

  /* z-index - это число, которое определяет уровень элемента. 
  Т.е допустим, есть два окна в одной позиции, и 2 окно перекрывает 1, т.к находиться ниже в коде.
  Но если, у первого окна поставить z-index=2, а у 2 окна он по дефолту равен 0 (но, это можно изменить с помощью z-index), 
  то теперь 1 окно будет перекрывать 2.
  z-index может принимать отрицательные значения, чтобы окно было ПОД основными. */
  z-index: 1;
}

.modal {
  border: 2px solid black;
  width: 300px;
  height: 100px;
  background-color: cornflowerblue;
  font-size: 20px;
  color: white;
  position: absolute;
  /* overflow - это свойство, если текст не помещается в блок. */
  /* Значение auto создаёт ползунок в блоке (если текст в него не поместился), чтобы можно было листать её и видеть текст, который находиться ниже. */
  overflow: auto;
  /* Значение scroll также, как и auto создаёт ползунок в блоке, но создаёт его в любом случае, даже если текст поместился в блок. */
  overflow: scroll;
  /* Значение hidden жёстко обрезает текст, который не поместился в блок. */
  overflow: hidden;
  /* overflow-y принимает те же самые значения, что и overflow, но применяет эти свойства только для вертикального направления элемента. */
  overflow-y: auto;
  /* overflow-x принимает те же самые значения, что и overflow, но применяет эти свойства только для горизонтального направления элемента. */
  overflow-x: scroll;
}


/* ПЛАВАЮЩИЕ ЭЛЕМЕНТЫ И ОЧИСТКА ПОТОКА. https://www.youtube.com/watch?v=1kZ9FTp2IiE&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=10 */


.item {
  /* float вырывает документ из основного потока документа и формирует для него новый. А это значит, что другие элементы перестают его видеть. */
  /* при использовании float, элемент на котором мы его используем, изменит свой размер под размер своего контента,
  а следующий элемент изменит своё положение, станет вплотную к первому элементу. 
  Если сделать float:right для 3 элемента, то он просто изменит своё положение в правую сторону и изменит свой размер под контент. */
  /* Если же 1 элементу сделать float:left, а 2 элементу float:right,
  то 1 элемент будет слева, 3 элемент между ними (но будет находиться под ними и перекрываться ими, он занял их место), а 2 элемент справа. */
  /* В html разметке, сначала идёт левый элемент, потом правый и уже потом, то что между ними. */
  /* float можно задать и строчным элементам, но они начнут ввести себя, как блоки. */
  /* Если float элементы не влезают в строку, то будут перенесены на следующую. */
  float: left;
  width: 150px;
}


/* Штука, чтобы заставлять элемент родителя "расхлопываться" (чтобы в нём были float элементы и они не перекрывали основной контент). */
.clearfix:after {
  /* Если задавать float какому-либо элементу, то нужно указать clearfix для родителя. */
  content: "";
  display: block;
  /* сlear: both означает, 
  что в рамках одного блочного отформатированного контекста обе стороны элемента 
  не могут примыкать к элементам, к которым ранее применено float.
  Если вкратце, то она очищает обтекание, чтобы float элементы находились в родительском блоке. */
  clear: both;
  /* clear:left делает очистку слева. */
  clear: left;
  /* clear:right делает очистку справа. */
  clear: right;
  /* clear:none отменяет очистку. */
  clear: none;
}


/* ШРИФТЫ И ТЕКСТ. https://www.youtube.com/watch?v=TAB8pVUKiI4&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=11 */


h1 {
  /* font-family определяет приоритетный список из одного или нескольких названий семейства шрифтов и/или общее имя шрифта для выбранного элемента. */
  /* serif - чтобы шрифт был с засечками, а sans-serif без засечек.  
  Это нужно, если на компьютере не будет указанного шрифта, то взялся бы любой с засечками или без. */
  /* Сначала, в кавычках, указываем шрифт, который будет использоваться,
  Потом шрифты, которые будут использоваться если того шрифта не будет на устройстве, 
  И потом, указываем то будет ли шрифт с засечками или без, если ни одного из указанных шрифтов нету на устройстве. */
  font-family: "Roboto", Arial, Helvetica, sans-serif;
}


/* Чтобы взять шрифты из Google fonts - https://fonts.google.com/, нужно в HTML документ вставить ссылку на шрифт: 
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@100;500;900&display=swap" rel="stylesheet"> */
/* А в CSS документе определить шрифты: */
body {
  font-family: "Roboto", sans-serif;
  /* font-size определяет размер шрифта. */
  font-size: 100px;
  /* А font-weight определяет толщину шрифта. */
  font-weight: 100px;
  /* font-style определяет стиль написания шрифта (тут курсив). */
  font-style: italic;
}

/* Чтобы подключить локальный шрифт на страницу, указывается специальная директива @font-face*/
@font-face {
  /* Где указываем имя шрифта, */
  font-family: "Roboto";
  /* Путь до файла со шрифтом,
  Для лучшей кроусбраузерности, наш один шрифт нужно определить в несколько форматов с разными расширениями. */
  src: url("/fonts/Roboto-Regular.ttf") format("truetype"),
    url("/fonts/Roboto-Regular.woff") format("woff"),
    url("/fonts/Roboto-Regular.woff2") format("woff2"),
    url("/fonts/Roboto-Regular.otf") format("opentype");
  /* Толщину шрифта, */
  font-weight: 500;
  /* Начертание шрифта, */
  font-variant: normal;
  /* узкое, нормальное или широкое начертание шрифта, */
  font-stretch: wider;
  /* И его стиль написания. */
  font-style: normal;
}

/* Если хотим подключить ещё один стиль, делаем те же самые действия. */
@font-face {
  font-family: "RobotoBoldItalic";
  src: url("/fonts/Roboto-BoldItalic.ttf") format("truetype"),
    url("/fonts/Roboto-BoldItalic.woff") format("woff"),
    url("/fonts/Roboto-BoldItalic.woff2") format("woff2"),
    url("/fonts/Roboto-BoldItalic.otf") format("opentype");
  font-weight: 900;
  font-style: italic;
}

h1 {
  /* С помощью свойства color, тексту можно задать цвет. */
  color: blueviolet;
  /* text-decoration задаёт варианты подчёркивания текста: 
  underline - подчёркивание снизу; 
  overline - подчёркивание сверху;
  line-through - перечёркивание;
  none - убирает подчёркивание. */
  text-decoration: underline overline line-through none;
  /* letter-spacing задаёт расстояние между символами. */
  letter-spacing: 2px;
  /* word-spacing задаёт расстояние между словами. */
  word-spacing: 10px;
  /* line-height задаёт расстояние между строчками. */
  line-height: 100px;
  /* text-transform помогает трансформировать текст: 
  uppercase - все символы в теге трансформируются в верхний регистр. 
  lowercase - все символы в теге трансформируются в нижний регистр. 
  capitalize - каждый первый символ любого слова в теге будет писаться с большой буквы.
  none - отмена любых ранее применённых текстовых трансформаций. */
  text-transform: capitalize;
  /* text-align выравнивает текст по: 
  right - правому краю,
  left - левому краю,
  center - центру,
  justify - левому и правому краю, растягивая предложения в середине. */
  text-align: justify;
  /* text-indent задаёт отступ в начале текста (красная строка). 
  В этом свойстве нужно указывать размер отступа. */
  text-indent: 20px;
}


/* ГРАНИЦЫ И ТЕНИ. https://www.youtube.com/watch?v=dAHu16pgBrg&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=12 */


.example {
  /* border находиться между padding и margin (border - это обводка элемента). */
  /* border-width задаёт толщину обводки. */
  border-width: 10px;
  /* border-style опреляет стиль границы:
  solid отображает одну прямую сплошную линию, 
  dotted отображает ряд из точек,
  dashed отображает линию с помощью чёрточек,
  double отображает две прямые линии, которые в сумме соответствуют размеру пикселя, определяемому border-width,
  none убирает отображение границы.
  Очень редко используемые значения: groove, inset, outset, ridge. Они просто играются со светом/размером. */
  border-style: solid;
  /* border-color опреляет цвет границы. */
  border-color: red;

  /* Все вышесказанные значения можно перечислить в свойстве border, просто перечислив их пробелом. */
  border: 10px solid red;

  /*С помощью border-right, border-left, border-top и border-bottom можно менять правые, левые, верхние и нижние стороны границы. */
  border-right: none;
  /* Ко всем им применяются те же свойства, что и к border. */
  border-right-style: none;
  border-bottom-width: 20px;
  border-left-color: blue;

  /* outline делает тоже самое, что и border, но не участвует в блочной модели и не влияет на размеры элемента и её можно задать только со всех сторон. */
  outline: 10px solid aqua;
}

/* Когда кнопка или поле input находяться в фокусе, то обводяться голубой обводкой. */
button:focus,
input:focus {
  outline: 2px solid aqua;
}

h1 {
  /* text-shadow нужно для определения тени у текста. 
  1 значение - горизонтальное смещение (то, насколько она будет смещена вправо относительно текста. Отрицательные числа перенесут тень на левую сторону.) ; 
  2 значение - вертикальное смещение (то, насколько она будет смещена вниз относительно текста. Отрицательные числа перенесут тень вверх.);
  3 значение - степень размытости;
  4 значение - цвет тени. */
  /* Можно применять множественные тени, перечисляя их через запятую. */
  text-shadow: 1px 2px 5px red, -1px -2px 5px green;
}

.shadow {
  /* box-shadow нужно для определения тени у элементов. 
  1 значение - горизонтальное смещение (то, насколько она будет смещена вправо относительно текста. Отрицательные числа перенесут тень на левую сторону.);
  2 значение - вертикальное смещение (то, насколько она будет смещена вниз относительно текста. Отрицательные числа перенесут тень вверх.);
  3 значение - степень размытости;
  4 значение - цвет тени.
  Если есть значение inset, то тень будет отрисована внутри элемента и получиться эффект "вдавленности". */
  box-shadow: 1px 2px 5px blue inset, -1px -2px 5px aqua inset;
}


/* СКРУГЛЕНИЕ УГЛОВ, СПИСКИ И ЦВЕТА. https://www.youtube.com/watch?v=zaJh6CymejM&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=13 */


.example {

  /* border-radius нужен для скругления углов прямоугольника. Его значения это то, насколько сильно они будут скруглены (значения применяются для каждого угла: 
  1 значение - к левому верхнему углу;
  2 значение - к правому верхнему углу;
  3 значение - к правому нижнему углу;
  4 значение - к левому нижнему углу. ). */
  border-radius: 50px 40px 30px 20px;

  /* Если задать свойства таким образом, то 1 значение задаёт радиус по горизонтали, а 2 значение по вертикали. */
  border-radius: 20px/40px;

  /* Если нужно по отдельности работать с каждым из углов, то можно применять отдельные свойства. */
  border-top-left-radius: 50px;
  border-top-right-radius: 40px;
  border-bottom-right-radius: 30px;
  border-bottom-left-radius: 20px;
}

/* Свойства для списков */
ul li {
  /* С помощью list-style-type определяем маркер списка. 
  Значение disc задаёт черную точку. 
  Значение circle задаёт небольшой круг (посередине ничего). 
  Значение square задаёт чёрный квадрат.
  Значение decimal задаёт цифры, вместо маркеров. 
  Значения upper-alpha и lower-alpha задают буквы, вместо маркеров (отличаются тем, каким регистром будут написаны буквы).
  Значения upper-roman и lower-roman задают римские цифры, вместо маркеров (отличаются тем, каким регистром будут написаны буквы).
  Значение decimal-leading-zero задаёт цифры, которые будут начинаться с нуля, вместо маркеров.
  Значение none скрывает любые маркеры в списке. */
  list-style-type: decimal-leading-zero;
  /* Свойство list-style-position принимает значения outside и inside.
  При outside маркеры списка находяться за пределами границы элемента.
  При inside маркеры списка находяться внутри границы элемента. */
  list-style-position: inside;
  /* С помощью list-style-image можно вместо маркера сделать изображения передав путь или ссылку. */
  list-style-image: url(https://image.flaticon.com/icons/png/128/66/66738.png);
}

h1 {
  /* Цвет можно задать с помощью слова. */
  color: red;
  /* Или с помощью HEX кода. */
  color: #ff0000;
  /* Чёрный цвет с помощью HEX кода. */
  color: #000;
  /* Белый цвет с помощью HEX кода. */
  color: #fff;
  /* Или с помощью rgb кода. */
  color: rgb(255, 0, 0);
  /* Или с помощью hsl кода (значения это: оттенок, насыщенность, освещённость). */
  color: hsl(0, 100%, 50%);
  /* Или с помощью rgba. "a" на конце обозначает альфа-канал (непрозрачность). 
  4 значением применяется аргументом, который делает текст более прозрачным (чем меньше цифра, тем прозрачнее текст). 
  Значение можно указать от 0 до 1.
  0 - полная прозрачность.
  1 - полная непрозрачность. */
  color: rgba(255, 0, 0, 0.5);
}


/* ОТОБРАЖЕНИЕ ЭЛЕМЕНТОВ, ВЕНДОРНЫЕ ПРЕФИКСЫ. https://www.youtube.com/watch?v=pyBjcMRLMoQ&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=14 */


/* display: none предназначен для того, чтобы полностью убрать элемент на странице. 
Оно полностью убирает элемент на странице и он никак не отображается.
Он не виден для поисковых систем. */
.first {
  display: none
}

/* visibility: hidden предназначен для того, чтобы скрыть текст элемента на странице.
Оно не убирает элемент, а лишь скрывает текст в нём. Сам элемент можно увидеть, наведя на него в панели разработчика. 
Он виден для поисковых систем. */
.second {
  visibility: hidden;
}

/* opacity: 0 делает текст полностью прозрачным и убирает элемент со страницы. */
.third {
  opacity: 0;
}

/* Вендорные префиксы - префиксы, для отображения элемента в определённых браузерах.
Каждый браузер — это отдельный вендор (от англ. vendor — продавец) услуг просмотра сайтов, интернета. Отсюда и слово «вендорный».
Если свойство с вендорным префиксом, значит что оно работает в тестовом режиме.
Чтобы узнать какое свойство, в каком браузере не используется (чтобы ставить префикс этого браузера у этого свойства) нужно использовать https://caniuse.com/ */
.example {
  /* -webkit- для Chrome. */
  -webkit-opacity: 0.5;
  /* -moz- для Firefox. */
  -moz-opacity: 0.5;
  /* -ms- для браузеров Microsoft. */
  -ms-opacity: 0.5;
  /* -o- для Opera. */
  -o-opacity: 0.5;
  /* И в конце указывается само свойство. */
  opacity: 0.5;
}

div {
  background-image: url("image.png");
  background-image: -webkit-image-set(url("image.png") 1x, url("image-2x.png") 2x);
  background-image: image-set("image.png" 1x, "image-2x.png" 2x);
  /* Сначала браузер прочитает свойство background-image со значением url(), которое он точно понимает. 
  Потом увидит такое же свойство с другим значением, и если он его поймёт, то забудет первое свойство и применит второе. Это называется фолбэк.
  Но браузер на этом не остановится и пойдёт дальше: если он поддерживает значение без префикса, то он предпочтёт его — ведь оно последнее. 
  Поэтому порядок следования свойств с префиксами в значениях тоже важен: 
  сначала идут значения с префиксами, потом — без, чтобы браузеры выбрали последний, максимально современный вариант. */
}


/* ФОН. https://www.youtube.com/watch?v=5k-x7FUnDuE&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=15 */


.background {
  /* Чтобы фон занимал всю ширину и высоту экрана. */
  height: 100vh;
  width: 100%;

  /* background-color задаёт определённый цвет фону. */
  background-color: gainsboro;
  /* background-image задаёт картинку, как фоновое изображения элемента.
  Если картинка слишком большая для элемента, то автоматически обрезается под его размеры. */
  background-image: url(https://images.pexels.com/photos/691571/pexels-photo-691571.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260);
  /* background-size определяет размер фонового изображения и принимает как точные значения так и специальные слова: 
  contain - делает так, чтобы изображение само подстраивалось под ширину и высоту экрана. И если оно слишком маленькое, то дублируется;
  cover - заставляет ширину и высоту изображения соответствовать ширине и высоте элемента.*/
  background-size: cover;
  /* Можно жёстко задать размеры изображения и тогда оно сожмётся и будет дублироваться на странице. */
  background-size: 100px 200px;
  /* Чтобы изображение не дублировалось на странице нужно воспользоваться свойством background-repeat: no-repeat. */
  background-repeat: no-repeat;
  /* Чтобы изображение дублировалось только по горизонтали используют background-repeat: repeat-x */
  background-repeat: repeat-x;
  /* Чтобы изображение дублировалось только по вертикали используют background-repeat: repeat-y */
  background-repeat: repeat-y;
  /* Ключевое слово auto делает, так чтобы сторона считалась автоматически в зависимости от пропорций картинки. */
  background-size: auto 300px;
  /* Чтобы управлять позицией картинки нужно использовать свойство background-position.
  Например, значение right bottom помещает картинку в правый нижний угол. 
  Первое значение принимает горизонтальную позицию (right, left, center), а второе вертикальную позицию (top, bottom, center). */
  background-position: right bottom;
  /* Для определения горизонтальной позиции картинки также можно использовать свойство background-position-x. */
  background-position-x: left;
  /* Для определения вертикальной позиции картинки также можно использовать свойство background-position-y. */
  background-position-y: top;
  /* Также можно в background-position указывать проценты или пиксели. Например, 50% 50% изменит позицию картинки в середину экрана. */
  background-position: 50% 50%;
  /* background-attachment: fixed делает так, чтобы картинка была всегда на одном месте. 
  И даже когда пользователь скроллит страницу, картинка всегда будет посередине экрана. */
  background-attachment: fixed;

  /* Все описанные выше свойства можно указать в одном свойстве background.
  Сначала идёт цвет, потом ссылка на картинку, позиция, повторение и положение. Можно указывать не все свойства. */
  background: red url(https://seeklogo.com/images/C/css3-logo-8724075274-seeklogo.com.png) 50% 50% no-repeat fixed;
  /* Можно создавать множественные фоновые изображения, перечисляя их url и свойства (необязательно) через запятую. 
  Добавление картинок идёт с конца, т.е сначала добавится картинка леса (вторая), а потом на эту картинку леса добавится логотип CSS (первая указанная картинка). */
  background: url(https://seeklogo.com/images/C/css3-logo-8724075274-seeklogo.com.png) center no-repeat,
    url(https://images.pexels.com/photos/691571/pexels-photo-691571.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260);
}


/* ГРАДИЕНТЫ. https://www.youtube.com/watch?v=8mzap9y6ECE&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=16 */


.wrapper {

  /* Чтобы создать градиент используется свойство background-image или просто background. */
  /* Далее прописывается значение linear-gradient, в который передаётся угол наклона (выражается в deg), начальный и далее конечный цвет градиента. */
  background-image: linear-gradient(90deg, white, black);
  /* Чтобы указать то, куда будет распространятся градиент нужно указать ключевое слово "to" и после него писать направление.
  Значение transparent создаёт прозрачный цвет. */
  background: linear-gradient(to top right, white, transparent);
  /* Чтобы создать градиент из нескольких цветов нужно просто указать соответсвующие цвета через запятую. */
  background-image: linear-gradient(45deg, red, orange, yellow, green, aqua, blue);
  /* Также, около цветов можно указать процент, того когда один цвет перейдёт в другой.
  То, где находяться градиенты - это отрезок, где проценты выступают в качестве длины отрезка.
  Если установить один градиент 50%, который переходит в другой на 50%, то будет жёсткий неплавный переход.
  Красный переходит в оранжевый на 10%, оранжевый переходит в жёлтый на 50% (оранжевый занимает самую большую территорию 40%), жёлтый переходит в зелёный на 70%. */
  background-image: linear-gradient(45deg, red 10%, orange 50%, yellow 70%, green, aqua, blue);

  /* Вместо процентов можно использовать пиксели, но отрезок будет равен не 100, а будет подстраиваться под размер страницы. */
  /* repeating-linear-gradient делает, так чтобы цвет повторялся по всему экрану, пока не заполнит его полностью. 
  Т.е мы описали часть градиента до 75px, а потом сказали, что он должен повторяться. */
  background-image: repeating-linear-gradient(45deg, yellow 25px, black 25px, black 50px, yellow 50px, yellow 75px, black 75px);

  /* Функция radial-gradient() создает изображение, состоящее из постепенного перехода между двумя или более цветами, которые исходят из источника. 
  Его форма может быть кругом или эллипсом. */
  background-image: radial-gradient(aqua, red);
  /* Первым аргументом можно указать как будет выглядеть градиент: ellipse или circle. */
  background-image: radial-gradient(ellipse, aqua, red);
  /* Чтобы указать размер градиента используют одно из ключевых слов, которые пишутся после определения формы: 
  closest-side - распространение градиента идёт из центра до ближайшей стороны;
  closest-corner - распространение градиента идёт из центра до ближайшего угла;
  farthest-side - распространение градиента идёт из центра до самой дальней стороны;
  farthest-corner - распространение градиента идёт из центра до самого дальнего угла. */
  background-image: radial-gradient(ellipse closest-side, aqua, red);
  /* Для radial-gradient можно задать значение распространения с помощью процентов и тогда переход автоматически становиться жёстким. */
  background-image: radial-gradient(circle, aqua 80%, red 20%);
  /* Используя repeating-radial-gradient() можно сделать градиент, который будет повторяться, пока не заполнит всю страницу. */
  background-image: repeating-radial-gradient(circle, aqua 20%, red 80%);
  /* Также, вместо процентов можно использовать пиксели. */
  background-image: repeating-radial-gradient(circle, aqua 20px, red 80px);
}


/* ФИЛЬТРЫ. https://www.youtube.com/watch?v=k-qqZ7rcy-E&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=17 */


body {
  padding: 0;
  margin: 0;
  height: 100vh;
  /* display: flex делает, так чтобы блочные элементы занимали не всю строку, а место, которое занимает их контент. 
  Т.е элемент растягивается или сжимается для заполнения собой пустого пространства. */
  display: flex;
  /* justify-content: center делает так, чтобы все элементы в body находились в центре страницы (распределяет пространство между элементами содержимого). 
  https://developer.mozilla.org/en-US/docs/Web/CSS/justify-content */
  justify-content: center;
  /* align-items: center делает, так чтобы элементы занимали не всю строку, а место, которое занимает их контент и находились в центре страницы 
  (выравнивание элементов по поперечной оси).
  https://developer.mozilla.org/en-US/docs/Web/CSS/align-items */
  align-items: center;
}

img {
  /* transition делает переход между двумя состояниями элемента (здесь transition нужен для плавного перехода). 
  all - значит, что переход применяется ко всем элементам (в нашем случае ко всем элементам img);
  1s - переход длиться одну секунду;
  ease - указывает, что переход начинается медленно, резко ускоряется, а затем постепенно замедляется к концу. */
  transition: all 1s ease;
}

/* Чтобы добавить треугольник к блоку с текстом, используют следующую конструкцию: */
.block::after {
  content: '';
  position: absolute;
  /* Абсолютное позиционирование */
  left: 20px;
  bottom: -20px;
  /* Положение треугольника */
  border: 10px solid transparent;
  /* Прозрачные границы */
  border-top: 10px solid green;
  /* Добавляем треугольник */
}

img:hover {
  /* Добавление фильтра осуществляется свойством filter. */

  /* Чтобы добавить блюр используем значение blur(). Размытие изображения происходит на величину этих пикселей. */
  filter: blur(2px);
  /* Чтобы создать тень у картинки можно использовать значение drop-shadow. Оно принимает те же аргументы, что и box-shadow, кроме inset и множественных теней. */
  filter: drop-shadow(5px 6px 4px rgba(0, 0, 0, 0.5));
  /* Чтобы сделать изображения чёрно-белым используют значение grayscale(). 
  Аргументы, которые передаются в него ввиде процентов - это то, насколько сильно будет обезцвециваться картинка. */
  filter: grayscale(80%);
  /* Чтобы сделать изображение более тусклым или более ярким используют brightness().
  Аргументы, которые передаются ввиде процентов - это то, насколько яркая будет картинка (от -50% до 150%). */
  filter: brightness(150%);
  /* Чтобы придать изображению контрастность используют contrast().
  Аргументы, которые передаются ввиде процентов - это то, насколько контрастная будет картинка (от -50% до 150%). */
  filter: contrast(150%);
  /* hue-rotate() меняет цветовую палитру изображения так, что она меняется на противоположную в RGB круге. 
  Т.е если у нас жёлтая картинка, то она станет зелёной, т.к в RGB круге жёлтый цвет смотрит на зелёный.
  В это значение передаются градусы, которые обозначают то, на какой цвет будет смотреть цвет картинки на RGB круге. */
  filter: hue-rotate(180deg);
  /* Чтобы инвертировать изображение используется значение invert().
  В него передаются проценты от 0 до 100, в зависимости от того, насколько будет инвертировано изображение. */
  filter: invert(100%);
  /* Чтобы сделать изображение более насыщенным используется значение saturate().
  В него передаются проценты от 0 до бесконечности, в зависимости от того, насколько будет насыщенно изображение. */
  filter: saturate(165%);
  /* Чтобы сделать изображение более "старым" используется значение sepia().
  В него передаются проценты от 0 до 100, в зависимости от того, насколько будет "старым" изображение. */
  filter: sepia(100%);
  /* Чтобы сделать изображение прозрачным используется значение opacity().
  В него передаются проценты от 0(полная прозрачность) до 100(полная непрозрачность). */
  filter: opacity(50%);
  /* Так как можно создавать собственные фильтры с помощью svg, то можно передать значение url(), куда будет помещена ссылка на ваш фильтр. */
  filter: url(#toSvg);
  /* Фильтры можно комбинировать, указывая несколько значений в свойстве filter. */
  filter: blur(2px) brightness(150%);
}


/* ТРАНСФОРМАЦИИ. https://www.youtube.com/watch?v=vbdw3iHzkFo&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=18 */


/* К трансформациям можно отнести: вращение, увеличение или уменьшение размеров, перемещение и наклон.
При трансформации, формируется новый поток для элемента и соседние элементы никак не реагируют на трансформацию элемента.
Т.е если элемент, к примеру, увеличиться, то все соседние элементы остануться на своих местах. */

img {
  /* Свойство transform-origin задает опорную точку для трансформации элемента. Опорная точка - это точка, относительно которой будет изменяться элемент. 
  В качестве аргументов можно использовать ключевые слова right, left, top, bottom. */
  transform-origin: left top;
  /* Также, в качестве аргументов можно использовать пиксели или проценты:
  1 аргумент - ось x, 2 аргумент - ось y. 
  Тогда отсчёт начинается с левого верхнего угла элемента (т.е при значениях "0 0" картинка будет изменяться относительно него). */
  /* В данном примере, опорная точка переместится на 50px вправо и на 100px вниз от левого верхнего угла элемента. */
  transform-origin: 50px 100px;
}

img:hover {
  /* Все трансформации задаются с помощью свойства transform. */
  /* Указав значение rotate() элемент начнёт вращаться. 
  Это значение принимает градусы в качестве аргумента - это то, насколько будет повернут элемент.
  Можно задавать отрицательные числа, чтобы делать поворот в обратную сторону. */
  transform: rotate(360deg);
  /* Чтобы увеличить или уменьшить элемент используется значение scale().
  В качестве аргумента ему передаётся цифры - это называется коэффицентом масштабирования. Если передадим, к примеру 2, то элемент увеличиться в 2 раза.
  От 0 до 1 - уменьшение элемента, больше 1 - увеличение. */
  transform: scale(1.2);
  /* Также, в scale() можно указать два аргумента - масштабирование по оси x и по оси y. */
  transform: scale(0.2, 1.2);
  /* Также, есть отдельные значение scaleX для масштабирования по оси x и scaleY для масштабирования по оси y. */
  transform: scaleX(0.2);
  /* Но эти два свойства нету смысла использовать в одном коде, т.к они взаимо исключают друг друга.
  Т.е применяется то свойство, которое идёт ниже в коде и если нужно увеличить/уменьшить элемент и по оси x и по оси y, то используется scale() с двумя аргументами. */
  transform: scaleY(1.2);
  /* Чтобы переместить элемент используют значение translate. 
  (При перемещении, перемещается только сам элемент, а блок, в котором он нвходиться - нет.)
  Оно принимает 2 значения - перемещение по оси x и перемещение по оси y.
  Положительные значение - это вправо и вниз.
  Отрицательные значение - это влево и вверх. */
  transform: translate(-50px, -80px);
  /* Также, есть отдельные значение translateX для перемещения по оси x и translateY для перемещения по оси y. */
  transform: translateX(50px);
  /* Но эти два свойства нету смысла использовать в одном коде, т.к они взаимо исключают друг друга.
  Т.е применяется то свойство, которое идёт ниже в коде и если нужно переместить элемент и по оси x и по оси y, то используется translate() с двумя аргументами. */
  transform: translateY(80px);
  /* Чтобы сделать элементу наклон, используют значение skew.
  Оно принимает 2 значения (градусы или 0, если наклон не нужен) - наклон по оси x и наклон по оси y. */
  transform: skew(0, 45deg);
  /* Чтобы наклонить элемент только по оси x используют свойство skewX(). */
  transform: skewX(45deg);
  /* Чтобы наклонить элемент только по оси y используют свойство skewY(). */
  transform: skewY(45deg);
  /* В свойстве transform можно указать несколько различных значений. */
  transform: rotate(10deg) scale(1.2) skew(10deg);
}

/* ПРИКОЛЬНАЯ ФИЧА */

/* Если картинке сделать увеличение при наведение на неё курсора (с помощью псевдоэлемента hover). */
img:hover {
  transform: scale(1.5);
}

/* А блоку, в котором находиться картинка сделать overflow: hidden (он обрезает то, что выходит за пределы блока), 
то при наведение курсора на картинку, она как бы увеличиться "вглубь".*/
.wrapper {
  overflow: hidden;
}


/* ПЛАВНЫЕ ПЕРЕХОДЫ. https://www.youtube.com/watch?v=hwWIm6DSSoE&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=19 */


.example {

  /* С помощью transition-duration можно задать то, сколько будет длиться переход (определяется в секундах или милисекундах). */
  transition-duration: 500ms;
  /* С помощью transition-property мы определяем какие конкретно свойства элемента должны определять плавный переход.
  Нужно написать свойства через запятую или воспользоваться ключевым словом all (чтобы все свойства элемента имели плавный переход). 
  transition-property может принимать и одно и несколько значений. */
  transition-property: transform, background-color;
  /*Так как в прошлом transition-duration мы указали только одно значение, то переходы и transform и background-color будут занимать 500 милисекунд.
  Но в transition-duration можно указать несколько значений (учитывая, сколько значений передано в transition-property).
  И теперь переход transform будет занимать 500 милисекунд, а переход background-color будет занимать 2 секунды. */
  transition-duration: 500ms, 2s;
  /* С помощью transition-delay можно задать определённое время до начала перехода.
  Т.е первое значение это 0, значит переход transform сработает через 0 секунд после наведения курсора на элемент (т.к стоит hover).
  А переход background-color сработает только через 10 секунд после наведения курсора на элемент (т.к передано второе значение - 10s). */
  transition-delay: 0, 10s;
  /* Свойство transition-timing-function определяет, как будет распределяться скорость перехода по времени.
  Принимает значения: 
  ease - начало перехода медленное, к середине скорость повышается, к концу опять замедляется.
  ease-in - начало перехода медленное, к концу идёт ускорение.
  ease-out - начало перехода быстрое, к концу идёт замедление.
  ease-in-out - начало и конец перехода медленные.
  linear - скорость перехода одинаковая во всех частях.
  step-start - переход происходит моментально.
  step-end - По истечению заданного времени, происходит моментальный переход.
  steps() - переход происходит ступенчато. Передаются два аргумента: 
  Первый - количество шагов, за которое должен произойти переход;
  Второй - start (переход начинается в начале первого шага) или end (переход начинается в конце первого шага).
  cubic-bezier() - функция, которая помогает создать свою собственную анимацию на основании кривых Бизье. 
  Чем круче линия, тем быстрее происходит анимация.
  https://matthewlein.com/tools/ceaser - сайт для создания своей анимации на основе кривых Бизье */
  transition-timing-function: ease;
  /* Все выше описанные свойства можно записать в одном свойстве transition.
  1 значение - transition-property;
  2 значение - transition-duration;
  3 значение - transition-timing-function
  4 значение - transition-delay. */
  transition: all 1s ease .5s;
}


/* АНИМАЦИИ. https://www.youtube.com/watch?v=XG5JulRHSV8&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=20 */


/* Анимации отличаются от переходов тем, что переходы анимируют процесс перехода одного набора свойств в другие, 
а анимации анимируют процесс перехода одного набора свойств в другие, потом во вторые, третьи и тд. */
.example {
  border: 2px solid black;
  width: 200px;
  height: 200px;
  background-color: aqua;

  /* В свойстве animation-name передаётся имя анимации, которая будет применяться к элементу. */
  animation-name: myAnimation;
  /* В свойстве animation-duration передаётся время, которое определяет сколько будет длиться функция. */
  animation-duration: 5s;
  /* Свойство animation-timing-function определяет, как будет распределяться скорость перехода по времени.
    Принимает значения: 
    ease - начало перехода медленное, к середине скорость повышается, к концу опять замедляется.
    ease-in - начало перехода медленное, к концу идёт ускорение.
    ease-out - начало перехода быстрое, к концу идёт замедление.
    ease-in-out - начало и конец перехода медленные.
    linear - скорость перехода одинаковая во всех частях.
    step-start - переход происходит моментально.
    step-end - По истечению заданного времени, происходит моментальный переход.
    steps() - переход происходит ступенчато. Передаются два аргумента: 
    Первый - количество шагов, за которое должен произойти переход;
    Второй - start (переход начинается в начале первого шага) или end (переход начинается в конце первого шага).
    cubic-bezier() - функция, которая помогает создать свою собственную анимацию на основании кривых Бизье. 
    Чем круче линия, тем быстрее происходит анимация.
    https://matthewlein.com/tools/ceaser - сайт для создания своей анимации на основе кривых Бизье */
  animation-timing-function: linear;
  /* В свойстве animation-iteration-count передаётся число, которое обозначает то, сколько раз будет запущена анимация до автоматической остановки. 
  Также, можно передать значение infinite для бесконечной анимации. */
  animation-iteration-count: infinite;
  /* Свойство animation-direction (чтобы анимация шла не просто от from до to) принимает значения: 
  normal - все повторы анимации будут воспроизводиться в нормальном направлении;
  alternate - каждый нечётный повтор цикла в анимации будет идти в нормальном направлении, а каждый чётный будет идти в обратном направление;
  reverse - все повторы анимации будут воспроизводиться в обратном направлении;
  alternate-reverse - каждый чётный повтор цикла в анимации будет идти в нормальном направлении, а каждый нечётный будет идти в обратном направление. */
  animation-direction: reverse;
  /* animation-fill-mode: forwards нужно, чтобы по окончанию анимации, не возращать элемент к первоначальным свойствам, а оставить те, которые были на конце анимации. */
  animation-fill-mode: forwards;
  /* В свойстве animation-delay (задержка) передаётся время, которое определяет через сколько запуститься новый повтор цикла анимации. */
  animation-delay: 3s;

  /* Все выше описаннык свойства можно описать в свойстве animation, в которое передаётся: 
  animation-name, animation-duration, animation-timing-function, animation-delay, animation-iteration-count, animation-direction, animation-fill-mode. 
  Но необязательно передавать все эти значения. */
  animation: bgChange 5s linear infinite;

  /* Также, к одному элементу можно применять сразу несколько анимаций (множественные анимации). 
  Для этого нужно просто перечислить их через запятую с нужными свойствами. */
  animation: bgChange 8s 3, sizeChange 5s linear infinite;
}

.example:hover {
  /* Свойсво animation-play-state принимает значения running и paused, чтобы либо запустить, либо остановить анимацию. */
  animation-play-state: paused;
}

/* Чтобы создать анимацию указываем директиву @keyframes и даём название анимации. */
@keyframes bgChange {

  /* Ключевое слово from определяет начальный кадр. */
  from {
    background-color: aqua;
  }

  /* Проценты это то, как будет меняться анимация по мере своего произведения. При 50% она меняется на середине. */
  50% {
    background-color: red;
  }

  /* Ключевое слово to определяет заключительный кадр. */
  to {
    background-color: green;
  }
}

/* Также, применима такая форма записи. */
@keyframes sizeChange {
  from {
    transform: scale(1);
  }

  30% {
    transform: scale(1.2);
  }

  50% {
    transform: scale(1.4);
  }

  /* Чтобы цикличная анимация была плавной, нужно в конечном кадре присваивать ей свойства, которые были в начале. */
  to {
    transform: scale(1);
  }
}


/* ТАБЛИЦЫ И КУРСОР. https://www.youtube.com/watch?v=Y5MwssNWetI&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=21 */


/* Также, к таблицам можно применить отступы, скругления углов, цвета фона и контента, градиенты и тд. */
table,
/* Звёздочка после table, нужна для того, чтобы свойства применялись ко всем дочерним элементам элемента. */
table * {
  /* max-width чтобы её сильно таблицу не растягивало. */
  max-width: 600px;
  border: 1px solid black;
  /* Свойство border-collapse нужно для того, чтобы не было двойной обводки и прочей херни с обводками. Принимает значения: 
  collapse - объединяет обводки, которые находяться рядом в одну. 
  separate - значение по умолчанию и каждый элемент разделяется отдельной обводкой. */
  border-collapse: separate;
  /* Свойство border-spacing принимает значение/значения, которые означают расстояния между обводками (ячейками и тд).
  Первое значение отвечает за расстояние по горизонтали, а второе - за расстояние по вертикали. */
  border-spacing: 10px 50px;
  /* Свойство caption-side нужно для того, чтобы определять положение заголовка в таблице в строке. 
  Принимает 2 значения - top (заголовок вверху таблицы) и bottom (заголовок снизу таблицы). */
  caption-side: top;
  /* Свойство text-align нужно для горизонтального центрирования текста. Принимает значения: 
    left - выравнивает контент по левому краю элемента;
    right - выравнивает контент по правому краю элемента;
    center - выравнивает контент по центру элемента. */
  text-align: right;
  /* Свойство vertical-align нужно для вертикального центрирования текста. Принимает значения: 
    baseline - будут занимать позицию исходя из своих дефолтных настроек (если не задано другого) внутри их родительского элемента.;
    bottom - выравнивает контент по нижней границе элемента;
    top - выравнивает контент по верхней границе элемента;
    middle - выравнивает контент по центру элемента;
    sub - выравнивает контент так, как будто он подстрочный;
    text-bottom - выравнивает нижнюю границу элемента по самому нижнему краю текущей строки;
    text-top - выравнивает границу элемента по самому высокому элементу текущей строки. */
  vertical-align: middle;
  /* Свойство empty-cells нужно, чтобы производить какие-либо действия с пустыми ячейками таблицы.
  Принимает 2 значения - show (дефолтное. Пустые ячейки видны) и hide (все пустые ячейки лишаются границ и фона). */
  empty-cells: hide;
  /* Свойство cursor нужно для того, чтобы изменять внешний вид курсора (когда пользователь наводит на элементы, которые являются селекторами). Принимает значения: 
  pointer - курсор становиться ввиде руки;
  crosshair - курсор будет отображаться ввиде перекрестия;
  url() - нужно чтобы сделать свой собственный курсор. В скобках передаётся путь или ссылка на картинку, которая будет использоваться вместо курсора.
  Все виды курсоров можно посмотреть на сайте https://csscursor.info/. */
  cursor: pointer;
}

.dis,
td {
  /* Свойство pointer-events позволяет контролировать то, как элементы будут контролировать на события мыши или прикосновения к сенсорному экрану.
  Значение none делает, так чтобы элементы не воспринимали никакие взаимодействия с курсором (даже копирования текста). 
  Оно нужно если нужно отключить взаимодействия пользователя и элементов интерфейса. */
  pointer-events: none;
}


/* ТЕКСТОВЫЕ ЭФФЕКТЫ И МНОГОКОЛОНОЧНЫЙ ТЕКСТ. https://www.youtube.com/watch?v=6sc-gmz_MYQ&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=22 */


.example {

  /* Свойство text-overflow нужно для того, чтобы что-то делать с текстом, который не помещается в блок. Принимает значения: 
  ellipsis - текст обрезается, и последние 3 символа этого обрезанного текста заменяются троеточием;
  clip - текст просто обрезается в конце. */
  text-overflow: ellipsis;
  /* Свойство white-space: nowrap делает так, чтобы текст не переносился на новые строки. */
  white-space: nowrap;
  /* Свойство word-wrap: break-word делает так, чтобы слова переносились на новые строки, если не влезают в блок 
  (но на новой строке может оказаться всего одна буква из-за особенностей переноса). */
  word-wrap: break-word;
  /* Свойство word-break показывает то, как должно переноситься слово на новую строку. 
  Если задать значение break-all, то все слова будут разбиваться в конце строки посимвольно (тоже самое, что и word-wrap: break-word, как я понял). */
  word-break: break-all;
  /* Свойство writing-mode определяет то, какой будет способ написания текста. 
  Например, значение vertical-rl перевёрнет текст так, чтобы он был написан справа снизу вверх.*/
  writing-mode: vertical-rl;
}

.container {
  /*Свойство column-count применяется к блочным элементам.
  Они занимают всю строку, но мы можем контролировать это.
  С помощью этого свойства можно задать количество колонок на которое будет разбит весь текст в одной строке. */
  column-count: 3;
  /* Свойство column-rule разделяет колонки с помощью линии между ними. Принимает теже самые значения, что и свойство border. */
  column-rule: 1px solid black;
  /* Свойство column-width задаёт ширину колонок. 
  Это свойство, при узком экране (если колонкам не хватает места) может даже сделать текст одноколоночным, не взирая на свойство column-count. */
  column-width: 300px;
  /* Свойство column-gap определяет расстояние между колонками. */
  column-gap: 100px;
}


/* МЕДИАЗАПРОСЫ. https://www.youtube.com/watch?v=lv47xClJolw&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=23 */


/* Медиазапросы нужны, чтобы страница одинаково хорошо отображалась на всех устройствах. */
/* Чтобы скрывать определённые элементы на телефоне (у кого разрешение экрана 350px). screen значит, что контент предназначается только для экранов. */

/* Сначала нужно использовать директиву @media.
Далее, описываем набор правил и пишем слово, которое проверяет то, на каких устройстваз будут проверяться правила. Значения:
screen - проверка на то, что правила будут проверяться только на устройствах с экраном;
print - проверка на то, что правила будут проверяться только на принтерах или в режиме предварительного просмотра перед печатью;
speech - проверка на то, что правила будут проверяться только на скринридерах;
all - дефолтное значение. Правила будут проверяться на всех устройствах. */
@media print {

  /* Сюда пишем свойства, которые применяться, только в том случае, если выполняться заданные условия 
  (в нашем случае, если устройство - это принтер или пользователь находиться в режиме предварительного просмотра перед печатью). */
  body {
    color: blue;
  }
}

/* Правила могут разделяться 3 операторами: 
and - требуется выполнение всех указанных условий;
, - требуется выполнение хотя-бы одного из указанных условий (местный or);
not - отрицание указанного условия. */
/* Здесь происходит проверка на то, что сайт открыт на устройстве с дисплеем и имеет максимальную ширина экрана равна 350px.
То что указано в скобках называется медиафункцией. 
Есть такие значений, которые можно указать в медиафункции: width, height, min-width, min-height, max-width, max-height и ещё некоторые.
Т.е можно задать использование определённых свойств в зависимости от разрешения экрана. */
@media screen and (max-width:350px) {
  .object {
    display: none;
  }
}

/* Здесь происходит проверка на то, что сайт открыт на устройстве с дисплеем и ширина экрана находиться в пределах 992-1200px. */
@media screen and (min-width: 992px) and (max-width: 1200px) {
  body {
    background-color: aqua;
  }
}

/* Медиафункция orientation помогает определить в каком из двух режимов находиться функция. Принимает значения: 
landscape - горизонтальный режим устройства (когда ширина больше высоты);
portrait - вертикальный режим устройства (когда высота больше ширины). */
@media screen and (orientation: portrait) {

  /* Убираем заголовок h1. */
  h1 {
    display: none;
  }
}

/* Медиафункция device-aspect-radio помогает указать то, как ширина устройства относиться к его высоте. 
В качестве единиц измерения принимаются только целые числа. */
@media screen and (device-aspect-radio: 16/9) {
  body {
    background-color: green;
  }
}

/* Медиафункция min-resolution помогает указывает плотность пикселей устройства вывода.
В качестве единиц измерения принимаются dppx (относится к количеству пикселей, содержащихся в одном дюйме изображения, отображенного на мониторе компьютера)
или dpi (относится к количеству точек, содержащихся в одном дюйме изображения, распечатанного принтером на бумаге). */
/* Здесь свойства применяются к экранам, имеющим высокую плотность пикселей. */
@media screen and (min-resolution: 2dppx) {
  body {
    background-color: green;
  }
}


/* СТИЛИЗАЦИЯ ПЛЕЙСХОЛДЕРА И СКРОЛЛА, CSS-СПРАЙТЫ. https://www.youtube.com/watch?v=_eO1urQ71Lw&list=PLNkWIWHIRwMHUawuIEpPI_tOG7Mfhs_sA&index=24 */


/* Если применить свойства к input, то свойства изменяться только у текста, который вводит пользователь (или который находиться в поле ввода), но не у плейсхолдера. */
input {
  font-size: 24px;
  padding: 5px 10px;

  color: red;
}

/* Следующие 3 селектора нужны для стилилизации плейсхолдера. 
Они могут применять одни свойства, т.к разные селектора нужны для разных браузеров. */

/* Значение ::placeholder применяет свойства к плейсхолдеру у всех современных браузеров (Chrome, Firefox, Opera, Safari 10.1+). */
::placeholder {
  color: blue;
  /* opacity: 1 применяется только у браузера Firefox. */
  opacity: 1;
}

/* Данная конструкция используется для изменения плейсхолдера в браузере Edge. */
::-ms-input-placeholder {
  color: blue;
}

/* Данная конструкция используется для изменения плейсхолдера в браузере Internet Explorer 10-11. */
:-ms-input-placeholder {
  color: blue;
}

/* СТИЛИЛИЗИРОВАТЬ ТАКИЕ INPUT ЭЛЕМЕНТЫ, КАК КАЛЕНДАРЬ ИЛИ ВРЕМЯ МОЖНО ТОЛЬКО ЕСЛИ ВОССОЗДАТЬ ИХ С НУЛЯ С ПОМОЩЬЮ JS. */

/* Стилилизация скролла в каждом браузере специфична, поэтому тут мы стилилизуем скролл для Chrome (используем вендорный префикс ::-webkit). */
/* Свойство scrollbar стилилизует именно место, которое отводиться для полосы прокрутки скролла. */
::-webkit-scrollbar {
  width: 25px;
  background: #101124;
}

/* Свойство scrollbar-track стилилизует именно подложку, которая идёт под ползунком. */
::-webkit-scrollbar-track {
  border: 5px solid rgba(255, 255, 255, 0.25);
  box-shadow: inset 0 0 2.5px 2px rgba(0, 0, 0, 0.5);
}

/* Свойство scrollbar-thumb стилилизует сам ползунок. */
::-webkit-scrollbar-thumb {
  background: linear-gradient(45deg, #00ffa1, #00ffff);
  /* border-radius для скругления углов. */
  border-radius: 15px;
}

/* Создаём CSS-спрайт (что то типа анимации с помощью простого изменения позиции картинки кнопки) для кнопки. */
/* Прикольная анимация при наведении и нажатии на кнопку с помощью изменения позиции её картинки. */
button {
  width: 200px;
  height: 79px;
  /* Определяем картинку для фона. */
  background-image: url(./23.png);
  /* Картинка будет находиться вверху. */
  background-position: top;
  /* Картинка будет подстраиваться под высоту и ширину кнопки. */
  background-size: cover;

  /* Свойства, чтобы убрать дефолтные стили кнопки. */
  /* text-indent убирает текст кнопки туда, где пользователь его не видит (за границу экрана). */
  text-indent: -9999px;
  /* Убираем дефолтную обводку в 1px. */
  border: none;
  /* Делаем дефолтный фон кнопки прозрачным. */
  background-color: transparent;
  /* Показываем, что кнопки - это элемент взаимодействия и на неё можно кликнуть. */
  cursor: pointer;
  /* Делаем серую обводку. */
  outline: grey;
}

/* Когда пользователь наводит курсор на кнопку. */
button:hover {
  background-position: center;
}

/* Когда пользователь нажимает на кнопку. */
button:active {
  background-position: bottom;
}


/* НОВОВВЕДЕНИЯ CSS И HTML - https://www.youtube.com/watch?v=YFDKCAksZWw&t=1s */


/* КОНТЕЙНЕРНЫЕ ЗАПРОСЫ */
/* Данная функция следит за размером именно контейнера и с помощью медиа-запроса можно делать изменения в зависимости от размера контейнера. */
.container {
  /* container-type используется для определения типа содержимого, используемого в запросе к контейнеру.
  С помощью container-type мы определяем "контекст контейнера".
  Он может быть normal и тогда контейнерные запросы нельзя будет применять,
  Также может быть inline-size это означает, что для определения условия будет учитываться только ширина,
  а если будет size будут учитываться как ширина, так и высота. */
  container-type: inline-size;
  /* Контейнеру стоит присваивать имя, чтобы не путаться в контейнерных запросах. */
  container-name: card;
}

/* Дефолтные стили для карточки. */
.card {
  display: grid;
  grid-template-columns: 1fr 1fr;
}

/* Чтобы задавать контейнерные запросы нужно использовать ключевое слово @container,
далее указываем имя нашего контейнера и условия, при каком разрешении применять стили.
Стили, описанные в этом запросе применяться тогда, когда ширина контейнера станет меньше 400 пикселей,
или точнее они будут применяться до того времени, пока ширина контейнера не станет больше 400 пикселей. */
@container card (max-width: 400px) {

  /* Применяем стили, когда ширина контейнера меньше 400 пикселей. */
  .card {
    grid-template-columns: 1fr;
  }
}

/* STYLE QUERIES */
/* Задаём Style queries для контейнерных запросов в ключевом слове style()
и в нём проверяем значение переменной, которую задали в html элементе в атрибуте style.
И если значение переменной равно тому, что в атрибуте style, то применяются определённые стили. */
@container card style(--sunny: true) {

  /* Применяем стили к тем элементам у кого переменная "--sunny" равна true. */
  .weather-card {
    color: yellow;
  }
}

@container card style(--rain: true) {

  /* Применяем стили к тем элементам у кого переменная "--rain" равна true. */
  .weather-card {
    color: darkblue;
  }
}

/* :HAS() */
/* :has() используется так, что если в элементе .card есть элемент, переданный в :has() (в нашем случае это .card__image), то
к .card применяются переданные стили. */
.card:has(.card__image) {
  display: flex;
}

/* В данном случае мы применяем стили .card, если в элементе .card за h2 идёт элемент p. */
.card h2:has(+ p) {
  display: block;
}

/* Если в .card нету элемента .card__image */
.card:not(:has(.card__image)) {
  display: block;
}

/* NTH-OF */
/* Таким образом можно применить стили к каждому чётному элементу, который имеет класс .card,
Также можно так выбрать 2 элемент, который имеет класс .card и тд, но vs code пока что на это ругается. */
:nth-child(even of .card) {
  display: block;
}

/* TEXT-WRAP: BALANCE */
/* Свойство text-wrap может принимать wrap и просто переносить текст на новую строку, как обычно.
Может принимать nowrap и не переносить текст вовсе.
А может принимать balance и тогда текст будет по специальному алгоритму подстраиваться и будет красиво переноситься на новую строку. */
.card {
  text-wrap: balance;
}

/* INITIAL LETTER */
/* initial letter применяется для изменения первой буквы текста,
Первое значение - это то, сколько строк должна занимать буква,
а второе значение - то, насколько строк должна опуститься буква. */
p::first-letter {
  initial-letter: 5.3 2;
}

/* SVH, LVL, DVH */
/* svh - это самая маленькая высота вьюпорта, когда toolbar показывается на телефонах,
lvh - это самая большая высота вьюпорта, когда toolbar не показывается на телефонах,
dvh - это динамическая высота вьюпорта. 
Т.е когда toolbar показывается на телефонах? то применяется svh,а когда нет, то lvh. */
.card {
  height: 100dvh;
}

/* ЦВЕТОВОЕ ПРОСТРАНСТВО С ШИРОКОЙ ГАММОЙ */
/* Adobe разработал новое пространство цветов, которое лучше rgb, и чтобы его применять используются новые свойства.
Для этого используется свойство oklch().
Первый аргумент принимает число от 0 до 1 или процент от 0 до 100. 
Где число 0 соответствует 0% (черный), а число 1 соответствует 100% (белый). Этот аргумент определяет воспринимаемую яркость.
Второй аргумент принимает число от 0 до 1 или процент от 0 до 100. Это показатель цветности (грубо представляющий "количество цвета").
Третий аргумент принимает угол и представляет собой угол оттенка в rgb круге.
Четвёртый и необязательный аргумент, который принимает число от 0 до 1 и означает прозрачность (0) или непрозрачность (1).
В основном это свойство применяется для градиента и т.к сам ты цвет естественно создавать не будешь, то это можно сделать на https://gradient.style/. */
.card {
  background-color: oklch(40.1% 0.123 21.57 / .5);
}

/* COLOR-MIX() */
/* Это свойство нужно для смешивания цветов в конкретных цветовых пространствах.
Первым аргументом принимает в каком цветовом пространстве мы будем смешивать цвета.
Вторым и третим аргументом передаются сами цвета, которые мы будем смешивать, 
а дальше уровень прозрачности, где 0%, это значит что цвет будет полностью равен 1 переданному цвета,
а 100%, что цвет будет полностью равен 2 переданному цвету.
Color-mix() часто используется, когда есть primary-цвет и нужно получить его более прозрачные оттенки. */
.card {
  background-color: (in oklab, #04ff00, #00ffff 50%);
}

/* NESTING */
/* Теперь, в css можно вкладывать селекторы и различные медиа-запросы в другой селектор, прямо как в Sass. */
.card {
  color: red;

  &:hover {
    color: blue;
  }

  @container card (max-width: 400px) {
    .card {
      grid-template-columns: 1fr;
    }
  }
}

/* КАСКАДНЫЕ СЛОИ */
/* Каскадные слои можно определить с помощью @layer и названия слоя и в нём перебирать стили, которые нужно будет применить.
Чем ниже в коде находиться слой, тем больше у него приоритет (т.е при конфликтах, будут выбирать его стили). 
Но также, приоритет слоёв можно также указать в @layer, перебрав имена слоёв, 
исходя из того, какую приоритетность вы хотите им придать. Слои нужно перебирать от меньшего приоритета до большего. */
@layer components,
variations;

@layer components {
  .button {
    color: #fff;
  }
}

@layer variations {
  .button--modification {
    color: #fff;
  }
}

/* Если будет объявлен каскадный слой, который уже есть, 
то стили, объявленные в нём просто добавяться к ранее объявленному этому каскадному слою. */
@layer variations {
  .button--modification2 {
    color: #fff;
  }

  /* Каскадные слои поддерживают вложенность. */
  @layer day,
  night;

  @layer day {
    .button {
      color: yellow;
    }
  }

  @layer night {
    .button {
      color: black;
    }
  }
}

/* SCOPE */
/* @scope определяет область видимости для переданного класса в скобках.Т.е, например у нас есть глобальный класс .title, 
но т.к для .card мы создали свою область видимости, то его локальный класс .title не будет конфликтовать с глобальным .title. */
.title {
  font-size: 2px;
  color: red;
  font-weight: bold;
}

@scope (.card) {

  /* Элемент с классом .title в элементе c классом .card будет иметь только font-size: 14px, но не стили глобального .title. */
  .title {
    font-size: 14px;
  }
}

/* Также, @scope можно использовать таким образом.
В нашем примере, это значит, что все p,
находящиеся между элементом с классом .card и до элемента с классом .content будут окрашены в красный*/
@scope (.card) to (.content) {
  p {
    color: red;
  }
}

/* СИНУСЫ/КОСИНУСЫ */
.card {
  /* Чтобы получить косинус, нужно обернуть, то откуда нужно получить косинус в свойство cos(). */
  scale: cos(calc(1 / 54));
  /* Чтобы получить синус, нужно обернуть, то откуда нужно получить синус в свойство sin(). */
  translate: calc(sin(1 / 323 * 12))
}

/* ИНДИВИДУАЛЬНЫЕ СВОЙСТВА ДЛЯ TRANSFORM */
.card {
  /* Раньше, все эти свойства нужно было писать в свойстве transform. */
  transform: translate(50% 50%) rotate(30deg) scale(1.2);
  /* Но теперь появились их индивидуальные свойства. */
  translate: 50% 50%;
  rotate: 30deg;
  scale: 1.2;
}

/* SUBGRID */
/* Представим ситуацию, что у нас есть grid сетка и если один из элементов в разы больше другого, то
это выглядит странно и сама сетка естественно становиться больше. */
.wrapper {
  display: grid;
  grid-template-columns: 1fr 1fr;
  padding: 3em;
}

.item {
  grid-row: 1/4;
  /* Чтобы элемент сетки унаследовал свойство grid-template-rows у своего родителя 
  и стал такой же высоты, как он, то нужно использовать свойство subgrid. */
  display: grid;
  grid-template-rows: subgrid;
  /* Свойству grid-template-columns также можно определить subgrid, чтобы оно унаследовало это свойство у родителя. */
  grid-template-columns: subgrid;
}

/* MASONRY GRID */
/* При masonry-раскладке элементы располагаются один за другим в строчном направлении. 
При переносе на новую строку они могут смещаться вверх, заполняя пространство, оставленное коротким элементом, расположенным на предыдущей строке текщей колонки. */
.wrapper {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  /* Чтобы задать masonry-раскладку grid-контейнеру, то нужно просто задать grid-template-rows: masonry. */
  grid-template-rows: masonry;
  /* masonry-auto-flow изменяет способ размещения элементов при использовании masonry. .
  Принимает: 
  pack - В соответствии с алгоритмом masonry по умолчанию элементы будут размещены на дорожке с наибольшим пространством.
  next - Элементы будут располагаться один за другим по оси сетки. 
  definite-first - Отображение как в алгоритме masonry по умолчанию, сначала размещая элементы в определенном месте, прежде чем размещать другие элементы masonry.
  ordered - Игнорируйте любые элементы с определенным расположением и размещайте все в соответствии с измененным порядком документов. 
  Также, может принимать несколько значений. */
  masonry-auto-flow: next ordered;
  /* align-tracks задает выравнивание по оси Y для masonry контейнеров сетки.
  Свойство может принимать единственное значение, и в этом случае все дорожки выравниваются одинаковым образом. 
  Если используется список значений, то первое значение применяется к первой дорожке на оси сетки, второе - к следующей и так далее.
  Принимает те-же значения, что и align-items или justify-content. */
  align-tracks: end;
  /* justify-tracks задает выравнивание по оси X для masonry контейнеров сетки.
  Свойство может принимать единственное значение, и в этом случае все дорожки выравниваются одинаковым образом. 
  Если используется список значений, то первое значение применяется к первой дорожке на оси сетки, второе - к следующей и так далее.
  Принимает те-же значения, что и align-items или justify-content. */
  justify-tracks: center;
}

/* ВЕРТИКАЛЬНЫЙ РЕЖИМ ОТОБРАЖЕНИЯ ТЕКСТА */
/* Свойство writing-mode определяет, располагаются ли строки текста горизонтально или вертикально, а также направление, в котором продвигаются блоки.
Принимает: 
horizontal-tb - Для ltr скриптов содержимое перемещается горизонтально слева направо. Для rtl скриптов содержимое перемещается горизонтально справа налево. 
vertical-rl - Для ltr скриптов содержимое перемещается вертикально сверху вниз, а следующая вертикальная строка располагается слева от предыдущей строки. 
Для rtl скриптов содержимое перемещается вертикально снизу вверх, а следующая вертикальная строка располагается справа от предыдущей строки.
vertical-lr - Для ltr скриптов содержимое перемещается вертикально сверху вниз, а следующая вертикальная строка располагается справа от предыдущей строки. 
Для rtl скриптов содержимое перемещается вертикально снизу вверх, а следующая вертикальная строка располагается слева от предыдущей строки. */
.text {
  writing-mode: horizontal-tb;
}

/* НОВЫЕ ЛОГИЧЕСКИЕ СВОЙСТВА */
/* Раньше, мы использовали margin и padding, типа margin-top, padding-left и тд.
Но так как на всяких японских и тд сайтах, всё должно отображаться наоборот,
то менять эти свойства для этого странно и муторно.
Поэтому появились новые свойства: 
padding/margin/border-block-start - это top,
padding/margin/border-block-end - это bottom,
padding/margin/border-inline-start - это left,
padding/margin/border-inline-end - это right.
То, чем являются эти свойства подобраны для СНГ, англичан и прочих, у которых всё нормально.
А у японцев и тд, эти свойства будут реверсивны. */
.card {
  padding-inline-start: 16px;
  /* padding-inline-start: 16px для английского. */
  padding-left: 16px;
  /* padding-inline-start: 16px для арабского. */
  padding-right: 16px;
  /* padding-inline-start: 16px для японского. */
  padding-top: 16px;

  padding-block-start: 16px;
  /* padding-block-start: 16px для английского. */
  padding-top: 16px;
  /* padding-block-start: 16px для арабского. */
  padding-top: 16px;
  /* padding-block-start: 16px для японского. */
  padding-right: 16px;
}

/* ASPECT RATIO */
/* Свойство aspect-ratio позволяет вам определить желаемое соотношение ширины к высоте рамки элемента.
Это означает, что даже при изменении размера родительского контейнера или видового экрана браузер скорректирует размеры элемента
для поддержания указанного соотношения ширины к высоте. 
Первым числом идёт ширина, вторым высота. И получается их соотношение. */
.card {
  /* Соотношение 16 к 9 */
  aspect-ratio: 16 / 9;
  /* Это будет квадрат */
  aspect-ratio: 1;
}

/* CONTENT-VISIBILITY */
.card {
  /* Свойство content-visibility нужно для того, чтобы говорить браузеру, какик элементы и как нужно отрисовывать.
  Т.е, если выставить значение auto, то браузер будет отрисовывать элемент до того времени,
  пока пользователь видит его на своём экране, т.е он не стал выше 100vh. 
  Т.е, браузер обычно отрисовывает весь сайт сразу, 
  а так он сначала отрисует только элемент, который нужен пользователю сейчас. Это свойство хорошо для оптимизации. */
  content-visibility: auto;

  /* content-visibility: hidden скрывает элемент, но сохраняет его состояние рендеринга, поэтому, если нужно скрыть элемент,
   то лучше использовать content-visibility: hidden для оптимизации, а не display: none. */
  content-visibility: hidden;

  /* contains-intrinsic-size устанавливает размер элемента, который браузер будет использовать для макета, когда элемент подлежит ограничению размера.
  Т.е браузер будет отрисовывать 1000px элемента, даже если он переходит за рамки видимой области пользователя. */
  contain-intrinsic-size: 1000px;
}

/* FLEXBOX GAP */
.container {
  display: flex;
  flex-wrap: wrap;
  /* Теперь во flex контейнере можно задать row-gap для расстояния между строками, и column-gap для расстояния между колонками. */
  row-gap: 10px;
  column-gap: 20%;
  /* Либо можно задать сразу оба свойства в gap. */
  gap: 10px 20%;
}

/* OBJECT VIEW BOX */
.photo {
  /* Свойство object-view-box указывает “область просмотра” для элемента,
  так же, как это делает аттрибут <svg viewbox>, позволяя увеличить или обрезать контент элемента.
  object-view-box может принимать inset, и это работает так, что в нашем примере,
  25% отрежаться у верхней стороны картинки, 20% у правой стороны, 15% снизу и ничего не обрежаться слева. */
  object-view-box: inset(25% 20% 15% 0%);
  /* Указываем какой ширины должна получиться картинка и её соотношения. */
  width: 300px;
  aspect-ratio: 1;
}

/* MEDIA QUARIES RANGE */
/* Раньше, мы задавали медиа запросы так и это довольно неудобно. Тут мы указываем диапозон вьюпорта между 30em и 80em.*/
@media screen and (min-width: 30em) and (max-width: 80em) {}

/* Теперь медиа запросы можно писать так. Тут мы указываем диапозон между 400px и 1000px. width - наша текущая ширина вьюпорта */
@media (400px <=width <=1000px) {}

/* MIX-BLEND-MODE */
/* Свойство mix-blend-mode задает, как содержимое элемента должно сочетаться с содержимым родительского элемента и фоном элемента. 
Вообщем, оно изменяет элемент и накладывает на него различные фильтры, как на изображение. */
.card {
  /* Все возможные значения mix-blend-mode. */
  mix-blend-mode: normal;
  mix-blend-mode: multiply;
  mix-blend-mode: screen;
  mix-blend-mode: overlay;
  mix-blend-mode: darken;
  mix-blend-mode: lighten;
  mix-blend-mode: color-dodge;
  mix-blend-mode: color-burn;
  mix-blend-mode: hard-light;
  mix-blend-mode: soft-light;
  mix-blend-mode: difference;
  mix-blend-mode: exclusion;
  mix-blend-mode: hue;
  mix-blend-mode: saturation;
  mix-blend-mode: color;
  mix-blend-mode: luminosity;
}

/* FILTER */
/* Свойство filter применяет к элементу графические эффекты, такие как размытие или сдвиг цвета. 
Фильтры обычно используются для настройки рендеринга изображений, фона и границ. */
.card {
  /* Все возможные значения filter */
  filter: blur(5px);
  filter: brightness(0.4);
  filter: contrast(200%);
  filter: drop-shadow(16px 16px 20px blue);
  filter: grayscale(50%);
  filter: hue-rotate(90deg);
  filter: invert(75%);
  filter: opacity(25%);
  filter: saturate(30%);
  filter: sepia(60%);
}

/* BACKDROP-FILTER */
/* Свойство backdrop-filter применяет к ФОНУ элемента графические эффекты, такие как размытие или сдвиг цвета. 
Фильтры обычно используются для настройки рендеринга изображений, фона и границ.
В отличии от filter, размытие и тд применяется только к фону, а к его тексту и тд нет. */
.card {
  /* Все возможные значения backdrop-filter */
  backdrop-filter: blur(5px);
  backdrop-filter: brightness(0.4);
  backdrop-filter: contrast(200%);
  backdrop-filter: drop-shadow(16px 16px 20px blue);
  backdrop-filter: grayscale(50%);
  backdrop-filter: hue-rotate(90deg);
  backdrop-filter: invert(75%);
  backdrop-filter: opacity(25%);
  backdrop-filter: saturate(30%);
  backdrop-filter: sepia(60%);
}

/* LINEAR() */
/* Теперь, в функцию linear() можно задать значения, как в cubic-bezier,
только в отличии от него, в linear() движение происходит равномерно, а не резко. 
В linear() передаются точки линейного смягчения ввиде значений от 0 до 1.
Например, linear(0, 0.25, 1) создает функцию смягчения, которая линейно перемещается от 0 к 0.25, затем к 1. 
linear(0, 1) - равносильно просто linear. */
.card {
  /* Тут функция тратит 75% времени на переход от 0 к 0.25 и последние 25% на переход от 0.25 к 1. */
  animation: linear(0, 0.25 75%, 1)
}

/* MIN-CONTENT, MAX-CONTENT, FIT-CONTENT */
/* Внешний размер - это когда мы сами принудительно задаём ширину и высоту, с помощью width и height. 
А внутренний или естественный размер - это когда содержимое элемента определяет его размер (например, текст элемента растягивает элемент).
И, min-content, max-content и fit-content, как раз созданы для задания внутреннего размера элемента.
Они могут применяться и к width и к height. */
.card {
  /* Когда мы задаём ширину, как min-content, то ширина элемента будет равно ширине самого большого слова. */
  width: min-content;
  /* min-content можно использовать и в grid. */
  grid-template-rows: min-content auto min-content;
  /* Когда мы задаём ширину, как max-content, то он как бы говорит занять тексту, то сколько ему нужно места, но не больше.
  Т.е, текст будет стараться быть в одну строчку, но без свободного места справа. */
  width: max-content;
  /* max-content можно использовать и в grid. Колонка будет занимать столько места, сколько ей нужно. */
  grid-template-columns: max-content auto max-content;
  /* fit-content работает так, что когда контейнер большой,
  то применяется max-content, а когда маленький, то min-content. */
  width: -moz-fit-content;
  width: fit-content;
  /* fit-content можно использовать и в grid. В параметре можно передать максимально возможную ширину контента. */
  grid-template-columns: fit-content(100) auto fit-content(150);
}

/* СONIC-GRADIENT */
/* В коническом градиенте цвета поворачиваются по кругу вокруг центральной точки, как стрелки часов.
Также, с помощью слова turn можно сдвигать середину смещения цветов. 
Например, 0.25turn сдвигает середину смещения цветов на четверть. */
.card {
  background-image: conic-gradient(red, 0.25turn, green);
  /* Для повторения конических градиентов, есть свойство repeating-conic-gradient(). */
  background-image: repeating-conic-gradient(red, 0.25turn, green);
}

/* ACCENT-COLOR */
/* Свойство accent-color задаёт цвет для чекбоксов, слайдеров и тд. */
.input {
  accent-color: red;
}

/* CURRENT-COLOR */
/* Свойство current-color хранит в себе цвет, который записан в свойство color элемента ИЛИ РОДИТЕЛЯ ЭЛЕМЕНТА. */
.card {
  color: red;
  /* У нас будет border красного цвета */
  border: 1px solid CurrentColor;
}

/* ОТНОСИТЕЛЬНЫЕ ЦВЕТА */
/* Чтобы скорректировать какой то цвет, появилось слово from, после которого, идёт цвет, который нужно скорректировать.
После этого мы можем с помощью calc из каждого элемента rgb добавить и вычесть какое-либо значение.
Вся эта схема оборачивается в rgb(). */
.card {
  color: rgb(from tomato calc(r - 20) calc(g - 50) calc(b - 80));
  /* Так, цвет tomato будет полупрозрачным */
  color: rgb(from tomato r g b / 50%);
  /* Вот так, цвет можно скорректировать в oklch() пространстве. */
  color: oklch(from tomato l c calc(h + 120))
}

/* ЦВЕТОВЫЕ ПРОСТРАНСТВА ДЛЯ ГРАДИЕНТА */
/* Теперь, с помощью ключевого слова in можно указать нужное цветовое пространство для градиента. */
.card {
  background: linear-gradient(in lch to right, blue, red);
}

/* SCROLL SNAP */
/* Спецификация CSS Scroll Snap позволяет привязывать положение прокрутки к определённым элементам или местоположению после того, 
как пользователь прокрутил страницу или элемент. 
Использование Scroll Snapping заключается в установке свойства scroll-snap-type для элемента-контейнера и свойства scroll-snap-align для дочерних элементов. 
Прокрутка элемента-контейнера осуществляться с привязкой к дочерним элементам, которые вы определили. */
.container {
  /* Значение "mandatory" определяет поведение, при котором всякий раз, 
  когда пользователь прекращает прокрутку, браузер должен возвращать её к точке привязки. 
  Значение "proximity" менее строгое – оно означает, что браузер может возвращаться к точке привязки, если ему это покажется уместным. 
  Из моего опыта, если задано это значение, срабатывание происходит, если прокрутка остановилась в пределах нескольких сотен пикселей от точки привязки.
  Также, для scroll-snap-type нужно сначала указать ось, по которой будет происходить скроллинг. 
  Чтобы скроллинг работал в обоих осях нужно указать слово both. */
  scroll-snap-type: y mandatory;
  /* По умолчанию, при прокрутке дочерние элементы будут прижиматься к самым краям контейнера. 
  Вы можете изменить это, задав для контейнера свойство scroll-padding. Оно имеет такой же синтаксис, что и свойство padding. */
  scroll-padding: 20px;
  /* Свойство scroll-margin (en-US) может быть задано для дочерних элементов и определяет, по сути, внешний отступ данного элемента до позиции прокрутки. 
  Это позволяет дочерним элементам занимать разное количество места, и может использоваться в сочетании со свойством scroll-padding для родителя. */
  scroll-margin: 20%;
}

.child {
  /* Данное свойство позволяет указать, какая сторона элемента должна прижиматься к видимой области пользователя. 
  У свойства есть три возможных значения: "start", "center" и "end". */
  scroll-snap-align: start;
  /* scroll-snap-stop: always заставляет прокручиваемый контейнер остановиться на этом элементе, прежде чем пользователь сможет продолжить скролить.
  Т.е, чтобы пользователь точно остановился на этом элементе, а не бездумно скроллил. */
  scroll-snap-stop: always;
}

/* OVERSCROLL-BEHAVIOR */
/* Часто, когда у тебя есть модальное окно, то когда ты достигаешь конца скроллинга этого окна, 
то автоматически начинается скроллинг самой страницы, как бы по цепочке. 
Свойство overscroll-behavior решает эту проблему и если задать ему значение contain, 
то скроллинг "по цепочке" идти не будет. */
.card {
  overscroll-behavior: contain;
  /* Можно задать для осей x и y по отдельности. */
  overscroll-behavior-x: contain;
  /* Также, ещё есть значение none. 
  Оно работает, как contain, но оно ещё предотвращает отскок скролла на элементе при достижении верха или низа. */
  overscroll-behavior-y: none;
}

/* TOUCH ACTION */
/* Свойство touch-action указывает как элемент будет управляться через тачскрин (телефон). 
P.s Панорамирование-это вращение вокруг вертикальной оси, которое заставляет поле зрения перемещаться горизонтально.
Значения (может принимать несколько, в некоторых случаях): 
auto - Включит обработку браузером всех жестов панорамирования и масштабирования.
none - Отключит обработку браузером всех жестов панорамирования и масштабирования.
pan-x - Включит жесты горизонтального панорамирования одним пальцем. 
pan-y - Включит жесты вертикального панорамирования одним пальцем. 
manipulation - Включите жесты панорамирования и масштабирования, но отключите дополнительные нестандартные жесты, такие как двойное нажатие для увеличения. 
Отключение двойного нажатия для увеличения устраняет необходимость в том, чтобы браузеры задерживали генерацию событий click при касании пользователем экрана. 
Это псевдоним для "pan-x pan-y pinch-zoom" (который для совместимости сам по себе все еще действителен).
pan-left, pan-right,pan-up,pan-down - Включит жесты одним пальцем, которые начинаются с прокрутки в заданном направлении. 
После начала прокрутки направление все еще может быть изменено на обратное. Обратите внимание, что прокрутка "вверх" (панорамирование вверх) означает,
что пользователь проводит пальцем вниз по поверхности экрана, и аналогично панорамирование влево означает, что пользователь проводит пальцем вправо. 
Несколько направлений могут быть объединены, за исключением случаев, когда имеется более простое представление
(например, "pan-left pan-right" недопустимо, поскольку "pan-x" проще, но "pan-left pan-down**" допустимо).
pinch-zoom - Включит панорамирование страницы несколькими пальцами и ее масштабирование. Это можно комбинировать с любым из значений pan-. */
.card {
  touch-action: pan-x pan-y pinch-zoom;
}

/* SCROLL-BEHAVIOR */
/* Свойство scroll-behavior влияет на плавность скролла именно по якорям-ссылкам, а не просто по скроллу.
Принимает: 
auto - резкий скролл,
smooth - плавный скролл. */
.card {
  scroll-behavior: smooth;
}

/* SCROLLBAR GUTTER */
/* Часто, когда появляется модальное окно на странице, то скроллбар просто убирается и это выглядит странно.
Чтобы он не убирался, а на его месте просто образовывалось чёрное место (типа, он скрыт) стоит использовать scrollbar-gutter: stable. */
html,
body {
  scrollbar-gutter: stable;
}

/* FONT-DISPLAY */
/* Свойство font-display - это дескриптер, т.е свойство, которое применяется только внутри блока @font-face.
Все значения завязаны на загрузке шрифта и 3 стадиях: 
Период блокировки, период замены, период сбоя.
Чаще всего применяют значение fallback. 
Оно работает так, что период блокировки будет очень коротким и если шрифт за это время не загружен, то отображается невидимым запасным шрифтом.
Если же он успел загрузиться за это время, то отображается как обычно. Если же он не загружен, то текст отображается первым запасным шрифтом. 
Если после этих 2 этапов, шрифт так и не загружен, то текст на всё время посещения страницы будет отображаться запасным шрифтом.
Также в font-display можно передать: 
auto - Стратегия отображения шрифтов определяется агентом пользователя.
block - Предоставляет начертанию шрифта короткий период блокировки и бесконечный период замены.
swap - Придает начертанию шрифта чрезвычайно малый период блокировки и бесконечный период замены
optional - Придает начертанию шрифта чрезвычайно малый период блокировки и не имеет периода замены. */
@font-face {
  font-family: font;
  src: url();
  font-display: fallback;
}

/* LINE-CLAMP */
/* С помощью свойства -webkit-line-clamp можно задать то, через сколько строк по высоте будет показываться троеточие.
Для его правильного использования, элемент должен иметь свойства display: -webkit-box, -webkit-box-orient: vertical и overflow: hidden. */
.card p {
  display: -webkit-box;
  -webkit-line-clamp: 3;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

/* ВАРИАТИВНЫЕ ШРИФТЫ */
/* Раньше, шрифты можно было подключить конкретные и можно было задать им ограниченную жирность и тд.
Также, раньше, чтобы подключить несколько начертаний нужно было подключить несколько файлов и это нагружало сайт. 
Вариативные же шрифты хранят все начертания в одном файле. Подключаются они также, через @font-face. */
@font-face {
  /* Вариативные шрифты это новинка именно в типографике и её просто "импортировали" в веб, 
  поэтому чтобы подключить такие шрифты нужно просто использовать файлы с вариативными шрифтами. */
  font-family: variatic-font;
  src: url();
  /* font-weight также используется для жирности шрифта. */
  font-weight: 700;
  /* font-stretch используется для растяжения ширины шрифта. */
  font-stretch: 150;
  /* font-style теперь может принимать число, которое означает угол наклона шрифта. */
  font-style: 1;
  /* Для тонкой настройки вариативных шрифтов есть свойство font-variation-settings. */
  font-variation-settings: "slnt" 0;
  /* Свойство font-feature-settings позволяет включить или выключить некоторые возможности шрифта,
  например, отображение цифр в старом стиле. */
  font-feature-settings: "liga" on, "smcp" off;
}

/* FONT-PALETTE */
/* Палитра шрифта это новая возможность вариативных щрифтов. 
Чтобы её задать нужно использовать директиву @font-palette-values и задать ей имя. 
Далее определить семейство шрифта с помощью font-family и номер палитры с помощью base-palette. */
@font-palette-values --Grays {
  font-family: Rocher;
  base-palette: 1;
}

.grays {
  font-family: 'Rocher';
  /* Определяем палитру с помощью свойства font-palette. */
  font-palette: --Grays;
}

/* PREFERS-REDUCED-MOTION */
/* prefers-reduced-motion проверяет, включены ли у пользователя анимации или нет.
no-preference - анимации включены, reduce - анимации выключены. */
@media (prefers-reduced-motion: no-preference) {
  html {
    scroll-behavior: smooth;
  }
}

/* PREFERS-COLOR-SCHEME */
/* С помощью prefers-color-scheme можно определить какая тема стоит у пользователя. */
@media (prefers-color-scheme: light) {
  .card {
    color: white;
  }
}

@media (prefers-color-scheme: dark) {
  .card {
    color: black;
  }
}

/* PREFERS-REDUCED-DATA */
/* С помощью prefers-reduced-data можно определить стоит ли у пользователя экономия трафика или нет.
no-preference -  не стоит, reduce - стоит. */
@media (prefers-reduced-data: reduce) {
  .card {
    color: white;
  }
}

/* COLOR-SCHEME */
/* С помощью свойства color-scheme можно определить тему, которая будет стоять у пользователя на сайте.
Если поставить оба значения, то тема будет выбрана по предпочтению пользователя. */
:root {
  color-scheme: light dark;
}

/* PREFERS-CONTRAST */
/* prefers-contrast проверяет какие настройки контрастности установлены в системе. 
no-preference - никаких настроек;
more  - высокий уровень контрастности;
custom - определённый набор цветов. */
@media (prefers-contrast: more) {
  .card {
    color: white;
  }
}

/* РЕЖИМ ПРИНУДИТЕЛЬНЫХ ЦВЕТОВ */
/* forced-colors проверяет включил ли пользователь режим принудительных цветов.
none - не включен, active - включен. */
@media (forced-colors: active) {
  .card {
    /* Устанавливаем системный цвет */
    fill: buttonText;
  }
}

/* FOCUS-VISIBLE */
/* Псевдоселектор focus-visible определяет, что пользователь сфокусировался на элемент через Tab. */
.button:focus-visible {
  outline: red;
}

/* SUPPORTS */
/* Директива @supports проверяет то, поддерживает браузер пользователя переданное свойство. 
И если поддерживает то применяются определённые стили. */
@supports (display: grid) {
  .main {
    display: grid;
  }
}

/* CLAMP, MIN, MAX */
.card {
  /* сlamp() работает так, что элемент будет равен 50%, не будет меньше 200px, но и не больше 1000px. */
  width: clamp(200px, 50%, 1000px);
  /* min() работает так, что элемент примет то значение, которое наименьшее из тех, что переданы в функцию. */
  height: min(50vw, 4000px);
  /* max() работает так, что элемент примет то значение, которое набольшее из тех, что переданы в функцию. */
  height: max(25%, 400px)
}

/* PROPERTY */


/* Houdini (Гудини) — коллекция API браузера, значительно улучшающих процесс веб разработки.
API высокого уровня связаны с процессом рендеринга (стиль — макет — рисование — композиция). Эта группа включает:
Paint API — позволяет расширять CSS на шаге (имеется ввиду стадия рендеринга) отрисовки визуальных элементов (цвет, фон, границы и т.д.).
Layout API — позволяет расширять CSS на шаге определения размеров, позиции и выравнивания элементов.
Animation API — «точка расширения» на шаге отображения и анимирования элементов.
Низкоуровневые API являются основой для высокоуровневых и включают в себя:
API типизированной объектной модели (Typed Object Model)
API пользовательских свойств и значений (Custom Properties & Values)
API метрик шрифта (Font Metrics)
Ворклеты (Worklets). */

/* С помощью медиа-запроса @property можно задать своё собственное пользовательское свойство.
Этот медиа-запрос определяет, как браузеры должны применять свойство и обрабатывать ошибки.
В качестве аргумента данному методу передается объект со следующими свойствами:
после @property: название пользовательского свойства.
syntax: инструкция для парсинга. Предустановленными значениями являются: <color>, <integer>, <number>, <length>, <percentage> и др.
inherits: будет наследоваться или нет.
initialValue: значение по умолчанию (до переопределения, а также при возникновении ошибок). */
@property --colorPrimary {
  syntax: '<color>';
  inherits: false;
  initial-value: blue;
}

/* В приведенном примере было определено пользовательское свойство с типом <color>.
Это свойство будет использовано для определения градиента. Обычный CSS не поддерживает переход градиента.
Обратите внимание на то, как будет использовано пользовательское свойство для определения transition. */
.gradient-box {
  background: linear-gradient(45deg, rgba(255, 255, 255, 1) 0% var(--colorPrimary) 60%);
  transition: --colorPrimary 0.5s ease;
}

/* Браузер не знает о том, как выполнить переход для градиента, но он знает, как сделать это для цвета. 
Именно поэтому мы определили тип свойства как <color>. В браузере, поддерживающем Гудини, изменение градиента произойдет при наведении курсора. 
Позиция градиента, измеряемая в процентах, также может быть изменена при помощи пользовательского свойства CSS (зарегистрированного как <percentage>). */
.gradient-box:hover {
  --colorPrimary: red;
}

/* MARKER */
/* ::marker нужен для стилилизации элементов, имеющих display: list-item.
Это li и прочие элементы списка, или просто элементы, которым задано это свойство. */
li::marker {
  content: "🎄"
}

/* WHERE */
/* Обычно мы пишем так, когда у нескольких элементов нужно задать один селектор. */
header a:hover,
main a:hover,
footer a:hover {
  color: green;
}

/* Но с помощью :where, мы можем сделать так, и это будет элегантнее. */
:where(header, main, footer) a:hover {
  color: green;
}

/* IMAGE-SET() */
div {
  /* С помощью image-set() можно назначить несколько картинок для разных экранов и браузер сам выберет нужную. */
  background-image: image-set(url("img1x.webp") type("image/webp") 1x,
      url("img2x.webp") type("image/webp") 2x,
      url("img1x.png") type("image/png") 1x,
      url("img2x.png") type("image/png") 2x,
    );
}

/* IMAGE() */
/* Раньше мы задавали изображение так. */
.card {
  background-image: url("photo.img");
}

/* Но с помощью image() можем так. */
.card {
  /* У image() есть несколько отличий от url().
  Первое это то, что мы можем задать направление картинки с помощью ltr(слева направо) и rtl(справа налево).
  Второе это то, что мы с помощью "#xywh=" можем вырезать определённый фрагмент, вместо целой картинки. 
  Это начальные точки вдоль осей x и y, а также ширины и высоты — в исходное изображение для отображения только части исходного изображения.
  Часть изображения, определенная в параметре, становится отдельным изображением. 
  Т.е тут фоновым изображением элемента будет часть изображения myImage.webp,
  который начинается с координаты 0px, 20px (верхний левый угол) и имеет ширину 40px и высоту 60px. 
  И третье, это то что можно задать цвет, который будет отображаться, если картинка не прогрузилась. */
  background-image: image(red, ltr "photo.img#xywh=32,64,16,16");
}

/* POPOVER API */
/* Псевдоселектор ::backdrop применяется к popover элементам и стилилизует задний фон всплывающего окна
- https://developer.mozilla.org/en-US/docs/Web/CSS/::backdrop. */
.popover::backdrop {
  background: red;
}

/* ANCHOR POSITIONING */
.anchor {
  /* В ссылке, на которую нужно наводиться для подсказки присваиваем свойству anchor-name id нашего элемента, в качестве имени якоря. */
  anchor-name: --my-anchor;
}

/* @position-fallback работает так, что у него есть несколько позиций, 
которые он поэтапно применяет к элементу, в зависимости от того видит ли его пользователь.
Т.е, если изначально элемент будет сверху якоря (первый @try), 
но граница сверху будет уменьшаться, то он перейдёт на другой @try, где указано позиция снизу якоря. 
@position-fallback будет пробовать всё, чтобы элемент оставался внутри контейнера.
Если ничего не помогает, то применяет просто первый @try.
После @position-fallback идёт название position-fallback. */
@position-fallback --top-to-bottom {
  @try {
    bottom: anchor(top);
    left: anchor(center);
  }

  @try {
    top: anchor(bottom);
    left: anchor(center);
  }
}

.boat {
  /* В элементе, который будет показываться при наведении на ссылку нужно задать свойство anchor-default с именем якоря.
  Это свойство даёт возможность напрямую обращаться к якорю в стилях элемента.
  Если бы не указали, то пришлось бы обращаться как то так: 
  bottom: anchor(--my-anchor top).
  То есть, с помощью функции anchor можно брать позиции якоря. 
  Его верх, с помощью top или середину, с помощью center и так далее. 
  Также, можно взять его width или height. */
  anchor-default: --my-anchor;
  bottom: anchor(top);
  left: calc(anchor(center) - (var(--boat-size) * 0.5));
  /* С помощью свойство anchor-scroll можно указать, чтобы всплывашка была прикреплена к якорю и при скроллинге двигалась вместе с ним. */
  anchor-scroll: --my-anchor;
  /* Определяем position-fallback. */
  position-fallback: --top-to-bottom;
}

/* КАСТОМНЫЙ СЕЛЕКТ */
/* Теперь есть тег selectmenu и у селекта можно настраивать почти каждую деталь.
Больше про это - https://habr.com/ru/articles/707498/. */
selectmenu::part(listbox) {
  box-shadow: 3px 3px 3px 3px hotpink;
}

/* АНИМАЦИЯ ДИСКРЕТНЫХ СВОЙСТВ */
/* Дискретные свойства - это некоторые подкопотные свойства браузерных элементов.
С помощью них, можно анимировать например анимации модальных окон Popover API. */
.settings-popover {

  /* С помощью :popover-open можно прицепиться к состоянию открытия. */
  &:popover-open {

    /* С помощью @starting-style можно задать стили до изменения, т.е начальные стили. */
    @starting-style {
      transform: translateY(20%);
      opacity: 0;
    }

    /* Тут можно задать стили при состоянии открытия. */
    transform: translateY(0);
    opacity: 1;
  }

  /* Тут можно задать стили после открытия. */
  transform: translateY(50%);
  opacity: 0;

  /* Можно задать transition для плавных анимаций. */
  transition: all 0.5s;
}

/* SCROLL DRIVEN ANIMATION */
/* Модуль "Анимация, управляемая прокруткой CSS" предоставляет функциональные возможности, основанные на модуле CSS animations и API веб-анимации. 
Это позволяет вам анимировать значения свойств на основе продвижения по временной шкале, основанной на прокрутке.
Больше про это на https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_scroll-driven_animations. */
/* Сначала нужно задать саму анимацию. */
@keyframes reveal {
  from {
    opacity: 0
  }

  to {
    opacity: 1
  }
}

.revealing-image {
  animation: auto linear reveal both;
  /* Свойство animation-timeline CSS определяет временную шкалу, которая используется для управления ходом выполнения анимации CSS. 
  Принимает: 
  auto - временная шкала анимации такая же как временная шкала документа,
  scroll() - анимация работает так, что она происходит при скроллинге страницы и элемент, в зависимости от скроллинга делает свою анимацию. 
  view() - анимация работает так, что она происходит тоже при скроллинге страницы, 
  но тут элемент делает анимацию не в зависимости от скроллинга, а именно в зависимости оттого, насколько элемент видно. */
  animation-timeline: view();
  /* Свойство animation-range используется для установки начала и конца диапазона вложений анимации вдоль ее временной шкалы,
  то есть где на временной шкале анимация будет начинаться и заканчиваться. 
  Вообщем, можно указать то, в каких диапозонах анимация будет начинаться и заканчиваться, в каких точках при скроллинге.
  Поэксперементировать можно на https://scroll-driven-animations.style/tools/view-timeline/ranges/#range-start-name=entry&range-start-percentage=100&range-end-name=cover&range-end-percentage=70&view-timeline-axis=block&view-timeline-inset=0&subject-size=smaller&subject-animation=reveal&interactivity=clicktodrag&show-areas=yes&show-fromto=yes&show-labels=yes.
  Узнать больше можно на https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_scroll-driven_animations. */
  animation-range: entry 25% cover 50%;
}

/* VIEW TRANSITION API */
/* View Transitions API, что можно перевести как "интерфейс переходов отображения", 
предлагает легкий способ анимирования перехода между двумя состояниями DOM — даже между загрузками страниц. 
До недавнего времени у нас не было возможности простого обновления DOM. При использовании View Transitions API происходит следующее:
1. Делается снимок (snapshot) текущего состояния страницы.
2. Выполняется обновление DOM (добавляются/удаляются элементы).
3. Делается снимок нового состояния страницы.
4. Переход между этими состояниями анимируется с помощью дефолтного плавного затухания или с помощью кастомной анимации. */

/* Для стилизации старого и нового состояния предназначены следующие селекторы CSS: */
::view-transition-old(root) {
  /* анимирование выхода (старого состояния) */
}

::view-transition-new(root) {
  /* анимирование входа (нового состояния) */
}

/* Мы увеличиваем продолжительность анимации до 1 секунды, чтобы сделать ее более заметной: */
::view-transition-old(root),
::view-transition-new(root) {
  animation-duration: 1s;
}

/* Пример более сложной анимации. */
::view-transition-old(root) {
  animation: 1s transition-out 0s ease;
}

::view-transition-new(root) {
  animation: 1s transition-in 0s ease;
}

@keyframes transition-out {
  from {
    opacity: 1;
    translate: 0;
    rotate: 0;
  }

  to {
    opacity: 0;
    translate: -3rem -5rem;
    rotate: -10deg;
  }
}

@keyframes transition-in {
  from {
    opacity: 0;
    translate: 3rem 5rem;
    rotate: -10deg;
  }

  to {
    opacity: 1;
    translate: 0;
    rotate: 0;
  }
}

/* Если применять анимации к root, то анимации применяются ко всей странице, включая элемент header, что выглядит немного странно.
Свойство view-transition-name позволяет применять (или отключать) анимации к отдельным элементам. */
header {
  view-transition-name: header;
}

/* Но так как, мы не хотим анимировать header, поэтому у нас нет необходимости определять для нее анимации. 
Селекторы ::view-transition-old(root) и ::view-transition-new(root) теперь применяются ко всем элементам, за исключением <header>. */
::view-transition-old(header) {}

::view-transition-new(header) {}

/* Для некоторых людей с особенностями восприятия анимированные переходы могут оказаться нежелательными. 
Соответствующее предпочтение пользователя можно определить с помощью медиа-запроса prefers-reduced-motion. */
@media (prefers-reduced-motion) {

  ::view-transition-group(*),
  ::view-transition-old(*),
  ::view-transition-new(*) {
    animation: none !important;
  }
}