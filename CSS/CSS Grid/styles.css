

/* ПРИМЕНЕНИЕ СЕТКИ К КОНТЕЙНЕРУ. https://www.youtube.com/watch?v=o6zB8EC10wc&list=PLNkWIWHIRwMHlq6yOP65F_rNH5wID1U21&index=6 */


.grid-container {
    /* Чтобы создать grid-container нужно присвоить элементу свойство display: grid. */
    /* Если у свойства display будет значение inline-grid, то grid-container по ширине подстроиться под размер контента внутри себя (но возможно, это уже неактуально). */
    display: grid;
    /* Свойство grid-template-columns принимает то, количество значений, которое равно количеству колонок,
    которые будут в нашем лейауте.
    Это свойство принимает величины, которые отвечают за ширину колонок, а высота подстраивается под контент.
    (1fr равна 1 части доступного пространства, похоже на flex-grow: 1).
    Т.к значение в fr у нас только одно, то первый элемент занимает 100px, третий занимает 200px, а второй, всё пространство, которое осталось между ними. */
    grid-template-columns: 100px 1fr 200px;
}


/* СОЗДАНИЕ ТРЁХ КОЛОНОЧНОГО МАКЕТА. https://www.youtube.com/watch?v=uWze8aMlZ0s&list=PLNkWIWHIRwMHlq6yOP65F_rNH5wID1U21&index=3 */


.grid-container {
    display: grid;
    /* Если сумма размеров всех колонок будет меньше ширины экрана, то у grid-container ещё останется свободное место. */
    grid-template-columns: 100px 300px 200px;
    /* Grid-container`у можно задать и ширину и высоту. */
    width: 600px;
    height: 500px;
    /* fr в Grid работает, как flex-frow во Flexbox и поэтому 1 элемент (у него 1fr) будет в 4 раза меньше 3 элемента (у него 4fr). */
    grid-template-columns: 1fr 2fr 4fr;
    /* Если div элементов у нас 3, а в свойстве grid-template-columns передаётся 4 значения,
    то в grid-container появиться свободное пространство (в нашем случае, равное 400px), но если создать ещё один div элемент в grid-container,
    то он как раз будет подстроиться под это пустое пространство (400px в нашем случае). */
    grid-template-columns: 100px 300px 200px 400px;
    /* Также, свойство grid-template-columns принимает значения min-content и max-content и теперь,
    первая колонка горизонтально подстроиться под размер самого длинного слова, которое есть в колонке (т.к стоит min-content);
    вторая колонка будет равна 200px;
    а третья колонка была растянута на всю ширину контента. */
    /* При этом, у всех колонок, высота будет одинаковая, т.к высота колонки зависит от размера контента в ней,
    поэтому все колонки подстраиваются под размер самой высокой колонки в grid-container. */
    grid-template-columns: min-content 200px max-content;
    /* Свойство grid-template-columns может также принимать значение minmax(), в которое передаются минимальное и максимальное значение колонки, поэтому
    ширина этой колонки может изменяться от 100 до 300 пикселей, в зависимости от разрешения экрана, хотя другие колонки всегда будут иметь одинаковую ширину. */
    grid-template-columns: 100px 200px minmax(100px, 300px);
    /* Свойство grid-template-columns может также принимать значение repeat(), которое нужно для того, чтобы задать колонкам одинаковый размер.
    Первым значением задаём сколько элементов сетки будет дублироваться 
    (т.к у нас трёх-колоночный макет, то передаём число 3, чтобы наши 3 колонки имели одинаковый размер).
    А вторым значением передаётся размер колонок. */
    grid-template-columns: repeat(3, 1fr);
    /* Также, стоит учитывать, что если не задать размер какой-нибудь колонке, то её значение по-умолчанию равно auto, т.е
    колонка подстраивается под контент. */

    /* С помощью свойства column-gap можно задать расстояние между колонками. */
    column-gap: 15px;
}


/* УПРАВЛЕНИЕ РАЗМЕРАМИ И ПОЗИЦИЕЙ GRID-ЭЛЕМЕНТА. https://www.youtube.com/watch?v=m1VVFnIqmAk&list=PLNkWIWHIRwMHlq6yOP65F_rNH5wID1U21&index=4 */


.grid-container {
    display: grid;
    /* Свойство grid-template-rows отвечает за количество строк в grid-container (растягивает grid-container вертикально вниз). 
    Принимает те же свойства, что и grid-template-columns. */
    grid-template-rows: repeat(3, 100px);
}

.grid-item1 {
    /* Свойства grid-column-start и grid-column-end определяют, как элемент будет начинаться и заканчиваться в колонках.
    Т.е данный элемент начнётся в НАЧАЛЕ 3 колонки и растянется до НАЧАЛА 4 колонки вправо. */
    grid-column-start: 3;
    grid-column-end: 4;
    /* Прошлую запись можно упростить до одного свойства grid-column, передавая значения grid-column-start и grid-column-end через /. */
    grid-column: 3 / 4;
    /* Свойства grid-row-start и grid-row-end определяют, как элемент будет начинаться и заканчиваться в строках.
    Т.е данный элемент начнётся в НАЧАЛЕ 1 строки и растянется до НАЧАЛА 3 строки вниз (т.е займёт полностью 1 и 2 строки). */
    grid-row-start: 1;
    grid-row-end: 3;
    /* Прошлую запись можно упростить до одного свойства grid-row, передавая значения grid-row-start и grid-row-end через /. */
    grid-row: 1 / 3;
    /* Свойства grid-column и grid-row можно объединить в одно свойство grid-area.
    Оно принимает сначала grid-row-start, grid-column-start, grid-row-end, grid-column-end. */
    grid-area: 1 / 3 / 3 / 4
}

/* По-умолчанию, отсчёт в свойствах grid-column-start, grid-column-end, grid-row-start, grid-row-end начинается от левого верхнего угла.
Но если написать отрицательное число, то отсчёт начнётся с правого нижнего угла. Правый нижний угол равен -1. */


/* ИМЕНОВАНИЕ GRID-ЛИНИЙ, СОЗДАНИЕ СЕТКИ, ПОЗИЦИОНИРОВАНИЕ ЭЛЕМЕНТОВ. https://www.youtube.com/watch?v=CbrRvDlNgXg&list=PLNkWIWHIRwMHlq6yOP65F_rNH5wID1U21&index=5 */


.grid-container {
    display: grid;
    /* Имя колонки можно указать в свойстве grid-template-columns в квадратных скобках. */
    grid-template-columns: repeat(3, [col] 1fr);
    /* Имя строки можно указать в свойстве grid-template-rows в квадратных скобках. */
    grid-template-rows: repeat(3, [row] 100px);
    /* Указываем расстояние между колонками. */
    column-gap: 15px;
}

.grid-item1 {
    /* В свойстве grid-column мы можем указать имена колонки, в которой хотим растянуть элемент (занимает 3 колонки, т.к 4 - 1 = 3). */
    grid-column: col 1 / col 4;
    /* Ключевое слово span растягивает ячейки на определённое число.
    То есть, в следующем примере будет колонка, которая начнётся с второй колонки и растянется на ещё 4.
    А если бы было "col 2 / col 4", то колонка бы также началась со второй колонки, но растянулось ДО 4 колонки, а не на ещё 4 колонки. */
    grid-column: col 2 / span 4;
}


/* ВЫРАВНИВАНИЯ GRID-ЭЛЕМЕНТОВ. https://www.youtube.com/watch?v=uEHTERVYqsk&list=PLNkWIWHIRwMHlq6yOP65F_rNH5wID1U21&index=6 */



.grid-container {
    /* Создаём grid-container и создаём колонку длиной во весь экран и строку равную 300px. */
    display: grid;
    grid-template-columns: 1fr;
    grid-template-rows: 300px;
    /* Чтобы задать ВСЕМ элементам в grid-container одинаковое расположение используют свойства align-items и justify-items. */

    /* Свойство align-items нужно для выравнивания ВСЕХ ЭЛЕМЕНТОВ grid-container по вертикали. Принимает значения: 
    stretch - растягивает контент элементов по всей высоте контейнера. Не работает, если задана фиксированная высота;
    start - элементы расположаться вертикально в начале контейнера (сверху);
    end - элементы расположаться вертикально в конце контейнера (снизу);
    center - элементы расположаться вертикально в центре контейнера. */
    align-items: center;
    /* Свойство justify-items нужно для выравнивания ВСЕХ ЭЛЕМЕНТОВ grid-container по горизонтали. Принимает значения: 
    stretch - растягивает контент элементов по всей ширине контейнера. Не работает, если задана фиксированная ширина;
    start - элементы расположаться горизонтально в начале контейнера (слева);
    end - элементы расположаться горизонтально в конце контейнера (справа);
    center - элементы расположаться горизонтально в центре контейнера. */
    justify-items: center;
}

.grid-item1 {
    /* Свойство align-self нужно для выравнивания конкретного элемента по вертикали. Принимает значения: 
    stretch - растягивает контент элемента по всей высоте контейнера. Не работает, если задана фиксированная высота;
    start - элемент расположиться вертикально в начале контейнера (сверху);
    end - элемент расположиться вертикально в конце контейнера (снизу);
    center - элемент расположиться вертикально в центре контейнера. */
    align-self: center;
    /* Свойство justify-self нужно для выравнивания конкретного элемента по горизонтали. Принимает значения: 
    stretch - растягивает контент элемента по всей ширине контейнера. Не работает, если задана фиксированная ширина;
    start - элемент расположиться горизонтально в начале контейнера (слева);
    end - элемент расположиться горизонтально в конце контейнера (справа);
    center - элемент расположиться горизонтально в центре контейнера. */
    justify-self: center;
}


/* ВЫРАВНИВАНИЯ GRID-КОНТЕЙНЕРА. https://www.youtube.com/watch?v=FIy9ZQXTGVY&list=PLNkWIWHIRwMHlq6yOP65F_rNH5wID1U21&index=7 */


.grid-container {
    /* Создаём grid-container  */
    display: grid;
    /* Чтобы горизонтально выравнить сетку в grid-container используют свойство justify-content.
    (Что такое сетка - https://stackoverflow.com/questions/40740553/what-is-the-difference-between-align-items-vs-align-content-in-grid-layout) Принимает значения: 
    stretch - растягивает контент элементов сетки по всей ширине контейнера. Не работает, если задана фиксированная ширина;
    start - сетка расположиться горизонтально в начале контейнера (слева);
    end - сетка расположиться горизонтально в конце контейнера (справа);
    center - сетка расположиться горизонтально в центре контейнера;
    space-between - первый и последний элемент сетки горизонтально располагаются в начале и в конце grid-container. 
    А элементы сетки между ними равномерно распределены с одинаковым пространством между друг другом;
    space-around - все элементы сетки горизонтально располагаются с одинаковым расстоянием между друг другом 
    (но расстояние у первого/последнего элемента сетки между стенками grid-container будет меньше, 
    чем расстояние между друг другом других элементов сетки, т.к расстояние между ними суммируется);
    space-evenly - теперь вообще все элементы сетки горизонтально располагаются с одинаковым расстоянием по всему grid-container. */
    justify-content: space-evenly;
    /* Чтобы вертикально выравнить сетку в grid-container используют свойство align-content.
    (Что такое сетка - https://stackoverflow.com/questions/40740553/what-is-the-difference-between-align-items-vs-align-content-in-grid-layout) Принимает значения: 
    stretch - растягивает контент элементов сетки по всей высоте контейнера. Не работает, если задана фиксированная высота;
    start - сетка расположиться вертикально в начале контейнера (сверху);
    end - сетка расположиться вертикально в конце контейнера (снизу);
    center - сетка расположиться вертикально в центре контейнера;
    space-between - первый и последний элемент сетки вертикально располагаются в начале и в конце grid-container. 
    А элементы сетки между ними равномерно распределены с одинаковым пространством между друг другом;
    space-around - все элементы сетки вертикально располагаются с одинаковым расстоянием между друг другом 
    (но расстояние у первого/последнего элемента сетки между стенками grid-container будет меньше, 
    чем расстояние между друг другом других элементов сетки, т.к расстояние между ними суммируется);
    space-evenly - теперь вообще все элементы сетки вертикально располагаются с одинаковым расстоянием по всему grid-container. */
    align-content: center;
}


/* УПРАВЛЯТЬ ПОРЯДКОМ ЭЛЕМЕНТОВ ВНУТРИ GRID-КОНТЕЙНЕРА. https://www.youtube.com/watch?v=dIrEc9ruCuU&list=PLNkWIWHIRwMHlq6yOP65F_rNH5wID1U21&index=8 */


.grid-container {
    display: grid;
    /* Для определённого размещения элементов в сетке используется свойство grid-auto-flow (похоже на flex-direction во Flexbox). Принимает значения: 
    row - дефолтное значение, элементы располагаются слева направо и если не помещяются в одной строке, то переносятся на новую;
    column - элементы располагаются сверху вниз и если не помещяются в одной колонке, то переносятся на новую. */
    /* Значение dense указывается, чтобы "заполнить" некоторые дыры в сетке. 
    Т.е если, например 3 и 2 элемент больше других и 3 не помещается в строку, то после второго элемента остаётся пустое место,
    но с помощью значения dense это пустое место закроется с помощью другого элемента, который подходит размером под это пустое место.
    Можно сказать, что dense является "заполнителем пустого пространства" внутри CSS Grid. */
    grid-auto-flow: column dense;
}

/* Растягиваем второй и третий элемент на 2 колонки. */
.grid-item:nth-of-type(2),
.grid-item:nth-of-type(3) {
    grid-column: span 2;
    /* Можно изменить позицию элемента в контейнере с помощью свойства order. 
    По умолчанию, все элементы имеют это свойство, которое равно 0.
    Данная система устроена так, что сначала идут элементы с наименьшим значением order, а потом по нарастающей.
    Поэтому второй и третий элемент будут идти в самом конце (т.к индексы всех остальных элементов равны 0). */
    order: 1;
    /* Свойство order также может принимать отрицательные значения и тогда второй и третий элемент будут идти в самом начале. */
    order: -1
}


/* ВЛОЖЕННОСТЬ GRID-ЭЛЕМЕНТОВ. https://www.youtube.com/watch?v=XP30BMpJ740&list=PLNkWIWHIRwMHlq6yOP65F_rNH5wID1U21&index=9 */


.grid {
    display: grid;
    /* Параметр auto-fill анализирует пустое пространство и заполняет его следующим grid-элементом. */
    /* В параметре minmax есть значение auto, значит и что в следующем примере,
    элемент не может стать меньше 200px а максимального ограничения у него нет. */
    grid-template-columns: repeat(auto-fill, minmax(200px, auto));
}

/* Вложенный grid-container. */
/* Если главный grid-container динамически изменяет сетку при изменении разрешения экрана, то
внутренний контейнер всегда будет одинаковым (в нашем случае - двухколоночным). */
.grid-2 {
    display: grid;
    grid-template-columns: repeat(2, auto);
}


/* ГИБКОСТЬ GRID-ЭЛЕМЕНТОВ ПРИ ИЗМЕНЕНИИ РАЗМЕРОВ ЭКРАНА. https://www.youtube.com/watch?v=Ee2SWlquOQU&list=PLNkWIWHIRwMHlq6yOP65F_rNH5wID1U21&index=10 */


.grid {
    display: grid;
    /* Свойство grid-gap задаёт элементам одинаковые свойства column-gap и row-gap.
    (Работает так, что задаёт всем элементам margin). */
    grid-gap: 15px;
    height: 100vh;
    /* Параметр auto-fill анализирует пустое пространство в сетке,
    и если оно есть, то добавляет туда элемент, который помещается в это пустое пространство 
    (полезно при изменении разрешения экрана).
    Также, при уменьшении экрана, элементы, которые не помещаются, переходят на новую строку. */
    /* В следующем примере, элементы колонок не могут быть меньше 100px, т.к это минимальное значение, 
    но в максимальном значении стоит auto, а это значит, что элементы могут растягиваться на всю ширину и ограничений в этом плане у них нет. */
    grid-template-columns: repeat(auto-fill, minmax(100px, auto));
    /* Но если элементов мало, например 3 и используется auto-fill, то пустое пространство всё равно останется. 
    Для таких случаев есть параметр auto-fit,
    который растягивает grid-элементы на всю ширину (а auto-fill просто подставлял другой элемент под пустое пространство).  */
    grid-template-columns: repeat(auto-fit, minmax(100px, auto));
}


/* СОЗДАНИЕ ГИБКОГО МАКЕТА. https://www.youtube.com/watch?v=2MKGG8o1Qc4&list=PLNkWIWHIRwMHlq6yOP65F_rNH5wID1U21&index=11 */


/* Привязываем части размятки (header, nav, aside, main, footer) к grid-лейауту с помощью свойства grid-area 
для того, чтобы используя свойство grid-template-areas, к ним можно было обращаться. */
header {
    grid-area: header;
}

nav {
    grid-area: nav;
}

aside {
    grid-area: aside;
}

main {
    grid-area: main;
}

footer {
    grid-area: footer;
}

.container {
    display: grid;
    grid-template-columns: minmax(150px, 200px) 1fr minmax(150px, 200px);
    /* Свойство grid-template-areas определяет именованные области сетки (мы именовали их с помощью свойства grid-area),
    устанавливая ячейки в сетке. https://developer.mozilla.org/en-US/docs/Web/CSS/grid-template-areas */
    /* Так как у нас установлено 3 колонки, то мы указываем в каждой строке по 3 значения: 
    В первой строке везде стоит header, т.к он должен занимать всю ширину строки, т.е header располагается в каждой из 3 колонок.
    Во второй строке, в первой колонке у нас находиться nav, во второй main и в третьей aside.
    В третьей строке везде стоит footer, т.к он должен занимать всю ширину строки, т.е footer располагается в каждой из 3 колонок. */
    grid-template-areas: 
    "header header header"
    "nav main aside"
    "footer footer footer";
}